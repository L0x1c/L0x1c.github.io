<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>内存管理 | L0x1c&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="VAD_私有内存 私有内存 像malloc, virtualalloc申请的内存都是私有内存, MapViewofFile, MapViewOfSize, mdl, 这种是映射的内存
这些内存是由一个叫做vadroot的节点来管理的, 可以看一下这个位置 这里如果后续想获取到这个位置的话, 因为每个版本的偏移可能不一样, 可以通过函数PsGetProcessExitStatus来获取对应的偏移 &#43; 4就是vadRoot win10上的结构
&#43;0x658 VadRoot : _RTL_AVL_TREE &#43;0x660 VadHint : 0xffff900f`4bf43e10 Void &#43;0x668 VadCount : 0xde VadRoot: _RTL_AVL_TREE 里面就是代表了二叉搜索树的节点, 而里面的每个节点的结构都是__MMVAD的结构, VadHint多次查询的节点会放在这里, VadCount代表vad节点的个数
kd&gt; dt _RTL_AVL_TREE ffff900f4c129400&#43;0x658 nt!_RTL_AVL_TREE &#43;0x000 Root : 0xffff900f`4bf44810 _RTL_BALANCED_NODE kd&gt; dt 0xffff900f`4bf44810 _RTL_BALANCED_NODE nt!_RTL_BALANCED_NODE &#43;0x000 Children : [2] 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE &#43;0x000 Left : 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE &#43;0x008 Right : 0xffff900f`4bfe65c0 _RTL_BALANCED_NODE &#43;0x010 Red : 0y0 &#43;0x010 Balance : 0y00 &#43;0x010 ParentValue : 0 !">
<meta name="author" content="L0x1c">
<link rel="canonical" href="https://l0x1c.com/posts/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://l0x1c.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://l0x1c.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://l0x1c.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://l0x1c.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://l0x1c.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="内存管理" />
<meta property="og:description" content="VAD_私有内存 私有内存 像malloc, virtualalloc申请的内存都是私有内存, MapViewofFile, MapViewOfSize, mdl, 这种是映射的内存
这些内存是由一个叫做vadroot的节点来管理的, 可以看一下这个位置 这里如果后续想获取到这个位置的话, 因为每个版本的偏移可能不一样, 可以通过函数PsGetProcessExitStatus来获取对应的偏移 &#43; 4就是vadRoot win10上的结构
&#43;0x658 VadRoot : _RTL_AVL_TREE &#43;0x660 VadHint : 0xffff900f`4bf43e10 Void &#43;0x668 VadCount : 0xde VadRoot: _RTL_AVL_TREE 里面就是代表了二叉搜索树的节点, 而里面的每个节点的结构都是__MMVAD的结构, VadHint多次查询的节点会放在这里, VadCount代表vad节点的个数
kd&gt; dt _RTL_AVL_TREE ffff900f4c129400&#43;0x658 nt!_RTL_AVL_TREE &#43;0x000 Root : 0xffff900f`4bf44810 _RTL_BALANCED_NODE kd&gt; dt 0xffff900f`4bf44810 _RTL_BALANCED_NODE nt!_RTL_BALANCED_NODE &#43;0x000 Children : [2] 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE &#43;0x000 Left : 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE &#43;0x008 Right : 0xffff900f`4bfe65c0 _RTL_BALANCED_NODE &#43;0x010 Red : 0y0 &#43;0x010 Balance : 0y00 &#43;0x010 ParentValue : 0 !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://l0x1c.com/posts/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" />
<meta property="og:image" content="https://l0x1c.com/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2025-06-09T22:32:09+08:00" />
<meta property="article:modified_time" content="2025-06-09T22:32:09+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://l0x1c.com/images/papermod-cover.png" />
<meta name="twitter:title" content="内存管理"/>
<meta name="twitter:description" content="VAD_私有内存 私有内存 像malloc, virtualalloc申请的内存都是私有内存, MapViewofFile, MapViewOfSize, mdl, 这种是映射的内存
这些内存是由一个叫做vadroot的节点来管理的, 可以看一下这个位置 这里如果后续想获取到这个位置的话, 因为每个版本的偏移可能不一样, 可以通过函数PsGetProcessExitStatus来获取对应的偏移 &#43; 4就是vadRoot win10上的结构
&#43;0x658 VadRoot : _RTL_AVL_TREE &#43;0x660 VadHint : 0xffff900f`4bf43e10 Void &#43;0x668 VadCount : 0xde VadRoot: _RTL_AVL_TREE 里面就是代表了二叉搜索树的节点, 而里面的每个节点的结构都是__MMVAD的结构, VadHint多次查询的节点会放在这里, VadCount代表vad节点的个数
kd&gt; dt _RTL_AVL_TREE ffff900f4c129400&#43;0x658 nt!_RTL_AVL_TREE &#43;0x000 Root : 0xffff900f`4bf44810 _RTL_BALANCED_NODE kd&gt; dt 0xffff900f`4bf44810 _RTL_BALANCED_NODE nt!_RTL_BALANCED_NODE &#43;0x000 Children : [2] 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE &#43;0x000 Left : 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE &#43;0x008 Right : 0xffff900f`4bfe65c0 _RTL_BALANCED_NODE &#43;0x010 Red : 0y0 &#43;0x010 Balance : 0y00 &#43;0x010 ParentValue : 0 !"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://l0x1c.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "内存管理",
      "item": "https://l0x1c.com/posts/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "内存管理",
  "name": "内存管理",
  "description": "VAD_私有内存 私有内存 像malloc, virtualalloc申请的内存都是私有内存, MapViewofFile, MapViewOfSize, mdl, 这种是映射的内存\n这些内存是由一个叫做vadroot的节点来管理的, 可以看一下这个位置 这里如果后续想获取到这个位置的话, 因为每个版本的偏移可能不一样, 可以通过函数PsGetProcessExitStatus来获取对应的偏移 + 4就是vadRoot win10上的结构\n+0x658 VadRoot : _RTL_AVL_TREE +0x660 VadHint : 0xffff900f`4bf43e10 Void +0x668 VadCount : 0xde VadRoot: _RTL_AVL_TREE 里面就是代表了二叉搜索树的节点, 而里面的每个节点的结构都是__MMVAD的结构, VadHint多次查询的节点会放在这里, VadCount代表vad节点的个数\nkd\u0026gt; dt _RTL_AVL_TREE ffff900f4c129400+0x658 nt!_RTL_AVL_TREE +0x000 Root : 0xffff900f`4bf44810 _RTL_BALANCED_NODE kd\u0026gt; dt 0xffff900f`4bf44810 _RTL_BALANCED_NODE nt!_RTL_BALANCED_NODE +0x000 Children : [2] 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE +0x000 Left : 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE +0x008 Right : 0xffff900f`4bfe65c0 _RTL_BALANCED_NODE +0x010 Red : 0y0 +0x010 Balance : 0y00 +0x010 ParentValue : 0 !",
  "keywords": [
    
  ],
  "articleBody": "VAD_私有内存 私有内存 像malloc, virtualalloc申请的内存都是私有内存, MapViewofFile, MapViewOfSize, mdl, 这种是映射的内存\n这些内存是由一个叫做vadroot的节点来管理的, 可以看一下这个位置 这里如果后续想获取到这个位置的话, 因为每个版本的偏移可能不一样, 可以通过函数PsGetProcessExitStatus来获取对应的偏移 + 4就是vadRoot win10上的结构\n+0x658 VadRoot : _RTL_AVL_TREE +0x660 VadHint : 0xffff900f`4bf43e10 Void +0x668 VadCount : 0xde VadRoot: _RTL_AVL_TREE 里面就是代表了二叉搜索树的节点, 而里面的每个节点的结构都是__MMVAD的结构, VadHint多次查询的节点会放在这里, VadCount代表vad节点的个数\nkd\u003e dt _RTL_AVL_TREE ffff900f4c129400+0x658 nt!_RTL_AVL_TREE +0x000 Root : 0xffff900f`4bf44810 _RTL_BALANCED_NODE kd\u003e dt 0xffff900f`4bf44810 _RTL_BALANCED_NODE nt!_RTL_BALANCED_NODE +0x000 Children : [2] 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE +0x000 Left : 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE +0x008 Right : 0xffff900f`4bfe65c0 _RTL_BALANCED_NODE +0x010 Red : 0y0 +0x010 Balance : 0y00 +0x010 ParentValue : 0 !vad即可查询 其中start和End代表了开始和结束, 都需要乘上pagesize -\u003e 0x1000其中end不一样(end + 1)*pagesize - 1, 里面的每一个节点都是_MMVAD的结构, 可以找一个私有内存看一下结构\nkd\u003e dt _MMVAD ffff900f4bf449a0 nt!_MMVAD +0x000 Core : _MMVAD_SHORT +0x040 u2 : +0x048 Subsection : 0x01dbdb86`7175af69 _SUBSECTION +0x050 FirstPrototypePte : (null) +0x058 LastContiguousPte : (null) +0x060 ViewLinks : _IST_ENTRY [ 0xffff900f`4bfe4540 - 0x00000026`00000020 ] +0x070 VadsProcess : (null) +0x078 u4 : +0x080 FileObject : 0x00000004`00100200 _FILE_OBJECT kd\u003e dt _MMVAD_SHORT ffff900f4bf449a0 nt!_MMVAD_SHORT +0x000 NextVad : 0xffff900f`4bfe4e00 _MMVAD_SHORT +0x008 ExtraCreateInfo : 0xffff900f`4bfe29c0 Void +0x000 VadNode : _RTL_BALANCED_NODE +0x018 StartingVpn : 0x160 +0x01c EndingVpn : 0x166 +0x020 StartingVpnHigh : 0 '' +0x021 c : 0 '' +0x022 CommitChargeHigh : 0 '' +0x023 SpareNT64VadUChar : 0 '' +0x024 ReferenceCount : 0n0 +0x028 PushLock : _EX_PUSH_LOCK +0x030 u : +0x034 u1 : +0x038 EventList : (null) 其中的__MMVAD_SHORT的前三个其实是union, 代表了下一个vad节点的地址, NextVad是左子树, ExtraCreateInfo是右子树\nStartingVpn, EndingVpn, StartingVpnHigh, StartingVpnHigh可以看一下MiLocateAddress的写法, win10会和win7有不同, 计算方式为(result-\u003eCore.StartingVpn | ((unsigned __int64)result-\u003eCore.StartingVpnHigh \u003c\u003c 32))和(result-\u003eCore.EndingVpn | ((unsigned __int64)result-\u003eCore.EndingVpnHigh \u003c\u003c 32)) 在_MMVAD_SHORT结构里有一项是u-\u003e_MMVAD_FLAGS结构, 其中的PrivateMemory代表了这里是不是私有内存, Protection代表了属性是多少, vadtype用于标记这段虚拟内存的用途或分配方式 看一下这个vadtype\n值（十进制） 名称 含义说明 0 VadNone 未指定类型（保留） 1 VadDevicePhysicalMemory 映射的物理设备内存 2 VadImageMap 映像（如 EXE、DLL 文件）映射 3 VadAwe 使用 AWE（Address Windowing Extensions）分配的内存 4 VadWriteWatch 启用了写监视（Write-Watch）的内存，用于检测哪些页面被写入 5 VadLargePages 使用大页（Large Pages）分配的内存 6 VadRotatePhysical 映射旋转的物理内存（罕见） 7 VadLargePageSection 段式大页分配（仅在某些版本支持） 看一下这个Protection, 看一下NtAllocateVirtualMemory这个函数里关于Protection的字段可以很好的定位到MiMakeProtectionMask这个函数\n看一下这个函数, 可以发现他把这个申请的内存属性分成了两个属性, 也刚好的在两个表中\n我们可以举一个例子, 假设是PAGE_EXECUTE_READWRITE = 0x40\n那么根据代码的逻辑, 他会被分成两个部分, 0100 0000一个是4一个是0, 那么就会在这个表中找一下, 因为第一个是0所以要直接在第二个表中找一下属性, 可以看到数组的第五个刚好是MM_EXECUTE_READWRITE 所以我们上面内存这个位置是0x4, 所以属性就是MM_READWRITE\n写了三个功能:\n1.打开IDA分析内核MiLocateAddress这个函数, 给一个R3地址, 返回一个VAD节点\n2.给一个进程ID, 解析出此进程的所有VAD节点\n3.移除内存所在vad节点的位置\n#include \"struct.h\" void RtlAvlRemoveNode(PVOID tree, PVOID node); PEPROCESS LookUpProcess(HANDLE Pid) { PEPROCESS eprocess = NULL; NTSTATUS Status = STATUS_UNSUCCESSFUL; Status = PsLookupProcessByProcessId(Pid, \u0026eprocess); if (NT_SUCCESS(Status)) return eprocess; return NULL; } ULONG64 GetVadOffset() { UNICODE_STRING func; RtlInitUnicodeString(\u0026func, L\"PsGetProcessExitStatus\"); ULONG64 funcAddr = MmGetSystemRoutineAddress(\u0026func); if (funcAddr == NULL) { return FALSE; } //8B 81 D4 07 00 00 mov eax, [rcx+7D4h] PUCHAR funcBytes = (PUCHAR)funcAddr; //DbgPrint(\"funcAddr : %p\\n\", funcAddr); //DbgPrint(\"funcBytes : %p\\n\", funcBytes); for (size_t i = 0; i \u003c 0x10; i++) { if (funcBytes[0] == 0x8B \u0026\u0026 funcBytes[1] == 0x81) { UINT32 offset = *(UINT32*)(funcBytes + 2); return offset + 0x4; } } return FALSE; } PMMVAD MiLocateAddress(PEPROCESS eProcess, ULONG64 virtualAddress) { PRTL_AVL_TREE vadRoot = (PRTL_AVL_TREE)((PUCHAR)eProcess + GetVadOffset()); if (!vadRoot || !vadRoot-\u003eRoot) { return NULL; // VAD tree is empty or invalid } PMMVAD vad = (PMMVAD)vadRoot-\u003eRoot; if (!MmIsAddressValid(vad)) { return NULL; } ULONG64 address = virtualAddress \u003e\u003e 12; if (address \u003c (vad-\u003eCore.StartingVpn | (vad-\u003eCore.StartingVpnHigh \u003c\u003c 32)) || address \u003e(vad-\u003eCore.EndingVpn | (vad-\u003eCore.EndingVpn \u003c\u003c 32))) { while (vad) { if (address \u003e (vad-\u003eCore.EndingVpn | (vad-\u003eCore.EndingVpnHigh \u003c\u003c 32))) { vad = (PMMVAD)vad-\u003eCore.VadNode.Right; } else { if (address \u003e= (vad-\u003eCore.StartingVpn | (vad-\u003eCore.StartingVpnHigh \u003c\u003c 32))) { return vad; } vad = (PMMVAD)vad-\u003eCore.VadNode.Left; } } } return NULL; } PVOID EnumVad(PMMVAD vad) { if (!vad) { return NULL; } PVOID stack[256]; int stackIndex = 0; stack[stackIndex++] = vad; while (stackIndex \u003e 0) { PMMVAD currentVad = (PMMVAD)stack[--stackIndex]; DbgPrintEx(77, 0, \"Vad: %p | start : %x | end : %x | vadflags : %x \\n\", currentVad, currentVad-\u003eCore.StartingVpn, currentVad-\u003eCore.EndingVpn, currentVad-\u003eCore.u.VadFlags); if (currentVad-\u003eCore.VadNode.Right) { stack[stackIndex++] = (PVOID)currentVad-\u003eCore.VadNode.Right; } if (currentVad-\u003eCore.VadNode.Left) { stack[stackIndex++] = (PVOID)currentVad-\u003eCore.VadNode.Left; } } return NULL; } PVOID ParserProcessVad(PEPROCESS eProcess) { PRTL_AVL_TREE vadRoot = (PRTL_AVL_TREE)((PUCHAR)eProcess + GetVadOffset()); if (!vadRoot || !vadRoot-\u003eRoot) { return NULL; // VAD tree is empty or invalid } ULONG64 vadCount = *(PULONG64)((PUCHAR)eProcess + GetVadOffset() + 0x10); PMMVAD vad = (PMMVAD)vadRoot-\u003eRoot; if (!MmIsAddressValid(vad)) { return NULL; } EnumVad(vad); } PVOID LockPageProction(PEPROCESS eProcess, ULONG64 virtualaddress, PMMVAD vad) { } PVOID RemoveVad(PEPROCESS eProcess, ULONG64 virtualaddress) { PMMVAD vad = MiLocateAddress(eProcess, virtualaddress); if (!MmIsAddressValid(vad)) { return NULL; } PRTL_AVL_TREE vadRoot = (PRTL_AVL_TREE)((PUCHAR)eProcess + GetVadOffset()); if (!vadRoot || !vadRoot-\u003eRoot) { return NULL; } RtlAvlRemoveNode(vadRoot, vad); ObReferenceObject(eProcess); } PVOID UnloadDriver( _In_ PDRIVER_OBJECT DriverObject ) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(77, 0, \"Driver unloaded successfully.\\n\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry( _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath ) { UNREFERENCED_PARAMETER(RegistryPath); DbgPrintEx(77, 0, \"Driver loaded successfully.\\n\"); //1. 分析内核 MiLocateAddress 这个函数，然后照抄此判断是: 给一个R3地址，返回一个VAD 节点 //2. 给一个进程ID，解析出此进程的所有VAD节点 //3. 代码实现WIN10 WIN11 私有内存锁页 //4. 移除内存所在vad节点的位置 //DbgBreakPoint(); PEPROCESS eproc = NULL; eproc = LookUpProcess(0x16c8); if (!eproc) { return STATUS_UNSUCCESSFUL; } UINT32 vadOffset = GetVadOffset(); if (!vadOffset) { return STATUS_UNSUCCESSFUL; } //1: over PMMVAD vad = MiLocateAddress(eproc, 0xDCE0000); DbgPrintEx(77, 0, \"Find Vad: %p\\n\", vad); /* +0x658 VadRoot : _RTL_AVL_TREE +0x660 VadHint : 0xffffce01`8de7d9a0 Void +0x668 VadCount : 0xaa +0x670 VadPhysicalPages : 0 +0x678 VadPhysicalPagesLimit : 0 */ //vadRoot是根节点, vadHint是上一次MiLocateAddress找到的指针, vadCount是vad的数量 //2: over ParserProcessVad(eproc); //3. over RemoveVad(eproc, 0xDCE0000); ObDereferenceObject(eproc); DriverObject-\u003eDriverUnload = UnloadDriver; return STATUS_SUCCESS; } VAD映射内存 Win10锁页 插入一个锁页的知识点, win10和win7有差别, 主要还是看win10, 直接看一下MmProtectVirtualMemory这个函数, 可以看到如果满足这两个逻辑的话, 就会返回失败\n测试一个, 用CE申请了一块内存, 看一下对应的 +0x30的位置, 因为上面的\u0026 0x3F800可以用不用考虑, 因为这个参数可以用的属性加起来也不会超过0x800所以这里为0, 那么我们让这个位置 Core.u.LongFlags \u0026 0x1100000 == 0x1100000 就可以了\n可以发现Graphics: 0y1 PrivateMemoryAlwaysSet: 0y1这个两个位置为1即可\n代码实现:\nPVOID LockVadProction(PEPROCESS eProcess, ULONG64 virtualaddress) { PMMVAD_SHORT vad = MiLocateAddress(eProcess, virtualaddress); if (!MmIsAddressValid(vad)) { return NULL; } vad-\u003eu.PrivateVadFlags.Graphics = 0x1; vad-\u003eu.PrivateVadFlags.PrivateMemoryAlwaysSet = 0x1; } 这样这个内存的页就不能被修改属性了\n映射内存 找一个map的内存看一下, MMVAD_SHORT的结构\nX64页表 页表自映射 页帧\n物理页是有一个地方去管理，管理的时候用的是数组，没有用链表，因为数组的查找很快，因为物理地址是频繁运行，所以必须有一个很快的算法 有一个这样的数组叫做：mmpfndatabase, 数组里的每一个元素都是mmpfn结构,\n数组的索引, pte的页帧 —\u003e 某些属性 + 页帧 + 属性\nmmpfndatabase[pte.页帧]\nx64分页\nx64 获取PTEbase\n#include ULONG64 g_PteAddress = 0; ULONG64 g_PdeAddress = 0; ULONG64 g_PpeAddress = 0; ULONG64 g_PxeAddress = 0; ULONG64 GetPteAddress(ULONG64 Address) { return (ULONG64)(((Address \u003e\u003e 9) \u0026 0x7FFFFFFFF8) + g_PteAddress); } ULONG64 GetPdeAddress(ULONG64 Address) { return (ULONG64)(((Address \u003e\u003e 9) \u0026 0x7FFFFFFFF8) + g_PteAddress); } ULONG64 GetPpeAddress(ULONG64 Address) { return (ULONG64)(((Address \u003e\u003e 9) \u0026 0x7FFFFFFFF8) + g_PteAddress); } ULONG64 GetPxeAddress(ULONG64 Address) { return (ULONG64)(((Address \u003e\u003e 9) \u0026 0x7FFFFFFFF8) + g_PteAddress); } VOID GetFourTableBASE() { ULONG64 DirectoryTableBase = *(PULONG64)((PUCHAR)PsInitialSystemProcess + 0x28); //后12位属性 DirectoryTableBase \u0026= ~0xFFF; PHYSICAL_ADDRESS address; address.QuadPart = DirectoryTableBase; PULONG64 VirtualDirectorBase = MmGetVirtualForPhysical(address); ULONG64 index = -1; for (size_t i = 0; i \u003c 512; i++) { ULONG64 data = VirtualDirectorBase[i]; //8000 0000001aa063 //48 0xFFFFFFFFFFFF //ULONG64 testData = ((data \u0026 ~0xFFF) \u0026 0xFFFFFFFFFFFF); if (DirectoryTableBase == ((data \u0026 ~0xFFF) \u0026 0xFFFFFFFFFFFF)) { index = i; break; } } if (index != -1) { g_PteAddress = (index + 0x1FFFE00) \u003c\u003c 39; g_PdeAddress = (index \u003c\u003c 30) + g_PteAddress; g_PpeAddress = (index \u003c\u003c 21) + g_PdeAddress; g_PxeAddress = (index \u003c\u003c 12) + g_PpeAddress; } } VOID DriverUnload(PDRIVER_OBJECT pDriver) { } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pSeg) { //1. 获取pte的基址 （ MmGetVirtualForPhysical ） //2. 解析 返回PTE PDE PDPTE PML4的地址 ( MmIsAddressValidEx ) //1. over DbgBreakPoint(); GetFourTableBASE(); if (g_PteAddress != NULL) { DbgPrintEx(77, 0, \"PTEBASE: %p\\n\", g_PteAddress); DbgPrintEx(77, 0, \"PDEBASE: %p\\n\", g_PdeAddress); DbgPrintEx(77, 0, \"PPEBASE: %p\\n\", g_PpeAddress); DbgPrintEx(77, 0, \"PXEBASE: %p\\n\", g_PxeAddress); } else { DbgPrintEx(77, 0, \"ERROR\\n\"); } //2. over ULONG64 gdtr = 0xfffff80258bc4fb0; ULONG64 gdtrPte = GetPteAddress(gdtr); ULONG64 gdtrPde = GetPdeAddress(gdtrPte); ULONG64 gdtrPpe = GetPpeAddress(gdtrPde); ULONG64 gdtrPxe = GetPxeAddress(gdtrPpe); DbgPrintEx(77, 0, \"gdtrPte: %p\\n\", gdtrPte); DbgPrintEx(77, 0, \"gdtrPde: %p\\n\", gdtrPde); DbgPrintEx(77, 0, \"gdtrPpe: %p\\n\", gdtrPpe); DbgPrintEx(77, 0, \"gdtrPxe: %p\\n\", gdtrPxe); pDriver-\u003eDriverUnload = DriverUnload; return STATUS_SUCCESS; } PTE的原型 原型PTE本质上就是我们PTE的生命周期\n我们的dll还有exe是多个进程共用一个文件的存在，重新创建一个进程跑起来，还是会使用dll，\nallocatememory 当我们申请内存的时候，如果一次都没有访问过，是一个没有挂物理页的虚拟地址，当我们访问一下的时候，此时回给他挂上物理页\n上面的四种当我们申请内存的时候有可能是空的, d的表述, 此时申请完，我们去访问的时候，会发生页异常错误，抛给14号中断，判断是用户态模式还是内核态的模式，内核态的话直接就蓝屏，因为内核态模式是没有vad的，在用户态还要去检测一下有没有vad，如果在vad中，而且保护属性不是noaccess的话，其他的页属性的话会进一步的去给他挂物理页然后去修复\n",
  "wordCount" : "1130",
  "inLanguage": "en",
  "image": "https://l0x1c.com/images/papermod-cover.png","datePublished": "2025-06-09T22:32:09+08:00",
  "dateModified": "2025-06-09T22:32:09+08:00",
  "author":{
    "@type": "Person",
    "name": "L0x1c"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://l0x1c.com/posts/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "L0x1c's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://l0x1c.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://l0x1c.com/" accesskey="h" title="L0x1c&#39;s Blog (Alt + H)">L0x1c&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://l0x1c.com/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://l0x1c.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://l0x1c.com/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://l0x1c.com/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://l0x1c.com/">Home</a>&nbsp;»&nbsp;<a href="https://l0x1c.com/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      内存管理
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h1>
    <div class="post-meta"><span title='2025-06-09 22:32:09 +0800 +0800'>June 9, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;L0x1c

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#vad_%e7%a7%81%e6%9c%89%e5%86%85%e5%ad%98" aria-label="VAD_私有内存">VAD_私有内存</a><ul>
                        
                <li>
                    <a href="#%e7%a7%81%e6%9c%89%e5%86%85%e5%ad%98" aria-label="私有内存">私有内存</a></li></ul>
                </li>
                <li>
                    <a href="#vad%e6%98%a0%e5%b0%84%e5%86%85%e5%ad%98" aria-label="VAD映射内存">VAD映射内存</a><ul>
                        
                <li>
                    <a href="#win10%e9%94%81%e9%a1%b5" aria-label="Win10锁页">Win10锁页</a></li>
                <li>
                    <a href="#%e6%98%a0%e5%b0%84%e5%86%85%e5%ad%98" aria-label="映射内存">映射内存</a></li></ul>
                </li>
                <li>
                    <a href="#x64%e9%a1%b5%e8%a1%a8" aria-label="X64页表">X64页表</a><ul>
                        
                <li>
                    <a href="#%e9%a1%b5%e8%a1%a8%e8%87%aa%e6%98%a0%e5%b0%84" aria-label="页表自映射">页表自映射</a></li></ul>
                </li>
                <li>
                    <a href="#pte%e7%9a%84%e5%8e%9f%e5%9e%8b" aria-label="PTE的原型">PTE的原型</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="vad_私有内存">VAD_私有内存<a hidden class="anchor" aria-hidden="true" href="#vad_私有内存">#</a></h1>
<h2 id="私有内存">私有内存<a hidden class="anchor" aria-hidden="true" href="#私有内存">#</a></h2>
<p>像<code>malloc</code>, <code>virtualalloc</code>申请的内存都是私有内存, <code>MapViewofFile</code>, <code>MapViewOfSize</code>, <code>mdl</code>, 这种是映射的内存</p>
<p>这些内存是由一个叫做<code>vadroot</code>的节点来管理的, 可以看一下这个位置
<img loading="lazy" src="image-1.png" alt="alt text"  />

这里如果后续想获取到这个位置的话, 因为每个版本的偏移可能不一样, 可以通过函数<code>PsGetProcessExitStatus</code>来获取对应的偏移 + 4就是<code>vadRoot</code>
<code>win10</code>上的结构</p>
<pre tabindex="0"><code>   +0x658 VadRoot          : _RTL_AVL_TREE
   +0x660 VadHint          : 0xffff900f`4bf43e10 Void
   +0x668 VadCount         : 0xde
</code></pre><p><code>VadRoot: _RTL_AVL_TREE</code> 里面就是代表了二叉搜索树的节点, 而里面的每个节点的结构都是<code>__MMVAD</code>的结构, <code>VadHint</code>多次查询的节点会放在这里, <code>VadCount</code>代表vad节点的个数</p>
<pre tabindex="0"><code>kd&gt; dt _RTL_AVL_TREE ffff900f4c129400+0x658
nt!_RTL_AVL_TREE
   +0x000 Root             : 0xffff900f`4bf44810 _RTL_BALANCED_NODE
kd&gt; dt 0xffff900f`4bf44810 _RTL_BALANCED_NODE
nt!_RTL_BALANCED_NODE
   +0x000 Children         : [2] 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE
   +0x000 Left             : 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE
   +0x008 Right            : 0xffff900f`4bfe65c0 _RTL_BALANCED_NODE
   +0x010 Red              : 0y0
   +0x010 Balance          : 0y00
   +0x010 ParentValue      : 0
</code></pre><p><code>!vad</code>即可查询
<img loading="lazy" src="image-2.png" alt="alt text"  />

其中<code>start</code>和<code>End</code>代表了开始和结束, 都需要乘上<code>pagesize -&gt; 0x1000</code>其中<code>end</code>不一样<code>(end + 1)*pagesize - 1</code>, 里面的每一个节点都是<code>_MMVAD</code>的结构, 可以找一个私有内存看一下结构</p>
<pre tabindex="0"><code>kd&gt; dt _MMVAD ffff900f4bf449a0
nt!_MMVAD
   +0x000 Core             : _MMVAD_SHORT
   +0x040 u2               : &lt;anonymous-tag&gt;
   +0x048 Subsection       : 0x01dbdb86`7175af69 _SUBSECTION
   +0x050 FirstPrototypePte : (null) 
   +0x058 LastContiguousPte : (null) 
   +0x060 ViewLinks        : _IST_ENTRY [ 0xffff900f`4bfe4540 - 0x00000026`00000020 ]
   +0x070 VadsProcess      : (null) 
   +0x078 u4               : &lt;anonymous-tag&gt;
   +0x080 FileObject       : 0x00000004`00100200 _FILE_OBJECT

kd&gt; dt _MMVAD_SHORT ffff900f4bf449a0
nt!_MMVAD_SHORT
   +0x000 NextVad          : 0xffff900f`4bfe4e00 _MMVAD_SHORT
   +0x008 ExtraCreateInfo  : 0xffff900f`4bfe29c0 Void
   +0x000 VadNode          : _RTL_BALANCED_NODE
   +0x018 StartingVpn      : 0x160
   +0x01c EndingVpn        : 0x166
   +0x020 StartingVpnHigh  : 0 &#39;&#39;
   +0x021 c    : 0 &#39;&#39;
   +0x022 CommitChargeHigh : 0 &#39;&#39;
   +0x023 SpareNT64VadUChar : 0 &#39;&#39;
   +0x024 ReferenceCount   : 0n0
   +0x028 PushLock         : _EX_PUSH_LOCK
   +0x030 u                : &lt;anonymous-tag&gt;
   +0x034 u1               : &lt;anonymous-tag&gt;
   +0x038 EventList        : (null)
</code></pre><p>其中的<code>__MMVAD_SHORT</code>的前三个其实是<code>union</code>, 代表了下一个<code>vad</code>节点的地址, <code>NextVad</code>是左子树, <code>ExtraCreateInfo</code>是右子树</p>
<p><code>StartingVpn</code>, <code>EndingVpn</code>, <code>StartingVpnHigh</code>, <code>StartingVpnHigh</code>可以看一下<code>MiLocateAddress</code>的写法, <code>win10</code>会和<code>win7</code>有不同, 计算方式为<code>(result-&gt;Core.StartingVpn | ((unsigned __int64)result-&gt;Core.StartingVpnHigh &lt;&lt; 32))</code>和<code>(result-&gt;Core.EndingVpn | ((unsigned __int64)result-&gt;Core.EndingVpnHigh &lt;&lt; 32))</code>
<img loading="lazy" src="image.png" alt="alt text"  />
</p>
<p>在<code>_MMVAD_SHORT</code>结构里有一项是<code>u</code>-&gt;<code>_MMVAD_FLAGS</code>结构, 其中的<code>PrivateMemory</code>代表了这里是不是私有内存, <code>Protection</code>代表了属性是多少, <code>vadtype</code>用于标记这段虚拟内存的用途或分配方式
<img loading="lazy" src="image-3.png" alt="alt text"  />
</p>
<p>看一下这个<code>vadtype</code></p>
<table>
<thead>
<tr>
<th>值（十进制）</th>
<th>名称</th>
<th>含义说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>VadNone</code></td>
<td>未指定类型（保留）</td>
</tr>
<tr>
<td>1</td>
<td><code>VadDevicePhysicalMemory</code></td>
<td>映射的物理设备内存</td>
</tr>
<tr>
<td>2</td>
<td><code>VadImageMap</code></td>
<td>映像（如 EXE、DLL 文件）映射</td>
</tr>
<tr>
<td>3</td>
<td><code>VadAwe</code></td>
<td>使用 AWE（Address Windowing Extensions）分配的内存</td>
</tr>
<tr>
<td>4</td>
<td><code>VadWriteWatch</code></td>
<td>启用了写监视（Write-Watch）的内存，用于检测哪些页面被写入</td>
</tr>
<tr>
<td>5</td>
<td><code>VadLargePages</code></td>
<td>使用大页（Large Pages）分配的内存</td>
</tr>
<tr>
<td>6</td>
<td><code>VadRotatePhysical</code></td>
<td>映射旋转的物理内存（罕见）</td>
</tr>
<tr>
<td>7</td>
<td><code>VadLargePageSection</code></td>
<td>段式大页分配（仅在某些版本支持）</td>
</tr>
</tbody>
</table>
<p><img loading="lazy" src="image-4.png" alt="alt text"  />
</p>
<p>看一下这个<code>Protection</code>, 看一下<code>NtAllocateVirtualMemory</code>这个函数里关于<code>Protection</code>的字段可以很好的定位到<code>MiMakeProtectionMask</code>这个函数</p>
<p><img loading="lazy" src="image-5.png" alt="alt text"  />
</p>
<p>看一下这个函数, 可以发现他把这个申请的内存属性分成了两个属性, 也刚好的在两个表中</p>
<p><img loading="lazy" src="image-6.png" alt="alt text"  />
</p>
<p>我们可以举一个例子, 假设是<code>PAGE_EXECUTE_READWRITE = 0x40</code></p>
<p><img loading="lazy" src="image-7.png" alt="alt text"  />
</p>
<p>那么根据代码的逻辑, 他会被分成两个部分, <code>0100 0000</code>一个是4一个是0, 那么就会在这个表中找一下, 因为第一个是0所以要直接在第二个表中找一下属性, 可以看到数组的第五个刚好是<code>MM_EXECUTE_READWRITE</code>
<img loading="lazy" src="image-8.png" alt="alt text"  />
</p>
<p>所以我们上面内存这个位置是0x4, 所以属性就是<code>MM_READWRITE</code></p>
<p><img loading="lazy" src="image-9.png" alt="alt text"  />
</p>
<p>写了三个功能:</p>
<p>1.打开IDA分析内核MiLocateAddress这个函数, 给一个R3地址, 返回一个VAD节点</p>
<p>2.给一个进程ID, 解析出此进程的所有VAD节点</p>
<p>3.移除内存所在vad节点的位置</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;struct.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">RtlAvlRemoveNode</span><span class="p">(</span><span class="n">PVOID</span> <span class="n">tree</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PEPROCESS</span> <span class="nf">LookUpProcess</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">Pid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">PEPROCESS</span> <span class="n">eprocess</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">NTSTATUS</span> <span class="n">Status</span> <span class="o">=</span> <span class="n">STATUS_UNSUCCESSFUL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">Status</span> <span class="o">=</span> <span class="nf">PsLookupProcessByProcessId</span><span class="p">(</span><span class="n">Pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eprocess</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">NT_SUCCESS</span><span class="p">(</span><span class="n">Status</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">eprocess</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ULONG64</span> <span class="nf">GetVadOffset</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">UNICODE_STRING</span> <span class="n">func</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">RtlInitUnicodeString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">func</span><span class="p">,</span> <span class="sa">L</span><span class="s">&#34;PsGetProcessExitStatus&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ULONG64</span> <span class="n">funcAddr</span> <span class="o">=</span> <span class="nf">MmGetSystemRoutineAddress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">func</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">funcAddr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//8B 81 D4 07 00 00                       mov     eax, [rcx+7D4h]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">PUCHAR</span> <span class="n">funcBytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">funcAddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//DbgPrint(&#34;funcAddr : %p\n&#34;, funcAddr);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//DbgPrint(&#34;funcBytes : %p\n&#34;, funcBytes);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">funcBytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x8B</span> <span class="o">&amp;&amp;</span> <span class="n">funcBytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x81</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">UINT32</span> <span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">UINT32</span><span class="o">*</span><span class="p">)(</span><span class="n">funcBytes</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">offset</span> <span class="o">+</span> <span class="mh">0x4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PMMVAD</span> <span class="nf">MiLocateAddress</span><span class="p">(</span><span class="n">PEPROCESS</span> <span class="n">eProcess</span><span class="p">,</span> <span class="n">ULONG64</span> <span class="n">virtualAddress</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">PRTL_AVL_TREE</span> <span class="n">vadRoot</span> <span class="o">=</span> <span class="p">(</span><span class="n">PRTL_AVL_TREE</span><span class="p">)((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">eProcess</span> <span class="o">+</span> <span class="nf">GetVadOffset</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vadRoot</span> <span class="o">||</span> <span class="o">!</span><span class="n">vadRoot</span><span class="o">-&gt;</span><span class="n">Root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// VAD tree is empty or invalid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">PMMVAD</span> <span class="n">vad</span> <span class="o">=</span> <span class="p">(</span><span class="n">PMMVAD</span><span class="p">)</span><span class="n">vadRoot</span><span class="o">-&gt;</span><span class="n">Root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">MmIsAddressValid</span><span class="p">(</span><span class="n">vad</span><span class="p">))</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">ULONG64</span> <span class="n">address</span> <span class="o">=</span> <span class="n">virtualAddress</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">vad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">StartingVpn</span> <span class="o">|</span> <span class="p">(</span><span class="n">vad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">StartingVpnHigh</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">))</span> <span class="o">||</span> <span class="n">address</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">vad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">EndingVpn</span> <span class="o">|</span> <span class="p">(</span><span class="n">vad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">EndingVpn</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">while</span> <span class="p">(</span><span class="n">vad</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">vad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">EndingVpn</span> <span class="o">|</span> <span class="p">(</span><span class="n">vad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">EndingVpnHigh</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">vad</span> <span class="o">=</span> <span class="p">(</span><span class="n">PMMVAD</span><span class="p">)</span><span class="n">vad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">VadNode</span><span class="p">.</span><span class="n">Right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">else</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">vad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">StartingVpn</span> <span class="o">|</span> <span class="p">(</span><span class="n">vad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">StartingVpnHigh</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">				<span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="k">return</span> <span class="n">vad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="n">vad</span> <span class="o">=</span> <span class="p">(</span><span class="n">PMMVAD</span><span class="p">)</span><span class="n">vad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">VadNode</span><span class="p">.</span><span class="n">Left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PVOID</span> <span class="nf">EnumVad</span><span class="p">(</span><span class="n">PMMVAD</span> <span class="n">vad</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vad</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">PVOID</span> <span class="n">stack</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">stackIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">stack</span><span class="p">[</span><span class="n">stackIndex</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">vad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">stackIndex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">PMMVAD</span> <span class="n">currentVad</span> <span class="o">=</span> <span class="p">(</span><span class="n">PMMVAD</span><span class="p">)</span><span class="n">stack</span><span class="p">[</span><span class="o">--</span><span class="n">stackIndex</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">DbgPrintEx</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;Vad: %p | start : %x | end : %x | vadflags : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="n">currentVad</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="n">currentVad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">StartingVpn</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="n">currentVad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">EndingVpn</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="n">currentVad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">VadFlags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">currentVad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">VadNode</span><span class="p">.</span><span class="n">Right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">stack</span><span class="p">[</span><span class="n">stackIndex</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">currentVad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">VadNode</span><span class="p">.</span><span class="n">Right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">currentVad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">VadNode</span><span class="p">.</span><span class="n">Left</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">stack</span><span class="p">[</span><span class="n">stackIndex</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">currentVad</span><span class="o">-&gt;</span><span class="n">Core</span><span class="p">.</span><span class="n">VadNode</span><span class="p">.</span><span class="n">Left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PVOID</span> <span class="nf">ParserProcessVad</span><span class="p">(</span><span class="n">PEPROCESS</span> <span class="n">eProcess</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">PRTL_AVL_TREE</span> <span class="n">vadRoot</span> <span class="o">=</span> <span class="p">(</span><span class="n">PRTL_AVL_TREE</span><span class="p">)((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">eProcess</span> <span class="o">+</span> <span class="nf">GetVadOffset</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vadRoot</span> <span class="o">||</span> <span class="o">!</span><span class="n">vadRoot</span><span class="o">-&gt;</span><span class="n">Root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// VAD tree is empty or invalid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">ULONG64</span> <span class="n">vadCount</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">PULONG64</span><span class="p">)((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">eProcess</span> <span class="o">+</span> <span class="nf">GetVadOffset</span><span class="p">()</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">PMMVAD</span> <span class="n">vad</span> <span class="o">=</span> <span class="p">(</span><span class="n">PMMVAD</span><span class="p">)</span><span class="n">vadRoot</span><span class="o">-&gt;</span><span class="n">Root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">MmIsAddressValid</span><span class="p">(</span><span class="n">vad</span><span class="p">))</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">EnumVad</span><span class="p">(</span><span class="n">vad</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PVOID</span> <span class="nf">LockPageProction</span><span class="p">(</span><span class="n">PEPROCESS</span> <span class="n">eProcess</span><span class="p">,</span> <span class="n">ULONG64</span> <span class="n">virtualaddress</span><span class="p">,</span> <span class="n">PMMVAD</span> <span class="n">vad</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PVOID</span> <span class="nf">RemoveVad</span><span class="p">(</span><span class="n">PEPROCESS</span> <span class="n">eProcess</span><span class="p">,</span> <span class="n">ULONG64</span> <span class="n">virtualaddress</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">PMMVAD</span> <span class="n">vad</span> <span class="o">=</span> <span class="nf">MiLocateAddress</span><span class="p">(</span><span class="n">eProcess</span><span class="p">,</span> <span class="n">virtualaddress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">MmIsAddressValid</span><span class="p">(</span><span class="n">vad</span><span class="p">))</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">PRTL_AVL_TREE</span> <span class="n">vadRoot</span> <span class="o">=</span> <span class="p">(</span><span class="n">PRTL_AVL_TREE</span><span class="p">)((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">eProcess</span> <span class="o">+</span> <span class="nf">GetVadOffset</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vadRoot</span> <span class="o">||</span> <span class="o">!</span><span class="n">vadRoot</span><span class="o">-&gt;</span><span class="n">Root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">RtlAvlRemoveNode</span><span class="p">(</span><span class="n">vadRoot</span><span class="p">,</span> <span class="n">vad</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">ObReferenceObject</span><span class="p">(</span><span class="n">eProcess</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PVOID</span> <span class="nf">UnloadDriver</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="n">_In_</span> <span class="n">PDRIVER_OBJECT</span> <span class="n">DriverObject</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">UNREFERENCED_PARAMETER</span><span class="p">(</span><span class="n">DriverObject</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">DbgPrintEx</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;Driver unloaded successfully.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">NTSTATUS</span> <span class="nf">DriverEntry</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="n">_In_</span> <span class="n">PDRIVER_OBJECT</span> <span class="n">DriverObject</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="n">_In_</span> <span class="n">PUNICODE_STRING</span> <span class="n">RegistryPath</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">UNREFERENCED_PARAMETER</span><span class="p">(</span><span class="n">RegistryPath</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">DbgPrintEx</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;Driver loaded successfully.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//1. 分析内核 MiLocateAddress 这个函数，然后照抄此判断是: 给一个R3地址，返回一个VAD 节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//2. 给一个进程ID，解析出此进程的所有VAD节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//3. 代码实现WIN10 WIN11 私有内存锁页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//4. 移除内存所在vad节点的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">//DbgBreakPoint();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="n">PEPROCESS</span> <span class="n">eproc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">eproc</span> <span class="o">=</span> <span class="nf">LookUpProcess</span><span class="p">(</span><span class="mh">0x16c8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eproc</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">STATUS_UNSUCCESSFUL</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">UINT32</span> <span class="n">vadOffset</span> <span class="o">=</span> <span class="nf">GetVadOffset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vadOffset</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">STATUS_UNSUCCESSFUL</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//1: over
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">PMMVAD</span> <span class="n">vad</span> <span class="o">=</span> <span class="nf">MiLocateAddress</span><span class="p">(</span><span class="n">eproc</span><span class="p">,</span> <span class="mh">0xDCE0000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">DbgPrintEx</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;Find Vad: %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">vad</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	+0x658 VadRoot          : _RTL_AVL_TREE
</span></span></span><span class="line"><span class="cl"><span class="cm">	+0x660 VadHint          : 0xffffce01`8de7d9a0 Void
</span></span></span><span class="line"><span class="cl"><span class="cm">	+0x668 VadCount         : 0xaa
</span></span></span><span class="line"><span class="cl"><span class="cm">	+0x670 VadPhysicalPages : 0
</span></span></span><span class="line"><span class="cl"><span class="cm">	+0x678 VadPhysicalPagesLimit : 0
</span></span></span><span class="line"><span class="cl"><span class="cm">	*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//vadRoot是根节点, vadHint是上一次MiLocateAddress找到的指针, vadCount是vad的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">//2: over
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">ParserProcessVad</span><span class="p">(</span><span class="n">eproc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//3. over
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">RemoveVad</span><span class="p">(</span><span class="n">eproc</span><span class="p">,</span> <span class="mh">0xDCE0000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">ObDereferenceObject</span><span class="p">(</span><span class="n">eproc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">DriverObject</span><span class="o">-&gt;</span><span class="n">DriverUnload</span> <span class="o">=</span> <span class="n">UnloadDriver</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="vad映射内存">VAD映射内存<a hidden class="anchor" aria-hidden="true" href="#vad映射内存">#</a></h1>
<h2 id="win10锁页">Win10锁页<a hidden class="anchor" aria-hidden="true" href="#win10锁页">#</a></h2>
<p>插入一个锁页的知识点, <code>win10</code>和<code>win7</code>有差别, 主要还是看<code>win10</code>, 直接看一下<code>MmProtectVirtualMemory</code>这个函数, 可以看到如果满足这两个逻辑的话, 就会返回失败</p>
<p><img loading="lazy" src="image-10.png" alt="alt text"  />
</p>
<p>测试一个, 用<code>CE</code>申请了一块内存, 看一下对应的 <code>+0x30</code>的位置, 因为上面的<code>&amp; 0x3F800</code>可以用不用考虑, 因为这个参数可以用的属性加起来也不会超过<code>0x800</code>所以这里为<code>0</code>, 那么我们让这个位置 <code>Core.u.LongFlags &amp; 0x1100000 == 0x1100000</code> 就可以了</p>
<p><img loading="lazy" src="image-11.png" alt="alt text"  />
</p>
<p>可以发现<code>Graphics: 0y1 PrivateMemoryAlwaysSet: 0y1</code>这个两个位置为<code>1</code>即可</p>
<p><img loading="lazy" src="image-12.png" alt="alt text"  />
</p>
<p>代码实现:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">PVOID</span> <span class="nf">LockVadProction</span><span class="p">(</span><span class="n">PEPROCESS</span> <span class="n">eProcess</span><span class="p">,</span> <span class="n">ULONG64</span> <span class="n">virtualaddress</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">PMMVAD_SHORT</span> <span class="n">vad</span> <span class="o">=</span> <span class="nf">MiLocateAddress</span><span class="p">(</span><span class="n">eProcess</span><span class="p">,</span> <span class="n">virtualaddress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">MmIsAddressValid</span><span class="p">(</span><span class="n">vad</span><span class="p">))</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">vad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">PrivateVadFlags</span><span class="p">.</span><span class="n">Graphics</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">vad</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">PrivateVadFlags</span><span class="p">.</span><span class="n">PrivateMemoryAlwaysSet</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这样这个内存的页就不能被修改属性了</p>
<h2 id="映射内存">映射内存<a hidden class="anchor" aria-hidden="true" href="#映射内存">#</a></h2>
<p>找一个<code>map</code>的内存看一下, <code>MMVAD_SHORT</code>的结构</p>
<h1 id="x64页表">X64页表<a hidden class="anchor" aria-hidden="true" href="#x64页表">#</a></h1>
<h2 id="页表自映射">页表自映射<a hidden class="anchor" aria-hidden="true" href="#页表自映射">#</a></h2>
<p>页帧</p>
<p>物理页是有一个地方去管理，管理的时候用的是数组，没有用链表，因为数组的查找很快，因为物理地址是频繁运行，所以必须有一个很快的算法
有一个这样的数组叫做：<code>mmpfndatabase</code>, 数组里的每一个元素都是<code>mmpfn</code>结构,</p>
<p>数组的索引, pte的页帧 &mdash;&gt; 某些属性 + 页帧 + 属性</p>
<p>mmpfndatabase[pte.页帧]</p>
<p>x64分页</p>
<p>x64 获取PTEbase</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ntifs.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">ULONG64</span> <span class="n">g_PteAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ULONG64</span> <span class="n">g_PdeAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ULONG64</span> <span class="n">g_PpeAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ULONG64</span> <span class="n">g_PxeAddress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ULONG64</span> <span class="nf">GetPteAddress</span><span class="p">(</span><span class="n">ULONG64</span> <span class="n">Address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="n">ULONG64</span><span class="p">)(((</span><span class="n">Address</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7FFFFFFFF8</span><span class="p">)</span> <span class="o">+</span> <span class="n">g_PteAddress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ULONG64</span> <span class="nf">GetPdeAddress</span><span class="p">(</span><span class="n">ULONG64</span> <span class="n">Address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="n">ULONG64</span><span class="p">)(((</span><span class="n">Address</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7FFFFFFFF8</span><span class="p">)</span> <span class="o">+</span> <span class="n">g_PteAddress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ULONG64</span> <span class="nf">GetPpeAddress</span><span class="p">(</span><span class="n">ULONG64</span> <span class="n">Address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="n">ULONG64</span><span class="p">)(((</span><span class="n">Address</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7FFFFFFFF8</span><span class="p">)</span> <span class="o">+</span> <span class="n">g_PteAddress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ULONG64</span> <span class="nf">GetPxeAddress</span><span class="p">(</span><span class="n">ULONG64</span> <span class="n">Address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="n">ULONG64</span><span class="p">)(((</span><span class="n">Address</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7FFFFFFFF8</span><span class="p">)</span> <span class="o">+</span> <span class="n">g_PteAddress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">VOID</span> <span class="nf">GetFourTableBASE</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">ULONG64</span> <span class="n">DirectoryTableBase</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">PULONG64</span><span class="p">)((</span><span class="n">PUCHAR</span><span class="p">)</span><span class="n">PsInitialSystemProcess</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//后12位属性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">DirectoryTableBase</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0xFFF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">PHYSICAL_ADDRESS</span> <span class="n">address</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">address</span><span class="p">.</span><span class="n">QuadPart</span> <span class="o">=</span> <span class="n">DirectoryTableBase</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">PULONG64</span> <span class="n">VirtualDirectorBase</span> <span class="o">=</span> <span class="nf">MmGetVirtualForPhysical</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ULONG64</span> <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">ULONG64</span> <span class="n">data</span> <span class="o">=</span> <span class="n">VirtualDirectorBase</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//8000 0000001aa063
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//48 0xFFFFFFFFFFFF
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//ULONG64 testData = ((data &amp; ~0xFFF) &amp; 0xFFFFFFFFFFFF);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">DirectoryTableBase</span> <span class="o">==</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xFFF</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFFFFF</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">g_PteAddress</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mh">0x1FFFE00</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">39</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">g_PdeAddress</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">+</span> <span class="n">g_PteAddress</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">g_PpeAddress</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span><span class="p">)</span> <span class="o">+</span> <span class="n">g_PdeAddress</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">g_PxeAddress</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">+</span> <span class="n">g_PpeAddress</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">VOID</span> <span class="nf">DriverUnload</span><span class="p">(</span><span class="n">PDRIVER_OBJECT</span> <span class="n">pDriver</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">NTSTATUS</span> <span class="nf">DriverEntry</span><span class="p">(</span><span class="n">PDRIVER_OBJECT</span> <span class="n">pDriver</span><span class="p">,</span> <span class="n">PUNICODE_STRING</span> <span class="n">pSeg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//1. 获取pte的基址 （ MmGetVirtualForPhysical ）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//2. 解析 返回PTE PDE PDPTE PML4的地址 ( MmIsAddressValidEx ) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">//1. over
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nf">DbgBreakPoint</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">GetFourTableBASE</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">g_PteAddress</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">DbgPrintEx</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;PTEBASE: %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">g_PteAddress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">DbgPrintEx</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;PDEBASE: %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">g_PdeAddress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">DbgPrintEx</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;PPEBASE: %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">g_PpeAddress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">DbgPrintEx</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;PXEBASE: %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">g_PxeAddress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">DbgPrintEx</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;ERROR</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//2. over
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	
</span></span><span class="line"><span class="cl">	<span class="n">ULONG64</span> <span class="n">gdtr</span> <span class="o">=</span> <span class="mh">0xfffff80258bc4fb0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">ULONG64</span> <span class="n">gdtrPte</span> <span class="o">=</span> <span class="nf">GetPteAddress</span><span class="p">(</span><span class="n">gdtr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ULONG64</span> <span class="n">gdtrPde</span> <span class="o">=</span> <span class="nf">GetPdeAddress</span><span class="p">(</span><span class="n">gdtrPte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ULONG64</span> <span class="n">gdtrPpe</span> <span class="o">=</span> <span class="nf">GetPpeAddress</span><span class="p">(</span><span class="n">gdtrPde</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ULONG64</span> <span class="n">gdtrPxe</span> <span class="o">=</span> <span class="nf">GetPxeAddress</span><span class="p">(</span><span class="n">gdtrPpe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">DbgPrintEx</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;gdtrPte: %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">gdtrPte</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">DbgPrintEx</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;gdtrPde: %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">gdtrPde</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">DbgPrintEx</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;gdtrPpe: %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">gdtrPpe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">DbgPrintEx</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;gdtrPxe: %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">gdtrPxe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">pDriver</span><span class="o">-&gt;</span><span class="n">DriverUnload</span> <span class="o">=</span> <span class="n">DriverUnload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">STATUS_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="pte的原型">PTE的原型<a hidden class="anchor" aria-hidden="true" href="#pte的原型">#</a></h1>
<p>原型PTE本质上就是我们PTE的生命周期</p>
<p>我们的dll还有exe是多个进程共用一个文件的存在，重新创建一个进程跑起来，还是会使用dll，</p>
<p>allocatememory 当我们申请内存的时候，如果一次都没有访问过，是一个没有挂物理页的虚拟地址，当我们访问一下的时候，此时回给他挂上物理页</p>
<p><img loading="lazy" src="image-13.png" alt="alt text"  />
</p>
<p>上面的四种当我们申请内存的时候有可能是空的, d的表述, 此时申请完，我们去访问的时候，会发生页异常错误，抛给14号中断，判断是用户态模式还是内核态的模式，内核态的话直接就蓝屏，因为内核态模式是没有vad的，在用户态还要去检测一下有没有vad，如果在vad中，而且保护属性不是noaccess的话，其他的页属性的话会进一步的去给他挂物理页然后去修复</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://l0x1c.com/posts/minifilter/">
    <span class="title">Next »</span>
    <br>
    <span>minifilter</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
