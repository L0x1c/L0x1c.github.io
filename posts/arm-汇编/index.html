<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Arm 汇编学习 | L0x1c&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧
主要的学习流程大概这两个：
看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 &amp; 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件 cemu 做辅助支持 : https://github.com/hugsy/cemu
在ubuntu下面折腾了一下，感觉还行
当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）
Android studio &amp; ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下
安装完之后自己在 .zshrc 中配置一下环境变量
export ANDROID_HOME=&#34;Android/sdk所在路径&#34; export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了
代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下
进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}
以后避免每次都打开 android studio可以用emulator里面命令来启动avd
⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了
配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发
这样后ida attach就可以看到对应的进程那些了
c编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en
主要需要的是 Application.mk 和 Android.">
<meta name="author" content="L0x1c">
<link rel="canonical" href="https://l0x1c.com/posts/arm-%E6%B1%87%E7%BC%96/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://l0x1c.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://l0x1c.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://l0x1c.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://l0x1c.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://l0x1c.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Arm 汇编学习" />
<meta property="og:description" content="ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧
主要的学习流程大概这两个：
看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 &amp; 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件 cemu 做辅助支持 : https://github.com/hugsy/cemu
在ubuntu下面折腾了一下，感觉还行
当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）
Android studio &amp; ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下
安装完之后自己在 .zshrc 中配置一下环境变量
export ANDROID_HOME=&#34;Android/sdk所在路径&#34; export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了
代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下
进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}
以后避免每次都打开 android studio可以用emulator里面命令来启动avd
⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了
配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发
这样后ida attach就可以看到对应的进程那些了
c编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en
主要需要的是 Application.mk 和 Android." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://l0x1c.com/posts/arm-%E6%B1%87%E7%BC%96/" />
<meta property="og:image" content="https://l0x1c.com/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2025-10-12T00:59:09+08:00" />
<meta property="article:modified_time" content="2025-10-12T00:59:09+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://l0x1c.com/images/papermod-cover.png" />
<meta name="twitter:title" content="Arm 汇编学习"/>
<meta name="twitter:description" content="ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧
主要的学习流程大概这两个：
看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 &amp; 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件 cemu 做辅助支持 : https://github.com/hugsy/cemu
在ubuntu下面折腾了一下，感觉还行
当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）
Android studio &amp; ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下
安装完之后自己在 .zshrc 中配置一下环境变量
export ANDROID_HOME=&#34;Android/sdk所在路径&#34; export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了
代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下
进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}
以后避免每次都打开 android studio可以用emulator里面命令来启动avd
⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了
配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发
这样后ida attach就可以看到对应的进程那些了
c编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en
主要需要的是 Application.mk 和 Android."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://l0x1c.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Arm 汇编学习",
      "item": "https://l0x1c.com/posts/arm-%E6%B1%87%E7%BC%96/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Arm 汇编学习",
  "name": "Arm 汇编学习",
  "description": "ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧\n主要的学习流程大概这两个：\n看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 \u0026amp; 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件 cemu 做辅助支持 : https://github.com/hugsy/cemu\n在ubuntu下面折腾了一下，感觉还行\n当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）\nAndroid studio \u0026amp; ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下\n安装完之后自己在 .zshrc 中配置一下环境变量\nexport ANDROID_HOME=\u0026#34;Android/sdk所在路径\u0026#34; export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了\n代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下\n进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}\n以后避免每次都打开 android studio可以用emulator里面命令来启动avd\n⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了\n配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发\n这样后ida attach就可以看到对应的进程那些了\nc编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en\n主要需要的是 Application.mk 和 Android.",
  "keywords": [
    
  ],
  "articleBody": "ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧\n主要的学习流程大概这两个：\n看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 \u0026 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件 cemu 做辅助支持 : https://github.com/hugsy/cemu\n在ubuntu下面折腾了一下，感觉还行\n当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）\nAndroid studio \u0026 ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下\n安装完之后自己在 .zshrc 中配置一下环境变量\nexport ANDROID_HOME=\"Android/sdk所在路径\" export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了\n代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下\n进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}\n以后避免每次都打开 android studio可以用emulator里面命令来启动avd\n⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了\n配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发\n这样后ida attach就可以看到对应的进程那些了\nc编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en\n主要需要的是 Application.mk 和 Android.mk 这两个文件，现在写一个c然后编译一下试试\nAPP_ABI := arm64-v8a APP_BUILD_SCRIPT := Android.mk APP_PLATFORM := android-16 LOCAL_PATH := $(call my-dir) #LOCAL_ARM_MODE := arm LOCAL_MODULE := hello LOCAL_SRC_FILES := hello.c include $(BUILD_EXECUTABLE) 执行 ndk-build NDK_PROJECT_PATH=. NDK_APPLICATION_MK=Application.mk\n可以看到已经生成了，一个是debug版本的一个是release版本的，ida这样就可以开始调试起来了\n⚠️ 好像mac m1还没办法运行32位的，所以该文章主要都以64位为主，学的时候也是多学一下64位的毕竟是主流 ( 当然也可以先用32位的来做 )\n寄存器和指令基本格式 寄存器介绍 找了一台手机可以支持32位的，以及64位的，这样就可以都学一下了\n这次就可以32位调试起来了，可以很好看到32位的寄存器\narm32下一共有16个通用寄存器和一个状态寄存器\n其中r13叫做SP叫做栈指针寄存器相当于x86汇编中的esp LR叫做linker指针，当执行函数调用指令 BL func（Branch with Link）时，CPU 会自动把下一条指令的地址（PC + 4）写入 LR，并且跳转到 func 标签执行 BL func ; lr = pc + 4, 跳转到 func 函数如果想要返回的话 MOV PC, LR ; 回到调用点继续执行 如果函数内又调用了别的函数，LR 会被覆盖，所以通常编译器会 STMDB sp!, {LR} ; 保存返回地址 ... LDMIA sp!, {PC} ; 恢复并返回 PC (Program Counter) 里面存放的是当前的地址，对应x86里的eip PSR相当于x86中的eflag寄存器 可以看到arm手册里的介绍 对于PSR (当前程序状态寄存器) 这些位的介绍：\n位 名称 含义 说明 N (bit 31) Negative 结果为负 若算术结果为负，N=1 Z (bit 30) Zero 结果为零 若结果为 0，Z=1 C (bit 29) Carry 进位标志 加法进位或减法借位 V (bit 28) Overflow 溢出标志 有符号运算时溢出 ADD r0, r1, r2 ; CPSR.C 被设置为进位标志 SUBS r0, r1, r2 ; 带S的指令会更新 N Z C V 标志 27 位：Q（Saturation flag，饱和标志）\n用于 饱和运算（Saturating Arithmetic）指令，如 QADD、QDADD 当运算结果超出表示范围时，Q=1 可用 MSR CPSR_f, #0 或 MRS/MSR 指令清除或读取 26–25 位：IT[7:6]（If-Then 块标志）\n用于 Thumb 模式的 IT（If-Then）块控制 ITE EQ MOVEQ r0, #1 MOVNE r0, #0 #这时 CPSR 的 IT 位会被硬件自动设置与清空 19–16 位：GE[3:0]（Greater or Equal flags）\n用于 SIMD（多数据并行）中的比较结果标志（例如 UADD8, USUB8 等） 每一位对应 8 位操作结果是否大于等于 9 位：E（Endian bit）现在arm系统几乎都是小端的\nE = 0 → 小端（Little-endian） E = 1 → 大端（Big-endian） 5 位：T（Thumb state）\nT = 0 → ARM 模式（32 位指令） T = 1 → Thumb 模式（16 位指令） BX R0 ; 跳转到R0地址，并根据最低位决定T标志 # 如果 R0 的最低位为 1，会自动切换到 Thumb 模式 4–0 位：M[4:0]（处理器模式位）\n模式位（M4:M0） 模式名 权限 说明 10000 User 非特权 普通用户态 10001 FIQ 特权 快速中断 10010 IRQ 特权 普通中断 10011 Supervisor (SVC) 特权 系统调用 / 启动模式 10111 Abort 特权 内存访问异常 11011 Undefined 特权 未定义指令异常 11111 System 特权 特殊内核态 总体设计和指令规格 arm汇编中没有隐式内存操作指令\n这个怎么理解呢？ 可以这么来说，在x86汇编中有很多的隐式内存操作指令，比如push pop call，比如push这个指令，这个指令本身是没有内存的索引地址的，这个指令操作后会隐式的把esp指针的地址-4并且往其中写一个数，那么这个push这个指令就隐式的操作了内存，包括中断指令int 等等\narm汇编中，指令是 0 - 3个操作数，内存操作数和立即数操作数不能同时存在（因为 ARM 是典型的 load–store（取数-运算分离） 架构），内存操作数至多出现1次，寄存器操作数一般都是在前面\n这里大概理解了一下为什么内存操作数和立即操作数不能同时存在： 指令位数固定，要同时编码“访存寻址模式 + 数据算术的立即数/移位 + 寄存器号 + 条件码”，位不够用，解码也会变复杂，所以把复杂操作拆成两条简单指令，可以更好的乱序执行，把“访存”和“算术”拆开，硬件解码与执行更规整，单周期（或固定多周期）更容易保证；条件执行也更可控\n可以观察看到，左边的都是寄存器操作数，上面看到的LDR R6, [R6,#0xC]这种的属于两个操作数，后面的只是内存的一种索引模式 再比如：MOV.W R7, R9,LSR#12 这也是两个操作数，第二个R9,LSR#12这属于一个操作数\n读pc寄存器 在arm的这个汇编的情况中，pc寄存器属于那种正常的寄存器，可以对这个寄存器进行写，那么写到这个寄存器就相当于了指令跳转，写了个例子方便理解，可以看到跳过了地址是8的位置，直接到了c的地址\n读取pc寄存器有很多比较奇怪的行为，读取pc寄存器的时候，如果是arm模式会+8，thumb模式+4，因为ARM的流水线是为了性能优化设计的让CPU在执行当前指令的同时，已经把下一条、下下条都装载进指令缓存\n模式 指令长度 流水线深度 读取 PC 实际值 偏移原因 ARM 模式 4 字节 提前取两条 当前地址 + 8 三段流水线取指超前 Thumb 模式 2 字节 提前取一条 当前地址 + 4 指令短、取指周期短 ldr的指令读pc的内存也同理，可以看到后面的pc读取的数据pc被+8，然后读取8位置的值，所以pc寄存器只要有读的指令存在就是读的就是pc+8\n这里说一个问题就是ldr r0,[pc, #-4]\n但是比如你在ida调试那些环境下，那么读的就不是这个值了\n这里加一个小trips (关于ida安装keypatch): 这里我用了高版本的ida9.0，keypatch不支持：https://bbs.kanxue.com/thread-286591.htm#msg_header_h3_4\n编译之前看一下自己ida的架构，然后编译的keystone的dylib要对应上\n就可以用了\n继续回到主题！调试环境下的为什么不是这个值，我们看一下 这里我写的是 ldr r0, [pc, #-4]，ida帮我们优化了一下可以直接看到地址，之前说的pc寄存器遇见读的指令pc在arm模式下会+8，由于我-4了，所以应该是pc+4，读到的值r0应该是912fff1e\n我们现在看一下，读取到底是什么值，可以看到读取的是E7F001F0，这个是什么呢，我在下面硬编码改了一下，发现时UND #10，这个是什么？！\n网上查了一下，这个值都和反调试有关系，那么可以理解为，这里相当于读的断点的中断指令，类似于x86中f8的int 3，相当于单步的时候会有一个信号，信号呢被调试器捕获，然后ida捕获到异常，然后进行处理\nthumb模式下：\n先看第一个指令ldr r0,[pc] 这个在thumb模式下是pc + 4的地址读取出来\n可以看到又读了一个中断 DE10\n但是这里有疑问了，不是pc+4吗，继续往下看下面的两个都是e4的那个，就可以知道了，其实是有地址对齐的问题存在，所以才会两个条指令都是相同的pc+4但是对应的地址是一样的情况，所以thumb模式下还需要对齐，可以总结规律thumb模式下ldr reg,[pc]的pc地址是要 pc - pc % 4\n看一下公式准不准确用上面的d6的地址做一下对应的计算，可以看到是d8\n这种的东西在arm模式下不考虑，因为arm模式下都是4字节的，所以都是对齐的情况\n条件和标志位响应 Trips:（大部分的指令的说明都在arm手册的F5.1 以及 C6.2下）可以自己没事的时候看看\n上面的图代表了arm中的条件标志位的一些标识，比如如果相等就是EQ那么z就等于1这些，上面的这些助记符扩展都可以加入一些指令后面，比如 addeq r0, r0, #1 那么这句的含义就是当z=1的时候r0 = r0 + 1\n让这些标志位进行改变的，举例大概有cmp，或者是某些指令加了后面加了s的，因为加了s就可以把指令影响的标志寄存器进行改，用add进行举例可以看到，adds如果reg不是pc，他会更新psr中的标志位的\n直接写汇编调试一下运行看看，写的是add r0,r0,r1 r0 = 1 r1 = 0xffffffff，是进位的，但是add指令是不改变标志寄存器只改变结果，所以没有看到\n现在我变成adds可以看一下，可以看到改表了标志寄存器的值，发生了进位和为0，所以c位和z位变成了1\n查看手册可以发现上面说的第20位为S位，如果是1就是adds，如果是0那么就是add\n01 00 80 E0 ADD R0, R0, R1 01 00 90 E0 ADDS R0, R0, R1 0000 0001 0000 0000 1000 0000 1110 0000 0000 0001 0000 0000 1001 0000 1110 0000 其中有一个和x86相反的规则是减法指令，可以看一下，第一个sub r0,r0,r1 其中的r0 = 0, r1 = 0xffffffff，第二个r0 = 2，r1 = 1\n可以看到结果对了，但是c位没有变成1，但是第二个的时候c位变成了1\n这个位置就和之前x86学习汇编有一点不一样的情况，这里的情况是产生借位c是0，不产生借位c是0，规则就是减法就是加法器a−b=a+(∼b+1)\n这边有几个对应的指令\nsub subs cmp add adds cmn 如果想判断哪些指令有没有更新标志寄存器，你只需要看第20位是不是1，或者第五个十六进制是不是奇数就行，我在libc中随便找的一个函数，可以看到第五个如果是奇数的话，那么就是会改变psr寄存器的\nMOV指令 基本整型运算 ",
  "wordCount" : "512",
  "inLanguage": "en",
  "image": "https://l0x1c.com/images/papermod-cover.png","datePublished": "2025-10-12T00:59:09+08:00",
  "dateModified": "2025-10-12T00:59:09+08:00",
  "author":{
    "@type": "Person",
    "name": "L0x1c"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://l0x1c.com/posts/arm-%E6%B1%87%E7%BC%96/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "L0x1c's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://l0x1c.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://l0x1c.com/" accesskey="h" title="L0x1c&#39;s Blog (Alt + H)">L0x1c&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://l0x1c.com/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://l0x1c.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://l0x1c.com/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://l0x1c.com/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://l0x1c.com/">Home</a>&nbsp;»&nbsp;<a href="https://l0x1c.com/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Arm 汇编学习
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h1>
    <div class="post-meta"><span title='2025-10-12 00:59:09 +0800 +0800'>October 12, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;L0x1c

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#arm-%e6%b1%87%e7%bc%96" aria-label="ARM 汇编">ARM 汇编</a><ul>
                        
                <li>
                    <a href="#arm-%e6%b1%87%e7%bc%96%e4%bb%8b%e7%bb%8d--%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba" aria-label="ARM 汇编介绍 &amp; 环境搭建">ARM 汇编介绍 &amp; 环境搭建</a><ul>
                        
                <li>
                    <a href="#android-studio--ida-%e7%9a%84%e9%85%8d%e7%bd%ae" aria-label="Android studio &amp; ida 的配置">Android studio &amp; ida 的配置</a></li>
                <li>
                    <a href="#c%e7%bc%96%e8%af%91%e7%8e%af%e5%a2%83" aria-label="c编译环境">c编译环境</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%af%84%e5%ad%98%e5%99%a8%e5%92%8c%e6%8c%87%e4%bb%a4%e5%9f%ba%e6%9c%ac%e6%a0%bc%e5%bc%8f" aria-label="寄存器和指令基本格式">寄存器和指令基本格式</a><ul>
                        
                <li>
                    <a href="#%e5%af%84%e5%ad%98%e5%99%a8%e4%bb%8b%e7%bb%8d" aria-label="寄存器介绍">寄存器介绍</a></li>
                <li>
                    <a href="#%e6%80%bb%e4%bd%93%e8%ae%be%e8%ae%a1%e5%92%8c%e6%8c%87%e4%bb%a4%e8%a7%84%e6%a0%bc" aria-label="总体设计和指令规格">总体设计和指令规格</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%af%bbpc%e5%af%84%e5%ad%98%e5%99%a8" aria-label="读pc寄存器">读pc寄存器</a></li>
                <li>
                    <a href="#%e6%9d%a1%e4%bb%b6%e5%92%8c%e6%a0%87%e5%bf%97%e4%bd%8d%e5%93%8d%e5%ba%94" aria-label="条件和标志位响应">条件和标志位响应</a></li>
                <li>
                    <a href="#mov%e6%8c%87%e4%bb%a4" aria-label="MOV指令">MOV指令</a></li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e6%95%b4%e5%9e%8b%e8%bf%90%e7%ae%97" aria-label="基本整型运算">基本整型运算</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="arm-汇编">ARM 汇编<a hidden class="anchor" aria-hidden="true" href="#arm-汇编">#</a></h1>
<p>由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧</p>
<p>主要的学习流程大概这两个：</p>
<ul>
<li>看一下周壑老师的视频</li>
<li>辅助一下利用 <a href="https://azeria-labs.com/">https://azeria-labs.com/</a> 这个网站上的lab进行学习</li>
</ul>
<h2 id="arm-汇编介绍--环境搭建">ARM 汇编介绍 &amp; 环境搭建<a hidden class="anchor" aria-hidden="true" href="#arm-汇编介绍--环境搭建">#</a></h2>
<p>环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ）
ida（ 远程调试 ），keypatch 插件
cemu 做辅助支持 : <a href="https://github.com/hugsy/cemu">https://github.com/hugsy/cemu</a></p>
<p>在ubuntu下面折腾了一下，感觉还行</p>
<p><img loading="lazy" src="image-10.png" alt="alt text"  />
</p>
<p>当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）</p>
<h3 id="android-studio--ida-的配置">Android studio &amp; ida 的配置<a hidden class="anchor" aria-hidden="true" href="#android-studio--ida-的配置">#</a></h3>
<p><img loading="lazy" src="image.png" alt="alt text"  />
</p>
<p>勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下</p>
<p>安装完之后自己在 .zshrc 中配置一下环境变量</p>
<pre tabindex="0"><code>export ANDROID_HOME=&#34;Android/sdk所在路径&#34;
export PATH=${PATH}:${ANDROID_HOME}/tools
export PATH=${PATH}:${ANDROID_HOME}/platform-tools
export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径
</code></pre><p>所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了</p>
<p>代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下</p>
<p><img loading="lazy" src="image-1.png" alt="alt text"  />
</p>
<p>进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}</p>
<p><img loading="lazy" src="image-2.png" alt="alt text"  />
</p>
<p><img loading="lazy" src="image-3.png" alt="alt text"  />
</p>
<p>以后避免每次都打开 android studio可以用emulator里面命令来启动avd</p>
<p><img loading="lazy" src="image-4.png" alt="alt text"  />
</p>
<p>⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了</p>
<p><img loading="lazy" src="image-5.png" alt="alt text"  />
</p>
<p>配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发</p>
<p><img loading="lazy" src="image-6.png" alt="alt text"  />
</p>
<p>这样后ida attach就可以看到对应的进程那些了</p>
<p><img loading="lazy" src="image-7.png" alt="alt text"  />
</p>
<h3 id="c编译环境">c编译环境<a hidden class="anchor" aria-hidden="true" href="#c编译环境">#</a></h3>
<p><a href="https://developer.android.google.cn/ndk/guides/ndk-build?hl=en">https://developer.android.google.cn/ndk/guides/ndk-build?hl=en</a></p>
<p>主要需要的是 Application.mk 和 Android.mk 这两个文件，现在写一个c然后编译一下试试</p>
<pre tabindex="0"><code>APP_ABI := arm64-v8a
APP_BUILD_SCRIPT := Android.mk
APP_PLATFORM := android-16
</code></pre><pre tabindex="0"><code>LOCAL_PATH := $(call my-dir)
#LOCAL_ARM_MODE := arm
LOCAL_MODULE := hello
LOCAL_SRC_FILES := hello.c
include $(BUILD_EXECUTABLE)
</code></pre><p>执行 ndk-build NDK_PROJECT_PATH=. NDK_APPLICATION_MK=Application.mk</p>
<p><img loading="lazy" src="image-8.png" alt="alt text"  />
</p>
<p>可以看到已经生成了，一个是debug版本的一个是release版本的，ida这样就可以开始调试起来了</p>
<p><img loading="lazy" src="image-9.png" alt="alt text"  />
</p>
<p>⚠️ 好像mac m1还没办法运行32位的，所以该文章主要都以64位为主，学的时候也是多学一下64位的毕竟是主流 ( 当然也可以先用32位的来做 )</p>
<h2 id="寄存器和指令基本格式">寄存器和指令基本格式<a hidden class="anchor" aria-hidden="true" href="#寄存器和指令基本格式">#</a></h2>
<h3 id="寄存器介绍">寄存器介绍<a hidden class="anchor" aria-hidden="true" href="#寄存器介绍">#</a></h3>
<p>找了一台手机可以支持32位的，以及64位的，这样就可以都学一下了</p>
<p><img loading="lazy" src="image-11.png" alt="alt text"  />
</p>
<p>这次就可以32位调试起来了，可以很好看到32位的寄存器</p>
<p><img loading="lazy" src="image-12.png" alt="alt text"  />
</p>
<p>arm32下一共有16个通用寄存器和一个状态寄存器</p>
<ul>
<li>其中r13叫做SP叫做栈指针寄存器相当于x86汇编中的esp</li>
<li>LR叫做linker指针，当执行函数调用指令 BL func（Branch with Link）时，CPU 会自动把下一条指令的地址（PC + 4）写入 LR，并且跳转到 func 标签执行
<pre tabindex="0"><code>BL func     ; lr = pc + 4, 跳转到 func
</code></pre>函数如果想要返回的话
<pre tabindex="0"><code>MOV PC, LR  ; 回到调用点继续执行
</code></pre>如果函数内又调用了别的函数，LR 会被覆盖，所以通常编译器会
<pre tabindex="0"><code>STMDB sp!, {LR}   ; 保存返回地址
  ...
LDMIA sp!, {PC}    ; 恢复并返回
</code></pre></li>
<li>PC (Program Counter) 里面存放的是当前的地址，对应x86里的eip</li>
<li>PSR相当于x86中的eflag寄存器 可以看到arm手册里的介绍
<img loading="lazy" src="image-13.png" alt="alt text"  />
</li>
</ul>
<p>对于PSR (当前程序状态寄存器) 这些位的介绍：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>N (bit 31)</strong></td>
<td>Negative</td>
<td>结果为负</td>
<td>若算术结果为负，N=1</td>
</tr>
<tr>
<td><strong>Z (bit 30)</strong></td>
<td>Zero</td>
<td>结果为零</td>
<td>若结果为 0，Z=1</td>
</tr>
<tr>
<td><strong>C (bit 29)</strong></td>
<td>Carry</td>
<td>进位标志</td>
<td>加法进位或减法借位</td>
</tr>
<tr>
<td><strong>V (bit 28)</strong></td>
<td>Overflow</td>
<td>溢出标志</td>
<td>有符号运算时溢出</td>
</tr>
</tbody>
</table>
<pre tabindex="0"><code>ADD r0, r1, r2   ; CPSR.C 被设置为进位标志
SUBS r0, r1, r2  ; 带S的指令会更新 N Z C V 标志
</code></pre><p>27 位：Q（Saturation flag，饱和标志）</p>
<ul>
<li>用于 饱和运算（Saturating Arithmetic）指令，如 QADD、QDADD</li>
<li>当运算结果超出表示范围时，Q=1</li>
<li>可用 MSR CPSR_f, #0 或 MRS/MSR 指令清除或读取</li>
</ul>
<p>26–25 位：IT[7:6]（If-Then 块标志）</p>
<ul>
<li>用于 Thumb 模式的 IT（If-Then）块控制
<pre tabindex="0"><code>ITE EQ
MOVEQ r0, #1
MOVNE r0, #0

#这时 CPSR 的 IT 位会被硬件自动设置与清空
</code></pre></li>
</ul>
<p>19–16 位：GE[3:0]（Greater or Equal flags）</p>
<ul>
<li>用于 SIMD（多数据并行）中的比较结果标志（例如 UADD8, USUB8 等）</li>
<li>每一位对应 8 位操作结果是否大于等于</li>
</ul>
<p>9 位：E（Endian bit）现在arm系统几乎都是小端的</p>
<ul>
<li>E = 0 → 小端（Little-endian）</li>
<li>E = 1 → 大端（Big-endian）</li>
</ul>
<p>5 位：T（Thumb state）</p>
<ul>
<li>T = 0 → ARM 模式（32 位指令）</li>
<li>T = 1 → Thumb 模式（16 位指令）
<pre tabindex="0"><code>BX R0      ; 跳转到R0地址，并根据最低位决定T标志
# 如果 R0 的最低位为 1，会自动切换到 Thumb 模式
</code></pre></li>
</ul>
<p>4–0 位：M[4:0]（处理器模式位）</p>
<table>
<thead>
<tr>
<th>模式位（M4:M0）</th>
<th>模式名</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>10000</code></td>
<td>User</td>
<td>非特权</td>
<td>普通用户态</td>
</tr>
<tr>
<td><code>10001</code></td>
<td>FIQ</td>
<td>特权</td>
<td>快速中断</td>
</tr>
<tr>
<td><code>10010</code></td>
<td>IRQ</td>
<td>特权</td>
<td>普通中断</td>
</tr>
<tr>
<td><code>10011</code></td>
<td>Supervisor (SVC)</td>
<td>特权</td>
<td>系统调用 / 启动模式</td>
</tr>
<tr>
<td><code>10111</code></td>
<td>Abort</td>
<td>特权</td>
<td>内存访问异常</td>
</tr>
<tr>
<td><code>11011</code></td>
<td>Undefined</td>
<td>特权</td>
<td>未定义指令异常</td>
</tr>
<tr>
<td><code>11111</code></td>
<td>System</td>
<td>特权</td>
<td>特殊内核态</td>
</tr>
</tbody>
</table>
<h3 id="总体设计和指令规格">总体设计和指令规格<a hidden class="anchor" aria-hidden="true" href="#总体设计和指令规格">#</a></h3>
<p>arm汇编中没有隐式内存操作指令</p>
<p>这个怎么理解呢？
可以这么来说，在x86汇编中有很多的隐式内存操作指令，比如push pop call，比如push这个指令，这个指令本身是没有内存的索引地址的，这个指令操作后会隐式的把esp指针的地址-4并且往其中写一个数，那么这个push这个指令就隐式的操作了内存，包括中断指令int 等等</p>
<p>arm汇编中，指令是 0 - 3个操作数，内存操作数和立即数操作数不能同时存在（因为 ARM 是典型的 load–store（取数-运算分离） 架构），内存操作数至多出现1次，寄存器操作数一般都是在前面</p>
<p>这里大概理解了一下为什么内存操作数和立即操作数不能同时存在：
指令位数固定，要同时编码“访存寻址模式 + 数据算术的立即数/移位 + 寄存器号 + 条件码”，位不够用，解码也会变复杂，所以把复杂操作拆成两条简单指令，可以更好的乱序执行，把“访存”和“算术”拆开，硬件解码与执行更规整，单周期（或固定多周期）更容易保证；条件执行也更可控</p>
<p><img loading="lazy" src="image-14.png" alt="alt text"  />
</p>
<p>可以观察看到，左边的都是寄存器操作数，上面看到的LDR R6, [R6,#0xC]这种的属于两个操作数，后面的只是内存的一种索引模式
再比如：MOV.W R7, R9,LSR#12 这也是两个操作数，第二个R9,LSR#12这属于一个操作数</p>
<h2 id="读pc寄存器">读pc寄存器<a hidden class="anchor" aria-hidden="true" href="#读pc寄存器">#</a></h2>
<p>在arm的这个汇编的情况中，pc寄存器属于那种正常的寄存器，可以对这个寄存器进行写，那么写到这个寄存器就相当于了指令跳转，写了个例子方便理解，可以看到跳过了地址是8的位置，直接到了c的地址</p>
<p><img loading="lazy" src="image-15.png" alt="alt text"  />
</p>
<p>读取pc寄存器有很多比较奇怪的行为，读取pc寄存器的时候，如果是arm模式会+8，thumb模式+4，因为ARM的流水线是为了性能优化设计的让CPU在执行当前指令的同时，已经把下一条、下下条都装载进指令缓存</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>指令长度</th>
<th>流水线深度</th>
<th>读取 PC 实际值</th>
<th>偏移原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ARM 模式</strong></td>
<td>4 字节</td>
<td>提前取两条</td>
<td>当前地址 + 8</td>
<td>三段流水线取指超前</td>
</tr>
<tr>
<td><strong>Thumb 模式</strong></td>
<td>2 字节</td>
<td>提前取一条</td>
<td>当前地址 + 4</td>
<td>指令短、取指周期短</td>
</tr>
</tbody>
</table>
<p><img loading="lazy" src="image-16.png" alt="alt text"  />
</p>
<p>ldr的指令读pc的内存也同理，可以看到后面的pc读取的数据pc被+8，然后读取8位置的值，所以pc寄存器只要有读的指令存在就是读的就是pc+8</p>
<p><img loading="lazy" src="image-17.png" alt="alt text"  />
</p>
<p>这里说一个问题就是ldr r0,[pc, #-4]</p>
<p><img loading="lazy" src="image-18.png" alt="alt text"  />
</p>
<p>但是比如你在ida调试那些环境下，那么读的就不是这个值了</p>
<p>这里加一个小trips (关于ida安装keypatch):
这里我用了高版本的ida9.0，keypatch不支持：https://bbs.kanxue.com/thread-286591.htm#msg_header_h3_4</p>
<p>编译之前看一下自己ida的架构，然后编译的keystone的dylib要对应上</p>
<p><img loading="lazy" src="image-19.png" alt="alt text"  />
</p>
<p><img loading="lazy" src="image-20.png" alt="alt text"  />
</p>
<p>就可以用了</p>
<p><img loading="lazy" src="image-21.png" alt="alt text"  />
</p>
<p>继续回到主题！调试环境下的为什么不是这个值，我们看一下
这里我写的是 ldr r0, [pc, #-4]，ida帮我们优化了一下可以直接看到地址，之前说的pc寄存器遇见读的指令pc在arm模式下会+8，由于我-4了，所以应该是pc+4，读到的值r0应该是912fff1e</p>
<p><img loading="lazy" src="image-22.png" alt="alt text"  />
</p>
<p>我们现在看一下，读取到底是什么值，可以看到读取的是E7F001F0，这个是什么呢，我在下面硬编码改了一下，发现时UND #10，这个是什么？！</p>
<p><img loading="lazy" src="image-23.png" alt="alt text"  />
</p>
<p>网上查了一下，这个值都和反调试有关系，那么可以理解为，这里相当于读的断点的中断指令，类似于x86中f8的int 3，相当于单步的时候会有一个信号，信号呢被调试器捕获，然后ida捕获到异常，然后进行处理</p>
<p><img loading="lazy" src="image-24.png" alt="alt text"  />
</p>
<p>thumb模式下：</p>
<p>先看第一个指令ldr r0,[pc] 这个在thumb模式下是pc + 4的地址读取出来</p>
<p><img loading="lazy" src="image-25.png" alt="alt text"  />
</p>
<p>可以看到又读了一个中断 DE10</p>
<p><img loading="lazy" src="image-26.png" alt="alt text"  />
</p>
<p>但是这里有疑问了，不是pc+4吗，继续往下看下面的两个都是e4的那个，就可以知道了，其实是有地址对齐的问题存在，所以才会两个条指令都是相同的pc+4但是对应的地址是一样的情况，所以thumb模式下还需要对齐，可以总结规律thumb模式下ldr reg,[pc]的pc地址是要 pc - pc % 4</p>
<p><img loading="lazy" src="image-27.png" alt="alt text"  />
</p>
<p>看一下公式准不准确用上面的d6的地址做一下对应的计算，可以看到是d8</p>
<p><img loading="lazy" src="image-28.png" alt="alt text"  />
</p>
<p>这种的东西在arm模式下不考虑，因为arm模式下都是4字节的，所以都是对齐的情况</p>
<h2 id="条件和标志位响应">条件和标志位响应<a hidden class="anchor" aria-hidden="true" href="#条件和标志位响应">#</a></h2>
<p>Trips:（大部分的指令的说明都在arm手册的F5.1 以及 C6.2下）可以自己没事的时候看看</p>
<p><img loading="lazy" src="image-29.png" alt="alt text"  />
</p>
<p>上面的图代表了arm中的条件标志位的一些标识，比如如果相等就是EQ那么z就等于1这些，上面的这些助记符扩展都可以加入一些指令后面，比如 addeq r0, r0, #1 那么这句的含义就是当z=1的时候r0 = r0 + 1</p>
<p>让这些标志位进行改变的，举例大概有cmp，或者是某些指令加了后面加了s的，因为加了s就可以把指令影响的标志寄存器进行改，用add进行举例可以看到，adds如果reg不是pc，他会更新psr中的标志位的</p>
<p><img loading="lazy" src="image-30.png" alt="alt text"  />
</p>
<p>直接写汇编调试一下运行看看，写的是add r0,r0,r1 r0 = 1 r1 = 0xffffffff，是进位的，但是add指令是不改变标志寄存器只改变结果，所以没有看到</p>
<p><img loading="lazy" src="image-31.png" alt="alt text"  />
</p>
<p>现在我变成adds可以看一下，可以看到改表了标志寄存器的值，发生了进位和为0，所以c位和z位变成了1</p>
<p><img loading="lazy" src="image-32.png" alt="alt text"  />
</p>
<p>查看手册可以发现上面说的第20位为S位，如果是1就是adds，如果是0那么就是add</p>
<pre tabindex="0"><code>01 00 80 E0             ADD     R0, R0, R1
01 00 90 E0             ADDS    R0, R0, R1

0000 0001 0000 0000 1000 0000 1110 0000
0000 0001 0000 0000 1001 0000 1110 0000
</code></pre><p>其中有一个和x86相反的规则是减法指令，可以看一下，第一个sub r0,r0,r1 其中的r0 = 0, r1 = 0xffffffff，第二个r0 = 2，r1 = 1</p>
<p><img loading="lazy" src="image-33.png" alt="alt text"  />
</p>
<p>可以看到结果对了，但是c位没有变成1，但是第二个的时候c位变成了1</p>
<p><img loading="lazy" src="image-34.png" alt="alt text"  />
</p>
<p>这个位置就和之前x86学习汇编有一点不一样的情况，这里的情况是产生借位c是0，不产生借位c是0，规则就是减法就是加法器a−b=a+(∼b+1)</p>
<p>这边有几个对应的指令</p>
<pre tabindex="0"><code>sub subs cmp
add adds cmn
</code></pre><p>如果想判断哪些指令有没有更新标志寄存器，你只需要看第20位是不是1，或者第五个十六进制是不是奇数就行，我在libc中随便找的一个函数，可以看到第五个如果是奇数的话，那么就是会改变psr寄存器的</p>
<p><img loading="lazy" src="image-35.png" alt="alt text"  />
</p>
<h2 id="mov指令">MOV指令<a hidden class="anchor" aria-hidden="true" href="#mov指令">#</a></h2>
<h2 id="基本整型运算">基本整型运算<a hidden class="anchor" aria-hidden="true" href="#基本整型运算">#</a></h2>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://l0x1c.com/posts/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">
    <span class="title">« Prev</span>
    <br>
    <span>xv6 环境配置 vmare or docker</span>
  </a>
  <a class="next" href="https://l0x1c.com/posts/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
    <span class="title">Next »</span>
    <br>
    <span>内存管理</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
