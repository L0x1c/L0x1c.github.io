<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Arm 汇编学习 | L0x1c&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧
主要的学习流程大概这两个：
看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 &amp; 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件 cemu 做辅助支持 : https://github.com/hugsy/cemu
在ubuntu下面折腾了一下，感觉还行
当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）
Android studio &amp; ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下
安装完之后自己在 .zshrc 中配置一下环境变量
export ANDROID_HOME=&#34;Android/sdk所在路径&#34; export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了
代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下
进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}
以后避免每次都打开 android studio可以用emulator里面命令来启动avd
⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了
配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发
这样后ida attach就可以看到对应的进程那些了
c编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en
主要需要的是 Application.mk 和 Android.">
<meta name="author" content="L0x1c">
<link rel="canonical" href="https://l0x1c.com/posts/arm-%E6%B1%87%E7%BC%96/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://l0x1c.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://l0x1c.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://l0x1c.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://l0x1c.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://l0x1c.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Arm 汇编学习" />
<meta property="og:description" content="ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧
主要的学习流程大概这两个：
看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 &amp; 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件 cemu 做辅助支持 : https://github.com/hugsy/cemu
在ubuntu下面折腾了一下，感觉还行
当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）
Android studio &amp; ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下
安装完之后自己在 .zshrc 中配置一下环境变量
export ANDROID_HOME=&#34;Android/sdk所在路径&#34; export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了
代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下
进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}
以后避免每次都打开 android studio可以用emulator里面命令来启动avd
⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了
配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发
这样后ida attach就可以看到对应的进程那些了
c编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en
主要需要的是 Application.mk 和 Android." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://l0x1c.com/posts/arm-%E6%B1%87%E7%BC%96/" />
<meta property="og:image" content="https://l0x1c.com/images/papermod-cover.png" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2025-10-12T00:59:09+08:00" />
<meta property="article:modified_time" content="2025-10-12T00:59:09+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://l0x1c.com/images/papermod-cover.png" />
<meta name="twitter:title" content="Arm 汇编学习"/>
<meta name="twitter:description" content="ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧
主要的学习流程大概这两个：
看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 &amp; 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件 cemu 做辅助支持 : https://github.com/hugsy/cemu
在ubuntu下面折腾了一下，感觉还行
当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）
Android studio &amp; ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下
安装完之后自己在 .zshrc 中配置一下环境变量
export ANDROID_HOME=&#34;Android/sdk所在路径&#34; export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了
代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下
进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}
以后避免每次都打开 android studio可以用emulator里面命令来启动avd
⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了
配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发
这样后ida attach就可以看到对应的进程那些了
c编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en
主要需要的是 Application.mk 和 Android."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://l0x1c.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Arm 汇编学习",
      "item": "https://l0x1c.com/posts/arm-%E6%B1%87%E7%BC%96/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Arm 汇编学习",
  "name": "Arm 汇编学习",
  "description": "ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧\n主要的学习流程大概这两个：\n看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 \u0026amp; 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件 cemu 做辅助支持 : https://github.com/hugsy/cemu\n在ubuntu下面折腾了一下，感觉还行\n当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）\nAndroid studio \u0026amp; ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下\n安装完之后自己在 .zshrc 中配置一下环境变量\nexport ANDROID_HOME=\u0026#34;Android/sdk所在路径\u0026#34; export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了\n代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下\n进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}\n以后避免每次都打开 android studio可以用emulator里面命令来启动avd\n⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了\n配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发\n这样后ida attach就可以看到对应的进程那些了\nc编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en\n主要需要的是 Application.mk 和 Android.",
  "keywords": [
    
  ],
  "articleBody": "ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧\n主要的学习流程大概这两个：\n看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 \u0026 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件 cemu 做辅助支持 : https://github.com/hugsy/cemu\n在ubuntu下面折腾了一下，感觉还行\n当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）\nAndroid studio \u0026 ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下\n安装完之后自己在 .zshrc 中配置一下环境变量\nexport ANDROID_HOME=\"Android/sdk所在路径\" export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了\n代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下\n进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}\n以后避免每次都打开 android studio可以用emulator里面命令来启动avd\n⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了\n配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发\n这样后ida attach就可以看到对应的进程那些了\nc编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en\n主要需要的是 Application.mk 和 Android.mk 这两个文件，现在写一个c然后编译一下试试\nAPP_ABI := arm64-v8a APP_BUILD_SCRIPT := Android.mk APP_PLATFORM := android-16 LOCAL_PATH := $(call my-dir) #LOCAL_ARM_MODE := arm LOCAL_MODULE := hello LOCAL_SRC_FILES := hello.c include $(BUILD_EXECUTABLE) 执行 ndk-build NDK_PROJECT_PATH=. NDK_APPLICATION_MK=Application.mk\n可以看到已经生成了，一个是debug版本的一个是release版本的，ida这样就可以开始调试起来了\n⚠️ 好像mac m1还没办法运行32位的，所以该文章主要都以64位为主，学的时候也是多学一下64位的毕竟是主流 ( 当然也可以先用32位的来做 )\n寄存器和指令基本格式 寄存器介绍 找了一台手机可以支持32位的，以及64位的，这样就可以都学一下了\n这次就可以32位调试起来了，可以很好看到32位的寄存器\narm32下一共有16个通用寄存器和一个状态寄存器\n其中r13叫做SP叫做栈指针寄存器相当于x86汇编中的esp LR叫做linker指针，当执行函数调用指令 BL func（Branch with Link）时，CPU 会自动把下一条指令的地址（PC + 4）写入 LR，并且跳转到 func 标签执行 BL func ; lr = pc + 4, 跳转到 func 函数如果想要返回的话 MOV PC, LR ; 回到调用点继续执行 如果函数内又调用了别的函数，LR 会被覆盖，所以通常编译器会 STMDB sp!, {LR} ; 保存返回地址 ... LDMIA sp!, {PC} ; 恢复并返回 PC (Program Counter) 里面存放的是当前的地址，对应x86里的eip PSR相当于x86中的eflag寄存器 可以看到arm手册里的介绍 对于PSR (当前程序状态寄存器) 这些位的介绍：\n位 名称 含义 说明 N (bit 31) Negative 结果为负 若算术结果为负，N=1 Z (bit 30) Zero 结果为零 若结果为 0，Z=1 C (bit 29) Carry 进位标志 加法进位或减法借位 V (bit 28) Overflow 溢出标志 有符号运算时溢出 ADD r0, r1, r2 ; CPSR.C 被设置为进位标志 SUBS r0, r1, r2 ; 带S的指令会更新 N Z C V 标志 27 位：Q（Saturation flag，饱和标志）\n用于 饱和运算（Saturating Arithmetic）指令，如 QADD、QDADD 当运算结果超出表示范围时，Q=1 可用 MSR CPSR_f, #0 或 MRS/MSR 指令清除或读取 26–25 位：IT[7:6]（If-Then 块标志）\n用于 Thumb 模式的 IT（If-Then）块控制 ITE EQ MOVEQ r0, #1 MOVNE r0, #0 #这时 CPSR 的 IT 位会被硬件自动设置与清空 19–16 位：GE[3:0]（Greater or Equal flags）\n用于 SIMD（多数据并行）中的比较结果标志（例如 UADD8, USUB8 等） 每一位对应 8 位操作结果是否大于等于 9 位：E（Endian bit）现在arm系统几乎都是小端的\nE = 0 → 小端（Little-endian） E = 1 → 大端（Big-endian） 5 位：T（Thumb state）\nT = 0 → ARM 模式（32 位指令） T = 1 → Thumb 模式（16 位指令） BX R0 ; 跳转到R0地址，并根据最低位决定T标志 # 如果 R0 的最低位为 1，会自动切换到 Thumb 模式 4–0 位：M[4:0]（处理器模式位）\n模式位（M4:M0） 模式名 权限 说明 10000 User 非特权 普通用户态 10001 FIQ 特权 快速中断 10010 IRQ 特权 普通中断 10011 Supervisor (SVC) 特权 系统调用 / 启动模式 10111 Abort 特权 内存访问异常 11011 Undefined 特权 未定义指令异常 11111 System 特权 特殊内核态 总体设计和指令规格 arm汇编中没有隐式内存操作指令\n这个怎么理解呢？ 可以这么来说，在x86汇编中有很多的隐式内存操作指令，比如push pop call，比如push这个指令，这个指令本身是没有内存的索引地址的，这个指令操作后会隐式的把esp指针的地址-4并且往其中写一个数，那么这个push这个指令就隐式的操作了内存，包括中断指令int 等等\narm汇编中，指令是 0 - 3个操作数，内存操作数和立即数操作数不能同时存在（因为 ARM 是典型的 load–store（取数-运算分离） 架构），内存操作数至多出现1次，寄存器操作数一般都是在前面\n这里大概理解了一下为什么内存操作数和立即操作数不能同时存在： 指令位数固定，要同时编码“访存寻址模式 + 数据算术的立即数/移位 + 寄存器号 + 条件码”，位不够用，解码也会变复杂，所以把复杂操作拆成两条简单指令，可以更好的乱序执行，把“访存”和“算术”拆开，硬件解码与执行更规整，单周期（或固定多周期）更容易保证；条件执行也更可控\n可以观察看到，左边的都是寄存器操作数，上面看到的LDR R6, [R6,#0xC]这种的属于两个操作数，后面的只是内存的一种索引模式 再比如：MOV.W R7, R9,LSR#12 这也是两个操作数，第二个R9,LSR#12这属于一个操作数\n读pc寄存器 在arm的这个汇编的情况中，pc寄存器属于那种正常的寄存器，可以对这个寄存器进行写，那么写到这个寄存器就相当于了指令跳转，写了个例子方便理解，可以看到跳过了地址是8的位置，直接到了c的地址\n读取pc寄存器有很多比较奇怪的行为，读取pc寄存器的时候，如果是arm模式会+8，thumb模式+4，因为ARM的流水线是为了性能优化设计的让CPU在执行当前指令的同时，已经把下一条、下下条都装载进指令缓存\n模式 指令长度 流水线深度 读取 PC 实际值 偏移原因 ARM 模式 4 字节 提前取两条 当前地址 + 8 三段流水线取指超前 Thumb 模式 2 字节 提前取一条 当前地址 + 4 指令短、取指周期短 ldr的指令读pc的内存也同理，可以看到后面的pc读取的数据pc被+8，然后读取8位置的值，所以pc寄存器只要有读的指令存在就是读的就是pc+8\n这里说一个问题就是ldr r0,[pc, #-4]\n但是比如你在ida调试那些环境下，那么读的就不是这个值了\n这里加一个小trips (关于ida安装keypatch): 这里我用了高版本的ida9.0，keypatch不支持：https://bbs.kanxue.com/thread-286591.htm#msg_header_h3_4\n编译之前看一下自己ida的架构，然后编译的keystone的dylib要对应上\n就可以用了\n继续回到主题！调试环境下的为什么不是这个值，我们看一下 这里我写的是 ldr r0, [pc, #-4]，ida帮我们优化了一下可以直接看到地址，之前说的pc寄存器遇见读的指令pc在arm模式下会+8，由于我-4了，所以应该是pc+4，读到的值r0应该是912fff1e\n我们现在看一下，读取到底是什么值，可以看到读取的是E7F001F0，这个是什么呢，我在下面硬编码改了一下，发现时UND #10，这个是什么？！\n网上查了一下，这个值都和反调试有关系，那么可以理解为，这里相当于读的断点的中断指令，类似于x86中f8的int 3，相当于单步的时候会有一个信号，信号呢被调试器捕获，然后ida捕获到异常，然后进行处理\nthumb模式下：\n先看第一个指令ldr r0,[pc] 这个在thumb模式下是pc + 4的地址读取出来\n可以看到又读了一个中断 DE10\n但是这里有疑问了，不是pc+4吗，继续往下看下面的两个都是e4的那个，就可以知道了，其实是有地址对齐的问题存在，所以才会两个条指令都是相同的pc+4但是对应的地址是一样的情况，所以thumb模式下还需要对齐，可以总结规律thumb模式下ldr reg,[pc]的pc地址是要 pc - pc % 4\n看一下公式准不准确用上面的d6的地址做一下对应的计算，可以看到是d8\n这种的东西在arm模式下不考虑，因为arm模式下都是4字节的，所以都是对齐的情况\n条件和标志位响应 Trips:（大部分的指令的说明都在arm手册的F5.1 以及 C6.2下）可以自己没事的时候看看\n上面的图代表了arm中的条件标志位的一些标识，比如如果相等就是EQ那么z就等于1这些，上面的这些助记符扩展都可以加入一些指令后面，比如 addeq r0, r0, #1 那么这句的含义就是当z=1的时候r0 = r0 + 1\n让这些标志位进行改变的，举例大概有cmp，或者是某些指令加了后面加了s的，因为加了s就可以把指令影响的标志寄存器进行改，用add进行举例可以看到，adds如果reg不是pc，他会更新psr中的标志位的\n直接写汇编调试一下运行看看，写的是add r0,r0,r1 r0 = 1 r1 = 0xffffffff，是进位的，但是add指令是不改变标志寄存器只改变结果，所以没有看到\n现在我变成adds可以看一下，可以看到改表了标志寄存器的值，发生了进位和为0，所以c位和z位变成了1\n查看手册可以发现上面说的第20位为S位，如果是1就是adds，如果是0那么就是add\n01 00 80 E0 ADD R0, R0, R1 01 00 90 E0 ADDS R0, R0, R1 0000 0001 0000 0000 1000 0000 1110 0000 0000 0001 0000 0000 1001 0000 1110 0000 其中有一个和x86相反的规则是减法指令，可以看一下，第一个sub r0,r0,r1 其中的r0 = 0, r1 = 0xffffffff，第二个r0 = 2，r1 = 1\n可以看到结果对了，但是c位没有变成1，但是第二个的时候c位变成了1\n这个位置就和之前x86学习汇编有一点不一样的情况，这里的情况是产生借位c是0，不产生借位c是0，规则就是减法就是加法器a−b=a+(∼b+1)\n这边有几个对应的指令\nsub subs cmp add adds cmn 如果想判断哪些指令有没有更新标志寄存器，你只需要看第20位是不是1，或者第五个十六进制是不是奇数就行，我在libc中随便找的一个函数，可以看到第五个如果是奇数的话，那么就是会改变psr寄存器的\nMOV指令 mov指令没有访存的操作，所以两个操作数要不就是reg要不就是imm\nmov,movs (immediate) 因为arm的指令集是4字节的指令，立即数如果是32位的肯定放不下，所以arm的imm没办法直接写32位的立即数，mov立即数的情况手册中分成了两种指令格式一种是A1，一种是A2\nA2编码格式 先看一下A2的指令格式，上面有写到，A2的指令格式支持所有16位的立即数，这16位的立即数会写在0-11为以及16-19位，其中的12-15位代表了寄存器正好是4位代表了16个寄存器\n举个例子 mov r1, #0x1234 对应的硬编码是E3011234，那么正好就是0-11为234，16-19为1，12-15为1，正好和上面对应上了\nA1编码格式 比如这个指令：mov r1, #0x80000000，这个立即数已经超过了16位的范围，是32位的范围，那么这种情况就是对应的A1编码格式的情况，为什么要这么设计呢？\n虽然他比16位大，但是他的有效位只有最开始那一位\n这个硬编码根据A1拆分，0-11位是102，12-15的rd为1不变，16-19是0\n上面的解释是A32ExpandImm_C(imm12, PSTATE.C)，imm12需要拆成rot = imm12[11:8]，以及imm8 = imm12[7:0]，其中的rot的单位为2，所以上面的102可以为 02像右循环移为2，因为是32位02为10，像右循环移位2就是1（31个0），所以就是0x80000000，那么说明这个就可以表示0x0 - 0xff的情况都可以像右循环移位，移动的位数是0-16，为什么要乘2，那么就可以覆盖32位，那么就覆盖了0-32位的偶数\nmovt movt是像高4位写，如果像写32位的可以这么写\nmov r1,#0x5678 movt r1,#0x1234 ida优化就直接合并成了一条指令，这个movt的指令一定是先写mov后写movt，因为mov指令会把前面的4字节变成0，那么先写movt就没用了\n那么在实际代码中编译器怎么写的这个情况呢，可以看一下\n#include int main() { u_int32_t test_var = 0x12345678; printf(\"Test variable value: 0x%X\\n\", test_var); while (1) { printf(\"Hello, World!\\n\"); getchar(); } return 0; } 可以看到真实的环境下的寻址，都是通过ldr的这种方式去寻址的，movt这种一般是后面写shellcode的时候比较有用处\nmov,movs (register) 这个普通的mov reg,reg肯定都比较了解了，其中的0-3位为源寄存器，12-15为目标寄存器，举例中的这个mov r0,r1，其中r1就是0-3位为1，r0就是12-15位为0\n这个上面的图中的imm5就代表了可以进行移位的数字，可以看到是7-11位，一共是5位，5位就是代表了0-31，就是32个数字，也对应了32位\n下面这个例子就是左移1位，怎么移就要看5-6位的stype位了，因为有两位所以对应了四种情况：逻辑左移，逻辑右移，算数右移，循环移位 （没有算数左移，因为这个是和逻辑左移式一样的）\n在看一下移位的汇编，其实和mov的硬编码是一样的，因为他们的原理等价了mov的东西，其实移位的操作可以理解为是mov指令的一个宏定义\nmov,movs (register-shifted register) 这个是寄存器移位寄存器赋值给寄存器，所以和上面的大概的流程是一样的不重复了\n基本整型运算 基本运算基本不会出现两个imm，因为举个例子，比如 add r0,1,2 相当于r0 = 3，这个写出来就很奇怪了，早就在编译器的那一步就给你优化掉了\n像这种基本整形运算其实大部分都一样，格式所以主要以add来举例说明，后面的简单介绍功能就可以\nADD 见到这种12位的imm，其实本质上都是之前说的mov的那种形式 8位代表数字，4位代表移位\n寄存器的就比较简单了，两个寄存器想加写在第三个寄存器里，其中的imm5和stype就是之前mov中的说的移位操作\n这个就也和上面的mov类似就是寄存器移位寄存器\n这个就是pc+imm给到另一个寄存器了\n看一下汇编 add r0,pc,4\nida中对应什么呢，因为pc进行读就需要当前的pc+8，上面的指令加上4，所以就是2c的位置，但是在正常的调试环境中，或者运行环境中会根据imagebase进行调整可以在这里看一下printf的位置的这个情况\nprintf这个情况，可以看到他把imagebase加上去了\nSUB/CMP 减法操作 SUB Rd, Rn, Op2：Rd = Rn - Op2 CMP Rn, Op2：只比较不写寄存器，等价于 SUBS (丢弃结果)\n; i--，并在为零时跳走 SUBS r0, r0, #1 BEQ don ; 比较 a 与 b CMP r1, r2 ; 相当于 SUBS r?, r1, r2 BGE ge_path ; 大于等于走这里（无借位 + 非溢出） RSB 反减 RSB Rd, Rn, Op2：Rd = Op2 - Rn\n; 取负：Rd = -Rm RSBS r0, r1, #0 ; r0 = 0 - r1，顺带写标志 AND/TST 与操作 AND Rd, Rn, Op2：Rd = Rn \u0026 Op2 TST Rn, Op2：与运算并只写标志，等价于 ANDS (丢弃结果)\n; 测试 r0 的 bit 7 是否为 1 TST r0, #(1\u003c\u003c7) BNE bit7_is_one BIC 反与，按位清零 BIC Rd, Rn, Op2：Rd = Rn \u0026 ~Op2\n; 清 r0 的低 4 位 BIC r0, r0, #0xF ; 清 r1 的 bit 20（把 bit20 置 0） BIC r1, r1, #(1\u003c\u003c20) ORR 或 ORR Rd, Rn, Op2：Rd = Rn | Op2\n; 置 r0 的 bit 3 和 bit 5 ORR r0, r0, #(1\u003c\u003c3) | (1\u003c\u003c5) EOR/TEQ 异或 EOR Rd, Rn, Op2：Rd = Rn ^ Op2（按位异或/翻转） TEQ Rn, Op2：只写标志，等价于 EORS (丢弃结果)，常用来“测试相等性（按位相同则结果 0）”或“测试奇偶”\n; 翻转 r0 的 bit 8 EOR r0, r0, #(1\u003c\u003c8) ; 判断 r1 与 r2 的比特是否完全相同 TEQ r1, r2 BEQ equal_bits ; r1 ^ r2 == 0 访存指令 ",
  "wordCount" : "799",
  "inLanguage": "en",
  "image": "https://l0x1c.com/images/papermod-cover.png","datePublished": "2025-10-12T00:59:09+08:00",
  "dateModified": "2025-10-12T00:59:09+08:00",
  "author":{
    "@type": "Person",
    "name": "L0x1c"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://l0x1c.com/posts/arm-%E6%B1%87%E7%BC%96/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "L0x1c's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://l0x1c.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://l0x1c.com/" accesskey="h" title="L0x1c&#39;s Blog (Alt + H)">L0x1c&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://l0x1c.com/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://l0x1c.com/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://l0x1c.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://l0x1c.com/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://l0x1c.com/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://l0x1c.com/">Home</a>&nbsp;»&nbsp;<a href="https://l0x1c.com/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Arm 汇编学习
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h1>
    <div class="post-meta"><span title='2025-10-12 00:59:09 +0800 +0800'>October 12, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;L0x1c

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#arm-%e6%b1%87%e7%bc%96" aria-label="ARM 汇编">ARM 汇编</a><ul>
                        
                <li>
                    <a href="#arm-%e6%b1%87%e7%bc%96%e4%bb%8b%e7%bb%8d--%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba" aria-label="ARM 汇编介绍 &amp; 环境搭建">ARM 汇编介绍 &amp; 环境搭建</a><ul>
                        
                <li>
                    <a href="#android-studio--ida-%e7%9a%84%e9%85%8d%e7%bd%ae" aria-label="Android studio &amp; ida 的配置">Android studio &amp; ida 的配置</a></li>
                <li>
                    <a href="#c%e7%bc%96%e8%af%91%e7%8e%af%e5%a2%83" aria-label="c编译环境">c编译环境</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%af%84%e5%ad%98%e5%99%a8%e5%92%8c%e6%8c%87%e4%bb%a4%e5%9f%ba%e6%9c%ac%e6%a0%bc%e5%bc%8f" aria-label="寄存器和指令基本格式">寄存器和指令基本格式</a><ul>
                        
                <li>
                    <a href="#%e5%af%84%e5%ad%98%e5%99%a8%e4%bb%8b%e7%bb%8d" aria-label="寄存器介绍">寄存器介绍</a></li>
                <li>
                    <a href="#%e6%80%bb%e4%bd%93%e8%ae%be%e8%ae%a1%e5%92%8c%e6%8c%87%e4%bb%a4%e8%a7%84%e6%a0%bc" aria-label="总体设计和指令规格">总体设计和指令规格</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%af%bbpc%e5%af%84%e5%ad%98%e5%99%a8" aria-label="读pc寄存器">读pc寄存器</a></li>
                <li>
                    <a href="#%e6%9d%a1%e4%bb%b6%e5%92%8c%e6%a0%87%e5%bf%97%e4%bd%8d%e5%93%8d%e5%ba%94" aria-label="条件和标志位响应">条件和标志位响应</a></li>
                <li>
                    <a href="#mov%e6%8c%87%e4%bb%a4" aria-label="MOV指令">MOV指令</a><ul>
                        
                <li>
                    <a href="#movmovs-immediate" aria-label="mov,movs (immediate)">mov,movs (immediate)</a><ul>
                        
                <li>
                    <a href="#a2%e7%bc%96%e7%a0%81%e6%a0%bc%e5%bc%8f" aria-label="A2编码格式">A2编码格式</a></li>
                <li>
                    <a href="#a1%e7%bc%96%e7%a0%81%e6%a0%bc%e5%bc%8f" aria-label="A1编码格式">A1编码格式</a></li></ul>
                </li>
                <li>
                    <a href="#movt" aria-label="movt">movt</a></li>
                <li>
                    <a href="#movmovs-register" aria-label="mov,movs (register)">mov,movs (register)</a></li>
                <li>
                    <a href="#movmovs-register-shifted-register" aria-label="mov,movs (register-shifted register)">mov,movs (register-shifted register)</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e6%95%b4%e5%9e%8b%e8%bf%90%e7%ae%97" aria-label="基本整型运算">基本整型运算</a><ul>
                        
                <li>
                    <a href="#add" aria-label="ADD">ADD</a></li>
                <li>
                    <a href="#subcmp" aria-label="SUB/CMP">SUB/CMP</a></li>
                <li>
                    <a href="#rsb" aria-label="RSB">RSB</a></li>
                <li>
                    <a href="#andtst" aria-label="AND/TST">AND/TST</a></li>
                <li>
                    <a href="#bic" aria-label="BIC">BIC</a></li>
                <li>
                    <a href="#orr" aria-label="ORR">ORR</a></li>
                <li>
                    <a href="#eorteq" aria-label="EOR/TEQ">EOR/TEQ</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%ae%bf%e5%ad%98%e6%8c%87%e4%bb%a4" aria-label="访存指令">访存指令</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="arm-汇编">ARM 汇编<a hidden class="anchor" aria-hidden="true" href="#arm-汇编">#</a></h1>
<p>由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧</p>
<p>主要的学习流程大概这两个：</p>
<ul>
<li>看一下周壑老师的视频</li>
<li>辅助一下利用 <a href="https://azeria-labs.com/">https://azeria-labs.com/</a> 这个网站上的lab进行学习</li>
</ul>
<h2 id="arm-汇编介绍--环境搭建">ARM 汇编介绍 &amp; 环境搭建<a hidden class="anchor" aria-hidden="true" href="#arm-汇编介绍--环境搭建">#</a></h2>
<p>环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ）
ida（ 远程调试 ），keypatch 插件
cemu 做辅助支持 : <a href="https://github.com/hugsy/cemu">https://github.com/hugsy/cemu</a></p>
<p>在ubuntu下面折腾了一下，感觉还行</p>
<p><img loading="lazy" src="image-10.png" alt="alt text"  />
</p>
<p>当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）</p>
<h3 id="android-studio--ida-的配置">Android studio &amp; ida 的配置<a hidden class="anchor" aria-hidden="true" href="#android-studio--ida-的配置">#</a></h3>
<p><img loading="lazy" src="image.png" alt="alt text"  />
</p>
<p>勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下</p>
<p>安装完之后自己在 .zshrc 中配置一下环境变量</p>
<pre tabindex="0"><code>export ANDROID_HOME=&#34;Android/sdk所在路径&#34;
export PATH=${PATH}:${ANDROID_HOME}/tools
export PATH=${PATH}:${ANDROID_HOME}/platform-tools
export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径
</code></pre><p>所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了</p>
<p>代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下</p>
<p><img loading="lazy" src="image-1.png" alt="alt text"  />
</p>
<p>进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}</p>
<p><img loading="lazy" src="image-2.png" alt="alt text"  />
</p>
<p><img loading="lazy" src="image-3.png" alt="alt text"  />
</p>
<p>以后避免每次都打开 android studio可以用emulator里面命令来启动avd</p>
<p><img loading="lazy" src="image-4.png" alt="alt text"  />
</p>
<p>⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了</p>
<p><img loading="lazy" src="image-5.png" alt="alt text"  />
</p>
<p>配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发</p>
<p><img loading="lazy" src="image-6.png" alt="alt text"  />
</p>
<p>这样后ida attach就可以看到对应的进程那些了</p>
<p><img loading="lazy" src="image-7.png" alt="alt text"  />
</p>
<h3 id="c编译环境">c编译环境<a hidden class="anchor" aria-hidden="true" href="#c编译环境">#</a></h3>
<p><a href="https://developer.android.google.cn/ndk/guides/ndk-build?hl=en">https://developer.android.google.cn/ndk/guides/ndk-build?hl=en</a></p>
<p>主要需要的是 Application.mk 和 Android.mk 这两个文件，现在写一个c然后编译一下试试</p>
<pre tabindex="0"><code>APP_ABI := arm64-v8a
APP_BUILD_SCRIPT := Android.mk
APP_PLATFORM := android-16
</code></pre><pre tabindex="0"><code>LOCAL_PATH := $(call my-dir)
#LOCAL_ARM_MODE := arm
LOCAL_MODULE := hello
LOCAL_SRC_FILES := hello.c
include $(BUILD_EXECUTABLE)
</code></pre><p>执行 ndk-build NDK_PROJECT_PATH=. NDK_APPLICATION_MK=Application.mk</p>
<p><img loading="lazy" src="image-8.png" alt="alt text"  />
</p>
<p>可以看到已经生成了，一个是debug版本的一个是release版本的，ida这样就可以开始调试起来了</p>
<p><img loading="lazy" src="image-9.png" alt="alt text"  />
</p>
<p>⚠️ 好像mac m1还没办法运行32位的，所以该文章主要都以64位为主，学的时候也是多学一下64位的毕竟是主流 ( 当然也可以先用32位的来做 )</p>
<h2 id="寄存器和指令基本格式">寄存器和指令基本格式<a hidden class="anchor" aria-hidden="true" href="#寄存器和指令基本格式">#</a></h2>
<h3 id="寄存器介绍">寄存器介绍<a hidden class="anchor" aria-hidden="true" href="#寄存器介绍">#</a></h3>
<p>找了一台手机可以支持32位的，以及64位的，这样就可以都学一下了</p>
<p><img loading="lazy" src="image-11.png" alt="alt text"  />
</p>
<p>这次就可以32位调试起来了，可以很好看到32位的寄存器</p>
<p><img loading="lazy" src="image-12.png" alt="alt text"  />
</p>
<p>arm32下一共有16个通用寄存器和一个状态寄存器</p>
<ul>
<li>其中r13叫做SP叫做栈指针寄存器相当于x86汇编中的esp</li>
<li>LR叫做linker指针，当执行函数调用指令 BL func（Branch with Link）时，CPU 会自动把下一条指令的地址（PC + 4）写入 LR，并且跳转到 func 标签执行
<pre tabindex="0"><code>BL func     ; lr = pc + 4, 跳转到 func
</code></pre>函数如果想要返回的话
<pre tabindex="0"><code>MOV PC, LR  ; 回到调用点继续执行
</code></pre>如果函数内又调用了别的函数，LR 会被覆盖，所以通常编译器会
<pre tabindex="0"><code>STMDB sp!, {LR}   ; 保存返回地址
  ...
LDMIA sp!, {PC}    ; 恢复并返回
</code></pre></li>
<li>PC (Program Counter) 里面存放的是当前的地址，对应x86里的eip</li>
<li>PSR相当于x86中的eflag寄存器 可以看到arm手册里的介绍
<img loading="lazy" src="image-13.png" alt="alt text"  />
</li>
</ul>
<p>对于PSR (当前程序状态寄存器) 这些位的介绍：</p>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>N (bit 31)</strong></td>
<td>Negative</td>
<td>结果为负</td>
<td>若算术结果为负，N=1</td>
</tr>
<tr>
<td><strong>Z (bit 30)</strong></td>
<td>Zero</td>
<td>结果为零</td>
<td>若结果为 0，Z=1</td>
</tr>
<tr>
<td><strong>C (bit 29)</strong></td>
<td>Carry</td>
<td>进位标志</td>
<td>加法进位或减法借位</td>
</tr>
<tr>
<td><strong>V (bit 28)</strong></td>
<td>Overflow</td>
<td>溢出标志</td>
<td>有符号运算时溢出</td>
</tr>
</tbody>
</table>
<pre tabindex="0"><code>ADD r0, r1, r2   ; CPSR.C 被设置为进位标志
SUBS r0, r1, r2  ; 带S的指令会更新 N Z C V 标志
</code></pre><p>27 位：Q（Saturation flag，饱和标志）</p>
<ul>
<li>用于 饱和运算（Saturating Arithmetic）指令，如 QADD、QDADD</li>
<li>当运算结果超出表示范围时，Q=1</li>
<li>可用 MSR CPSR_f, #0 或 MRS/MSR 指令清除或读取</li>
</ul>
<p>26–25 位：IT[7:6]（If-Then 块标志）</p>
<ul>
<li>用于 Thumb 模式的 IT（If-Then）块控制
<pre tabindex="0"><code>ITE EQ
MOVEQ r0, #1
MOVNE r0, #0

#这时 CPSR 的 IT 位会被硬件自动设置与清空
</code></pre></li>
</ul>
<p>19–16 位：GE[3:0]（Greater or Equal flags）</p>
<ul>
<li>用于 SIMD（多数据并行）中的比较结果标志（例如 UADD8, USUB8 等）</li>
<li>每一位对应 8 位操作结果是否大于等于</li>
</ul>
<p>9 位：E（Endian bit）现在arm系统几乎都是小端的</p>
<ul>
<li>E = 0 → 小端（Little-endian）</li>
<li>E = 1 → 大端（Big-endian）</li>
</ul>
<p>5 位：T（Thumb state）</p>
<ul>
<li>T = 0 → ARM 模式（32 位指令）</li>
<li>T = 1 → Thumb 模式（16 位指令）
<pre tabindex="0"><code>BX R0      ; 跳转到R0地址，并根据最低位决定T标志
# 如果 R0 的最低位为 1，会自动切换到 Thumb 模式
</code></pre></li>
</ul>
<p>4–0 位：M[4:0]（处理器模式位）</p>
<table>
<thead>
<tr>
<th>模式位（M4:M0）</th>
<th>模式名</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>10000</code></td>
<td>User</td>
<td>非特权</td>
<td>普通用户态</td>
</tr>
<tr>
<td><code>10001</code></td>
<td>FIQ</td>
<td>特权</td>
<td>快速中断</td>
</tr>
<tr>
<td><code>10010</code></td>
<td>IRQ</td>
<td>特权</td>
<td>普通中断</td>
</tr>
<tr>
<td><code>10011</code></td>
<td>Supervisor (SVC)</td>
<td>特权</td>
<td>系统调用 / 启动模式</td>
</tr>
<tr>
<td><code>10111</code></td>
<td>Abort</td>
<td>特权</td>
<td>内存访问异常</td>
</tr>
<tr>
<td><code>11011</code></td>
<td>Undefined</td>
<td>特权</td>
<td>未定义指令异常</td>
</tr>
<tr>
<td><code>11111</code></td>
<td>System</td>
<td>特权</td>
<td>特殊内核态</td>
</tr>
</tbody>
</table>
<h3 id="总体设计和指令规格">总体设计和指令规格<a hidden class="anchor" aria-hidden="true" href="#总体设计和指令规格">#</a></h3>
<p>arm汇编中没有隐式内存操作指令</p>
<p>这个怎么理解呢？
可以这么来说，在x86汇编中有很多的隐式内存操作指令，比如push pop call，比如push这个指令，这个指令本身是没有内存的索引地址的，这个指令操作后会隐式的把esp指针的地址-4并且往其中写一个数，那么这个push这个指令就隐式的操作了内存，包括中断指令int 等等</p>
<p>arm汇编中，指令是 0 - 3个操作数，内存操作数和立即数操作数不能同时存在（因为 ARM 是典型的 load–store（取数-运算分离） 架构），内存操作数至多出现1次，寄存器操作数一般都是在前面</p>
<p>这里大概理解了一下为什么内存操作数和立即操作数不能同时存在：
指令位数固定，要同时编码“访存寻址模式 + 数据算术的立即数/移位 + 寄存器号 + 条件码”，位不够用，解码也会变复杂，所以把复杂操作拆成两条简单指令，可以更好的乱序执行，把“访存”和“算术”拆开，硬件解码与执行更规整，单周期（或固定多周期）更容易保证；条件执行也更可控</p>
<p><img loading="lazy" src="image-14.png" alt="alt text"  />
</p>
<p>可以观察看到，左边的都是寄存器操作数，上面看到的LDR R6, [R6,#0xC]这种的属于两个操作数，后面的只是内存的一种索引模式
再比如：MOV.W R7, R9,LSR#12 这也是两个操作数，第二个R9,LSR#12这属于一个操作数</p>
<h2 id="读pc寄存器">读pc寄存器<a hidden class="anchor" aria-hidden="true" href="#读pc寄存器">#</a></h2>
<p>在arm的这个汇编的情况中，pc寄存器属于那种正常的寄存器，可以对这个寄存器进行写，那么写到这个寄存器就相当于了指令跳转，写了个例子方便理解，可以看到跳过了地址是8的位置，直接到了c的地址</p>
<p><img loading="lazy" src="image-15.png" alt="alt text"  />
</p>
<p>读取pc寄存器有很多比较奇怪的行为，读取pc寄存器的时候，如果是arm模式会+8，thumb模式+4，因为ARM的流水线是为了性能优化设计的让CPU在执行当前指令的同时，已经把下一条、下下条都装载进指令缓存</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>指令长度</th>
<th>流水线深度</th>
<th>读取 PC 实际值</th>
<th>偏移原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ARM 模式</strong></td>
<td>4 字节</td>
<td>提前取两条</td>
<td>当前地址 + 8</td>
<td>三段流水线取指超前</td>
</tr>
<tr>
<td><strong>Thumb 模式</strong></td>
<td>2 字节</td>
<td>提前取一条</td>
<td>当前地址 + 4</td>
<td>指令短、取指周期短</td>
</tr>
</tbody>
</table>
<p><img loading="lazy" src="image-16.png" alt="alt text"  />
</p>
<p>ldr的指令读pc的内存也同理，可以看到后面的pc读取的数据pc被+8，然后读取8位置的值，所以pc寄存器只要有读的指令存在就是读的就是pc+8</p>
<p><img loading="lazy" src="image-17.png" alt="alt text"  />
</p>
<p>这里说一个问题就是ldr r0,[pc, #-4]</p>
<p><img loading="lazy" src="image-18.png" alt="alt text"  />
</p>
<p>但是比如你在ida调试那些环境下，那么读的就不是这个值了</p>
<p>这里加一个小trips (关于ida安装keypatch):
这里我用了高版本的ida9.0，keypatch不支持：https://bbs.kanxue.com/thread-286591.htm#msg_header_h3_4</p>
<p>编译之前看一下自己ida的架构，然后编译的keystone的dylib要对应上</p>
<p><img loading="lazy" src="image-19.png" alt="alt text"  />
</p>
<p><img loading="lazy" src="image-20.png" alt="alt text"  />
</p>
<p>就可以用了</p>
<p><img loading="lazy" src="image-21.png" alt="alt text"  />
</p>
<p>继续回到主题！调试环境下的为什么不是这个值，我们看一下
这里我写的是 ldr r0, [pc, #-4]，ida帮我们优化了一下可以直接看到地址，之前说的pc寄存器遇见读的指令pc在arm模式下会+8，由于我-4了，所以应该是pc+4，读到的值r0应该是912fff1e</p>
<p><img loading="lazy" src="image-22.png" alt="alt text"  />
</p>
<p>我们现在看一下，读取到底是什么值，可以看到读取的是E7F001F0，这个是什么呢，我在下面硬编码改了一下，发现时UND #10，这个是什么？！</p>
<p><img loading="lazy" src="image-23.png" alt="alt text"  />
</p>
<p>网上查了一下，这个值都和反调试有关系，那么可以理解为，这里相当于读的断点的中断指令，类似于x86中f8的int 3，相当于单步的时候会有一个信号，信号呢被调试器捕获，然后ida捕获到异常，然后进行处理</p>
<p><img loading="lazy" src="image-24.png" alt="alt text"  />
</p>
<p>thumb模式下：</p>
<p>先看第一个指令ldr r0,[pc] 这个在thumb模式下是pc + 4的地址读取出来</p>
<p><img loading="lazy" src="image-25.png" alt="alt text"  />
</p>
<p>可以看到又读了一个中断 DE10</p>
<p><img loading="lazy" src="image-26.png" alt="alt text"  />
</p>
<p>但是这里有疑问了，不是pc+4吗，继续往下看下面的两个都是e4的那个，就可以知道了，其实是有地址对齐的问题存在，所以才会两个条指令都是相同的pc+4但是对应的地址是一样的情况，所以thumb模式下还需要对齐，可以总结规律thumb模式下ldr reg,[pc]的pc地址是要 pc - pc % 4</p>
<p><img loading="lazy" src="image-27.png" alt="alt text"  />
</p>
<p>看一下公式准不准确用上面的d6的地址做一下对应的计算，可以看到是d8</p>
<p><img loading="lazy" src="image-28.png" alt="alt text"  />
</p>
<p>这种的东西在arm模式下不考虑，因为arm模式下都是4字节的，所以都是对齐的情况</p>
<h2 id="条件和标志位响应">条件和标志位响应<a hidden class="anchor" aria-hidden="true" href="#条件和标志位响应">#</a></h2>
<p>Trips:（大部分的指令的说明都在arm手册的F5.1 以及 C6.2下）可以自己没事的时候看看</p>
<p><img loading="lazy" src="image-29.png" alt="alt text"  />
</p>
<p>上面的图代表了arm中的条件标志位的一些标识，比如如果相等就是EQ那么z就等于1这些，上面的这些助记符扩展都可以加入一些指令后面，比如 addeq r0, r0, #1 那么这句的含义就是当z=1的时候r0 = r0 + 1</p>
<p>让这些标志位进行改变的，举例大概有cmp，或者是某些指令加了后面加了s的，因为加了s就可以把指令影响的标志寄存器进行改，用add进行举例可以看到，adds如果reg不是pc，他会更新psr中的标志位的</p>
<p><img loading="lazy" src="image-30.png" alt="alt text"  />
</p>
<p>直接写汇编调试一下运行看看，写的是add r0,r0,r1 r0 = 1 r1 = 0xffffffff，是进位的，但是add指令是不改变标志寄存器只改变结果，所以没有看到</p>
<p><img loading="lazy" src="image-31.png" alt="alt text"  />
</p>
<p>现在我变成adds可以看一下，可以看到改表了标志寄存器的值，发生了进位和为0，所以c位和z位变成了1</p>
<p><img loading="lazy" src="image-32.png" alt="alt text"  />
</p>
<p>查看手册可以发现上面说的第20位为S位，如果是1就是adds，如果是0那么就是add</p>
<pre tabindex="0"><code>01 00 80 E0             ADD     R0, R0, R1
01 00 90 E0             ADDS    R0, R0, R1

0000 0001 0000 0000 1000 0000 1110 0000
0000 0001 0000 0000 1001 0000 1110 0000
</code></pre><p>其中有一个和x86相反的规则是减法指令，可以看一下，第一个sub r0,r0,r1 其中的r0 = 0, r1 = 0xffffffff，第二个r0 = 2，r1 = 1</p>
<p><img loading="lazy" src="image-33.png" alt="alt text"  />
</p>
<p>可以看到结果对了，但是c位没有变成1，但是第二个的时候c位变成了1</p>
<p><img loading="lazy" src="image-34.png" alt="alt text"  />
</p>
<p>这个位置就和之前x86学习汇编有一点不一样的情况，这里的情况是产生借位c是0，不产生借位c是0，规则就是减法就是加法器a−b=a+(∼b+1)</p>
<p>这边有几个对应的指令</p>
<pre tabindex="0"><code>sub subs cmp
add adds cmn
</code></pre><p>如果想判断哪些指令有没有更新标志寄存器，你只需要看第20位是不是1，或者第五个十六进制是不是奇数就行，我在libc中随便找的一个函数，可以看到第五个如果是奇数的话，那么就是会改变psr寄存器的</p>
<p><img loading="lazy" src="image-35.png" alt="alt text"  />
</p>
<h2 id="mov指令">MOV指令<a hidden class="anchor" aria-hidden="true" href="#mov指令">#</a></h2>
<p>mov指令没有访存的操作，所以两个操作数要不就是reg要不就是imm</p>
<p><img loading="lazy" src="image-36.png" alt="alt text"  />
</p>
<h3 id="movmovs-immediate">mov,movs (immediate)<a hidden class="anchor" aria-hidden="true" href="#movmovs-immediate">#</a></h3>
<p>因为arm的指令集是4字节的指令，立即数如果是32位的肯定放不下，所以arm的imm没办法直接写32位的立即数，mov立即数的情况手册中分成了两种指令格式一种是A1，一种是A2</p>
<p><img loading="lazy" src="image-37.png" alt="alt text"  />
</p>
<h4 id="a2编码格式">A2编码格式<a hidden class="anchor" aria-hidden="true" href="#a2编码格式">#</a></h4>
<p>先看一下A2的指令格式，上面有写到，A2的指令格式支持所有16位的立即数，这16位的立即数会写在0-11为以及16-19位，其中的12-15位代表了寄存器正好是4位代表了16个寄存器</p>
<p>举个例子 mov r1, #0x1234 对应的硬编码是E3011234，那么正好就是0-11为234，16-19为1，12-15为1，正好和上面对应上了</p>
<p><img loading="lazy" src="image-38.png" alt="alt text"  />
</p>
<h4 id="a1编码格式">A1编码格式<a hidden class="anchor" aria-hidden="true" href="#a1编码格式">#</a></h4>
<p>比如这个指令：mov r1, #0x80000000，这个立即数已经超过了16位的范围，是32位的范围，那么这种情况就是对应的A1编码格式的情况，为什么要这么设计呢？</p>
<p>虽然他比16位大，但是他的有效位只有最开始那一位</p>
<p><img loading="lazy" src="image-39.png" alt="alt text"  />
</p>
<p>这个硬编码根据A1拆分，0-11位是102，12-15的rd为1不变，16-19是0</p>
<p>上面的解释是A32ExpandImm_C(imm12, PSTATE.C)，imm12需要拆成rot = imm12[11:8]，以及imm8 = imm12[7:0]，其中的rot的单位为2，所以上面的102可以为 02像右循环移为2，因为是32位02为10，像右循环移位2就是1（31个0），所以就是0x80000000，那么说明这个就可以表示0x0 - 0xff的情况都可以像右循环移位，移动的位数是0-16，为什么要乘2，那么就可以覆盖32位，那么就覆盖了0-32位的偶数</p>
<h3 id="movt">movt<a hidden class="anchor" aria-hidden="true" href="#movt">#</a></h3>
<p><img loading="lazy" src="image-40.png" alt="alt text"  />
</p>
<p>movt是像高4位写，如果像写32位的可以这么写</p>
<pre tabindex="0"><code>mov r1,#0x5678
movt r1,#0x1234
</code></pre><p><img loading="lazy" src="image-41.png" alt="alt text"  />
</p>
<p>ida优化就直接合并成了一条指令，这个movt的指令一定是先写mov后写movt，因为mov指令会把前面的4字节变成0，那么先写movt就没用了</p>
<p>那么在实际代码中编译器怎么写的这个情况呢，可以看一下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">u_int32_t</span> <span class="n">test_var</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Test variable value: 0x%X</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">test_var</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Hello, World!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">getchar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以看到真实的环境下的寻址，都是通过ldr的这种方式去寻址的，movt这种一般是后面写shellcode的时候比较有用处</p>
<p><img loading="lazy" src="image-42.png" alt="alt text"  />
</p>
<h3 id="movmovs-register">mov,movs (register)<a hidden class="anchor" aria-hidden="true" href="#movmovs-register">#</a></h3>
<p><img loading="lazy" src="image-43.png" alt="alt text"  />
</p>
<p>这个普通的mov reg,reg肯定都比较了解了，其中的0-3位为源寄存器，12-15为目标寄存器，举例中的这个mov r0,r1，其中r1就是0-3位为1，r0就是12-15位为0</p>
<p><img loading="lazy" src="image-44.png" alt="alt text"  />
</p>
<p>这个上面的图中的imm5就代表了可以进行移位的数字，可以看到是7-11位，一共是5位，5位就是代表了0-31，就是32个数字，也对应了32位</p>
<p>下面这个例子就是左移1位，怎么移就要看5-6位的stype位了，因为有两位所以对应了四种情况：逻辑左移，逻辑右移，算数右移，循环移位 （没有算数左移，因为这个是和逻辑左移式一样的）</p>
<p><img loading="lazy" src="image-45.png" alt="alt text"  />
</p>
<p>在看一下移位的汇编，其实和mov的硬编码是一样的，因为他们的原理等价了mov的东西，其实移位的操作可以理解为是mov指令的一个宏定义</p>
<p><img loading="lazy" src="image-46.png" alt="alt text"  />
</p>
<h3 id="movmovs-register-shifted-register">mov,movs (register-shifted register)<a hidden class="anchor" aria-hidden="true" href="#movmovs-register-shifted-register">#</a></h3>
<p>这个是寄存器移位寄存器赋值给寄存器，所以和上面的大概的流程是一样的不重复了</p>
<p><img loading="lazy" src="image-47.png" alt="alt text"  />
</p>
<h2 id="基本整型运算">基本整型运算<a hidden class="anchor" aria-hidden="true" href="#基本整型运算">#</a></h2>
<p>基本运算基本不会出现两个imm，因为举个例子，比如 add r0,1,2 相当于r0 = 3，这个写出来就很奇怪了，早就在编译器的那一步就给你优化掉了</p>
<p>像这种基本整形运算其实大部分都一样，格式所以主要以add来举例说明，后面的简单介绍功能就可以</p>
<h3 id="add">ADD<a hidden class="anchor" aria-hidden="true" href="#add">#</a></h3>
<p>见到这种12位的imm，其实本质上都是之前说的mov的那种形式 8位代表数字，4位代表移位</p>
<p><img loading="lazy" src="image-48.png" alt="alt text"  />
</p>
<p>寄存器的就比较简单了，两个寄存器想加写在第三个寄存器里，其中的imm5和stype就是之前mov中的说的移位操作</p>
<p><img loading="lazy" src="image-49.png" alt="alt text"  />
</p>
<p>这个就也和上面的mov类似就是寄存器移位寄存器</p>
<p><img loading="lazy" src="image-50.png" alt="alt text"  />
</p>
<p>这个就是pc+imm给到另一个寄存器了</p>
<p><img loading="lazy" src="image-51.png" alt="alt text"  />
</p>
<p>看一下汇编 add r0,pc,4</p>
<p><img loading="lazy" src="image-52.png" alt="alt text"  />
</p>
<p>ida中对应什么呢，因为pc进行读就需要当前的pc+8，上面的指令加上4，所以就是2c的位置，但是在正常的调试环境中，或者运行环境中会根据imagebase进行调整可以在这里看一下printf的位置的这个情况</p>
<p><img loading="lazy" src="image-53.png" alt="alt text"  />
</p>
<p>printf这个情况，可以看到他把imagebase加上去了</p>
<p><img loading="lazy" src="image-54.png" alt="alt text"  />
</p>
<h3 id="subcmp">SUB/CMP<a hidden class="anchor" aria-hidden="true" href="#subcmp">#</a></h3>
<p>减法操作
SUB Rd, Rn, Op2：Rd = Rn - Op2
CMP Rn, Op2：只比较不写寄存器，等价于 SUBS (丢弃结果)</p>
<pre tabindex="0"><code>; i--，并在为零时跳走
SUBS    r0, r0, #1
BEQ     don
; 比较 a 与 b
CMP     r1, r2         ; 相当于 SUBS r?, r1, r2
BGE     ge_path        ; 大于等于走这里（无借位 + 非溢出）
</code></pre><h3 id="rsb">RSB<a hidden class="anchor" aria-hidden="true" href="#rsb">#</a></h3>
<p>反减
RSB Rd, Rn, Op2：Rd = Op2 - Rn</p>
<pre tabindex="0"><code>; 取负：Rd = -Rm
RSBS    r0, r1, #0     ; r0 = 0 - r1，顺带写标志
</code></pre><h3 id="andtst">AND/TST<a hidden class="anchor" aria-hidden="true" href="#andtst">#</a></h3>
<p>与操作
AND Rd, Rn, Op2：Rd = Rn &amp; Op2
TST Rn, Op2：与运算并只写标志，等价于 ANDS (丢弃结果)</p>
<pre tabindex="0"><code>; 测试 r0 的 bit 7 是否为 1
TST     r0, #(1&lt;&lt;7)
BNE     bit7_is_one
</code></pre><h3 id="bic">BIC<a hidden class="anchor" aria-hidden="true" href="#bic">#</a></h3>
<p>反与，按位清零
BIC Rd, Rn, Op2：Rd = Rn &amp; ~Op2</p>
<pre tabindex="0"><code>; 清 r0 的低 4 位
BIC     r0, r0, #0xF
; 清 r1 的 bit 20（把 bit20 置 0）
BIC     r1, r1, #(1&lt;&lt;20)
</code></pre><h3 id="orr">ORR<a hidden class="anchor" aria-hidden="true" href="#orr">#</a></h3>
<p>或
ORR Rd, Rn, Op2：Rd = Rn | Op2</p>
<pre tabindex="0"><code>; 置 r0 的 bit 3 和 bit 5
ORR     r0, r0, #(1&lt;&lt;3) | (1&lt;&lt;5)
</code></pre><h3 id="eorteq">EOR/TEQ<a hidden class="anchor" aria-hidden="true" href="#eorteq">#</a></h3>
<p>异或
EOR Rd, Rn, Op2：Rd = Rn ^ Op2（按位异或/翻转）
TEQ Rn, Op2：只写标志，等价于 EORS (丢弃结果)，常用来“测试相等性（按位相同则结果 0）”或“测试奇偶”</p>
<pre tabindex="0"><code>; 翻转 r0 的 bit 8
EOR     r0, r0, #(1&lt;&lt;8)
; 判断 r1 与 r2 的比特是否完全相同
TEQ     r1, r2
BEQ     equal_bits     ; r1 ^ r2 == 0
</code></pre><h2 id="访存指令">访存指令<a hidden class="anchor" aria-hidden="true" href="#访存指令">#</a></h2>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://l0x1c.com/posts/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">
    <span class="title">« Prev</span>
    <br>
    <span>xv6 环境配置 vmare or docker</span>
  </a>
  <a class="next" href="https://l0x1c.com/posts/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
    <span class="title">Next »</span>
    <br>
    <span>内存管理</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
