[{"content":"关于dy的a_bogus逆向，jsvmp\n进行抖音抓包，对应的位置在\nurl = \u0026#34;https://www.douyin.com/aweme/v1/web/aweme/post/\u0026#34; 可以看一下调用栈，不难发现主要的逻辑在bdms_1.0.1.19_fix.js\n直接跳过去可以看到d就是指令操作\n先一点一点的去看\n这个位置调用了atob，代表了对下面的那个字符进行了base64的解密，随后取第 4~7 字节求和得到单字节 key\n再用自定义 map 函数 _ 对余下字节逐个异或，最后把结果送进自带的 DEFLATE 解压器，从而得到可执行的数据块，这里可以很好的看出来这一块是一个压缩文件的格式，对应base64的UEsC\nimport base64, zlib, re, hashlib, os, sys from pathlib import Path BASE64_DATA = r\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;.strip() # ============================================== def sanitize_b64(s: str) -\u0026gt; str: return re.sub(r\u0026#39;[^A-Za-z0-9+/=]\u0026#39;, \u0026#39;\u0026#39;, s) def xor_transform(decoded: bytes) -\u0026gt; tuple[bytes, int, int]: key_sum = sum(decoded[4:8]) \u0026amp; 0xFFFFFFFF km = key_sum % 256 step = km % 10 tail = decoded[8:] out = bytearray(len(tail)) for i, b in enumerate(tail): out[i] = (b ^ ((km + step * i) % 256)) \u0026amp; 0xFF return bytes(out), key_sum, km def inflate_raw(data: bytes) -\u0026gt; bytes: return zlib.decompress(data, -15) def main(): b64 = sanitize_b64(BASE64_DATA) raw = base64.b64decode(b64) mapped = xor_transform(raw) payload = inflate_raw(mapped) out_path = Path(os.getcwd()) / \u0026#34;payload.bin\u0026#34; out_path.write_bytes(payload) if __name__ == \u0026#34;__main__\u0026#34;: main() 可以和dump的东西进行对应上\nfunction W(t) { for (var r = 0, e = 0; ; ) { var n = t.d[t.i++]; if (r |= (127 \u0026amp; n) \u0026lt;\u0026lt; e, e += 7, !(128 \u0026amp; n)) return e \u0026lt; 32 \u0026amp;\u0026amp; 64 \u0026amp; n ? r | -1 \u0026lt;\u0026lt; e : r } } 最开始的e9 07\n0xe9 = 1110 1001\n低 7 位 0x69 = 105\n0x07 = 0000 0111\n低 7 位 0x07 = 7\n累加：val += 7 \u0026lt;\u0026lt; 7 = 7 * 128 = 896\n总和：105 + 896 = 1001\n所以字符串池的条数为1001条\n字符串的位置走过后，这个位置是函数表对应的条数\n0x1C | 0x80 = 0x9C\n计算后这个位置应该是796条，下图调试的位置吻合\n打印出来：\n字符串表\na_bogus对应的是表的Z[220]\n调试位置对应的url的方法\n调试到这里可以看到对应的字节码的东西为\n{\u0026#34;f\u0026#34;: [34, 54, 0, 3, 34, 30, 214, 41, 212, 34, 30, 214, 30, 70, 54, 0, 4, 74, 0, 4, 30, 218, 54, 0, 5, 74, 0, 5, 30, 72, 54, 0, 6, 33, 74, 2, 33, 74, 0, 6, 0, 1, 54, 0, 7, 74, 0, 7, 41, 5, 74, 0, 6, 53, 11, 60, 161, 74, 0, 6, 60, 216, 30, 178, 59, 2, 54, 0, 8, 74, 0, 8, 30, 162, 18, 30, 219, 73, 165, 0, 1, 29, 17, 5, 74, 2, 3, 30, 150, 41, 18, 74, 0, 8, 30, 162, 18, 30, 163, 73, 165, 74, 2, 3, 30, 150, 0, 2, 26, 74, 0, 8, 30, 162, 18, 30, 219, 73, 220, 0, 1, 29, 41, 45, 33, 74, 3, 14, 0, 0, 26, 33, 74, 2, 37, 74, 0, 8, 30, 162, 18, 30, 9, 0, 0, 74, 0, 2, 0, 2, 54, 0, 9, 74, 0, 8, 30, 162, 18, 30, 163, 73, 220, 74, 0, 9, 0, 2, 26, 74, 0, 7, 29, 41, 10, 74, 0, 5, 74, 0, 8, 30, 178, 20, 72, 34, 30, 214, 18, 30, 51, 63, 108, 0, 1, 26, 33, 74, 2, 36, 74, 0, 8, 30, 215, 0, 1, 41, 7, 33, 74, 2, 5, 0, 0, 26, 34, 73, 214, 25, 26, 74, 1, 4, 18, 30, 126, 34, 74, 0, 2, 39, 1, 0, 2, 26, 33, 76], \u0026#34;i\u0026#34;: 1, \u0026#34;u\u0026#34;: true, \u0026#34;s\u0026#34;: []}, 这个序列是给\u0026quot;a_bogus\u0026quot;赋值的序列\n观察这个a_bogus的赋值的情况，是在var m = n.apply(d, e)中给值放到了v[p++]中，观察e的值的来源，在观察整个虚拟机，可以看到所有的v[p]都参与了基本指令运算，关于+-*/%\u0026amp;\u0026gt;\u0026gt;\u0026lt;\u0026lt;，而且观察所有的基本运算所虚拟机表示的中的位置只有一个，那么可以思考就是对于每一个opcode，这个虚拟机只对应了简单的指令运算，然后进行大量的拼接得到的算法，所以只需要对这些基本运算进行插庄打log就可以看到整个流程的生成了\n打log的位置：所有基本运算，以及最后的放到v[++p]位置的地方\n\u0026#39;m:\u0026#39;,m,\u0026#39;n:\u0026#39;,n,\u0026#39;d:\u0026#39;,d,\u0026#39;e:\u0026#39;,e \u0026#39;v[p]:\u0026#39;,v[p] \u0026gt; w ,\u0026#39;=\u0026#39;,\u0026#39;v[p]:\u0026#39;,v[p],\u0026#39;\u0026gt;\u0026#39;,\u0026#39;w:\u0026#39;,w \u0026#39;v[p]:\u0026#39;,v[p] % E ,\u0026#39;=\u0026#39;,\u0026#39;v[p]:\u0026#39;,v[p],\u0026#39;%\u0026#39;,\u0026#39;E:\u0026#39;,E \u0026#39;v[p]:\u0026#39;,v[p] \u0026amp; E ,\u0026#39;=\u0026#39;,\u0026#39;v[p]:\u0026#39;,v[p],\u0026#39;\u0026amp;\u0026#39;,\u0026#39;w:\u0026#39;,w \u0026#39;v[p]:\u0026#39;,v[p] \u0026gt;\u0026gt;\u0026gt; w ,\u0026#39;=\u0026#39;,\u0026#39;v[p]:\u0026#39;,v[p],\u0026#39;\u0026gt;\u0026gt;\u0026gt;\u0026#39;,\u0026#39;w:\u0026#39;,w \u0026#39;v[p]:\u0026#39;,v[p] - E ,\u0026#39;=\u0026#39;,\u0026#39;v[p]:\u0026#39;,v[p],\u0026#39;-\u0026#39;,\u0026#39;E:\u0026#39;,E \u0026#39;v[p]:\u0026#39;,v[p] \u0026gt;\u0026gt; w ,\u0026#39;=\u0026#39;,\u0026#39;v[p]:\u0026#39;,v[p],\u0026#39;\u0026gt;\u0026gt;\u0026#39;,\u0026#39;w:\u0026#39;,w \u0026#39;v[p]:\u0026#39;,v[p] / E ,\u0026#39;=\u0026#39;,\u0026#39;v[p]:\u0026#39;,v[p],\u0026#39;/\u0026#39;,\u0026#39;E:\u0026#39;,E \u0026#39;v[p]:\u0026#39;,v[p] * E ,\u0026#39;=\u0026#39;,\u0026#39;v[p]:\u0026#39;,v[p],\u0026#39;*\u0026#39;,\u0026#39;E:\u0026#39;,E \u0026#39;v[p]:\u0026#39;,v[p] | w ,\u0026#39;=\u0026#39;,\u0026#39;v[p]:\u0026#39;,v[p],\u0026#39;|\u0026#39;,\u0026#39;w:\u0026#39;,w \u0026#39;v[p]:\u0026#39;,v[p] \u0026lt;\u0026lt; w ,\u0026#39;=\u0026#39;,\u0026#39;v[p]:\u0026#39;,v[p],\u0026#39;\u0026lt;\u0026lt;\u0026#39;,\u0026#39;w:\u0026#39;,w \u0026#39;v[p]:\u0026#39;,v[p] + E ,\u0026#39;=\u0026#39;,\u0026#39;v[p]:\u0026#39;,v[p],\u0026#39;+\u0026#39;,\u0026#39;E:\u0026#39;,E \u0026#39;v[p]:\u0026#39;,v[p] ^ w ,\u0026#39;=\u0026#39;,\u0026#39;v[p]:\u0026#39;,v[p],\u0026#39;^\u0026#39;,\u0026#39;w:\u0026#39;,w 直接开始跑，我们从最后生成往上回溯分析\n可以看到a_bogus，这里满足base64变表，直接写个脚本测试一下\nimport random BASE_TABLE = \u0026#34;Dkdpgh2ZmsQB80/MfvV36XI1R45-WUAlEixNLwoqYTOPuzKFjJnry79HbGcaStCe\u0026#34; def b64_swap_decode(s: str, alphabet: str = BASE_TABLE) -\u0026gt; bytes: table = {ch: i for i, ch in enumerate(alphabet)} s = s.strip() if len(s) % 4: s += \u0026#34;=\u0026#34; * ((4 - len(s) % 4) % 4) out = bytearray() for i in range(0, len(s), 4): block = s[i:i+4] pad = block.count(\u0026#34;=\u0026#34;) vals = [] for ch in block: if ch == \u0026#34;=\u0026#34;: vals.append(0) else: if ch not in table: raise ValueError(f\u0026#34;字母表中不存在字符: {repr(ch)}\u0026#34;) vals.append(table[ch]) v = (vals[0] \u0026lt;\u0026lt; 18) | (vals[1] \u0026lt;\u0026lt; 12) | (vals[2] \u0026lt;\u0026lt; 6) | vals[3] out.append((v \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) if pad \u0026lt; 2: out.append((v \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) if pad \u0026lt; 1: out.append(v \u0026amp; 0xFF) return bytes(out) def b64_swap_encode(b: bytes, alphabet: str = BASE_TABLE) -\u0026gt; str: res = [] for i in range(0, len(b), 3): chunk = b[i:i+3] pad = 3 - len(chunk) if pad: chunk = chunk + b\u0026#34;\\x00\u0026#34; * pad val = (chunk[0] \u0026lt;\u0026lt; 16) | (chunk[1] \u0026lt;\u0026lt; 8) | chunk[2] res.append(alphabet[(val \u0026gt;\u0026gt; 18) \u0026amp; 0x3F]) res.append(alphabet[(val \u0026gt;\u0026gt; 12) \u0026amp; 0x3F]) res.append(\u0026#34;=\u0026#34; if pad == 2 else alphabet[(val \u0026gt;\u0026gt; 6) \u0026amp; 0x3F]) res.append(\u0026#34;=\u0026#34; if pad \u0026gt;= 1 else alphabet[val \u0026amp; 0x3F]) return \u0026#34;\u0026#34;.join(res) if __name__ == \u0026#34;__main__\u0026#34;: encoded = \u0026#34;Q6UVhHtyDdWRKVFGuCcOeJKU2Uj/rPuynlTdbzPPtBtTOq0aBSP2MnbScouJskbjL8BziKVHqEtlbDnczGU0Z99kzmpDSm4fosVCV68oZqwgTeGmLrD/ehhzuwBC0QJwl5C6NAU51sBn2jVAIq5uWd3GH5To5bEdSrZ6D/LytEAgfCSkk93kOCDdEgaFUvcG\u0026#34; raw = b64_swap_decode(encoded, BASE_TABLE) print(\u0026#34;Decoded bytes:\u0026#34;, raw) print(\u0026#34;Decoded as UTF-8:\u0026#34;, raw.decode(\u0026#34;utf-8\u0026#34;, errors=\u0026#34;replace\u0026#34;)) print(\u0026#34;Decimal values:\u0026#34;, \u0026#34; \u0026#34;.join(str(byte) for byte in raw)) 可以看到和刚过来的数组是一样的\n在这里可以看到，这里的字符是拼接来的，前4字节和后面进行了拼接，先看一下后面的字节的来源\n追上去后可以看到两个部分的线索，直接直接就可以根据rc4的特征来看到，这部分上面是表的生成，下面是标准的rc4的算法（除了表生成位置）\n表生成位置：\n直接根据他给的写就行，写一下算法，key可以很好的看到是211\nimport random BASE_TABLE = \u0026#34;Dkdpgh2ZmsQB80/MfvV36XI1R45-WUAlEixNLwoqYTOPuzKFjJnry79HbGcaStCe\u0026#34; def rc4(data: bytes, key: bytes) -\u0026gt; bytes: seed = (sum(key) \u0026amp; 0xff) if key else 0 raw = list(range(255, -1, -1)) z = 0 n = len(raw) for i in range(n): a = (z + seed) % 256 raw[i], raw[a] = raw[a], raw[i] if i + 1 \u0026lt; n: z = raw[i + 1] * a + a i = 0 j = 0 out = bytearray() for b in data: i = (i + 1) \u0026amp; 0xff j = (j + raw[i]) \u0026amp; 0xff raw[i], raw[j] = raw[j], raw[i] K = raw[(raw[i] + raw[j]) \u0026amp; 0xff] out.append(b ^ K) return bytes(out) def b64_swap_decode(s: str, alphabet: str = BASE_TABLE) -\u0026gt; bytes: table = {ch: i for i, ch in enumerate(alphabet)} s = s.strip() if len(s) % 4: s += \u0026#34;=\u0026#34; * ((4 - len(s) % 4) % 4) out = bytearray() for i in range(0, len(s), 4): block = s[i:i+4] pad = block.count(\u0026#34;=\u0026#34;) vals = [] for ch in block: if ch == \u0026#34;=\u0026#34;: vals.append(0) else: if ch not in table: raise ValueError(f\u0026#34;字母表中不存在字符: {repr(ch)}\u0026#34;) vals.append(table[ch]) v = (vals[0] \u0026lt;\u0026lt; 18) | (vals[1] \u0026lt;\u0026lt; 12) | (vals[2] \u0026lt;\u0026lt; 6) | vals[3] out.append((v \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) if pad \u0026lt; 2: out.append((v \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) if pad \u0026lt; 1: out.append(v \u0026amp; 0xFF) return bytes(out) def b64_swap_encode(b: bytes, alphabet: str = BASE_TABLE) -\u0026gt; str: res = [] for i in range(0, len(b), 3): chunk = b[i:i+3] pad = 3 - len(chunk) if pad: chunk = chunk + b\u0026#34;\\x00\u0026#34; * pad val = (chunk[0] \u0026lt;\u0026lt; 16) | (chunk[1] \u0026lt;\u0026lt; 8) | chunk[2] res.append(alphabet[(val \u0026gt;\u0026gt; 18) \u0026amp; 0x3F]) res.append(alphabet[(val \u0026gt;\u0026gt; 12) \u0026amp; 0x3F]) res.append(\u0026#34;=\u0026#34; if pad == 2 else alphabet[(val \u0026gt;\u0026gt; 6) \u0026amp; 0x3F]) res.append(\u0026#34;=\u0026#34; if pad \u0026gt;= 1 else alphabet[val \u0026amp; 0x3F]) return \u0026#34;\u0026#34;.join(res) if __name__ == \u0026#34;__main__\u0026#34;: encoded = \u0026#34;Q6UVhHtyDdWRKVFGuCcOeJKU2Uj/rPuynlTdbzPPtBtTOq0aBSP2MnbScouJskbjL8BziKVHqEtlbDnczGU0Z99kzmpDSm4fosVCV68oZqwgTeGmLrD/ehhzuwBC0QJwl5C6NAU51sBn2jVAIq5uWd3GH5To5bEdSrZ6D/LytEAgfCSkk93kOCDdEgaFUvcG\u0026#34; raw = b64_swap_decode(encoded, BASE_TABLE) print(\u0026#34;Decoded bytes:\u0026#34;, raw) print(\u0026#34;Decoded as UTF-8:\u0026#34;, raw.decode(\u0026#34;utf-8\u0026#34;, errors=\u0026#34;replace\u0026#34;)) print(\u0026#34;Decimal values:\u0026#34;, \u0026#34; \u0026#34;.join(str(byte) for byte in raw)) rc4_decoded = rc4(raw[4:], bytes([211])) print(\u0026#34;RC4 Decoded bytes:\u0026#34;, rc4_decoded) print(\u0026#34;RC4 Decoded as UTF-8:\u0026#34;, rc4_decoded.decode(\u0026#34;utf-8\u0026#34;, errors=\u0026#34;replace\u0026#34;)) print(\u0026#34;RC4 Decimal values:\u0026#34;, \u0026#34; \u0026#34;.join(str(byte) for byte in rc4_decoded)) RC4 Decimal values: 3 84 32 64 33 16 162 84 145 78 212 47 217 0 218 161 17 64 33 0 221 1 3 144 201 90 33 149 230 218 40 130 200 239 38 227 60 31 8 2 65 66 51 156 107 4 20 27 128 0 206 12 194 64 44 16 155 97 185 240 16 67 40 0 144 43 208 32 107 108 40 17 148 2 29 32 165 113 26 49 253 55 27 54 178 126 17 112 52 113 22 49 236 120 57 56 34 62 49 113 36 49 54 49 124 122 25 56 35 62 53 113 53 113 30 49 108 121 48 56 179 124 105 92 224 35 105 75 255 54 73 100 125 50 52 38 164 110 183 29 rc4这个位置是没有错的，继续往下分析\n前面四个字节的来源，前四个字节是41 71 82 23看一下来源\ndef gen_s() -\u0026gt; str: # a = (int(random.random() * 65535)) \u0026amp; 0xFF # b = int(random.random() * 40) a = (int(0.5446416885859573 * 65535)) \u0026amp; 0xFF b = int(0.5832301287563609 * 40) s = [] s.append(chr((a \u0026amp; 0xAA) | 0x01)) s.append(chr((a \u0026amp; 0x55) | 0x02)) s.append(chr((b \u0026amp; 0xAA) | 0x50)) s.append(chr((b \u0026amp; 0x55) | 0x02)) return \u0026#39;\u0026#39;.join(s) #Generated 4 bytes: b\u0026#39;)GR\\x17\u0026#39; #Generated Decimal values: 41 71 82 23 再往上追可以看到，这个刚才rc4解密的数组是通过8为数组+132位数组来的\n第一组的地方3, 84, 32, 64\n第二组的地方33, 16, 162, 84\ndef gen_r_head2() -\u0026gt; str: # a= (int(random.random() * 240)) \u0026amp; 0xFF # b = (int(random.random() * 255)) \u0026amp; 0xFF \u0026amp; 77 a = (int(0.20071909122733345 * 240)) \u0026amp; 0xFF b = (int(0.83287578221808 * 255)) \u0026amp; 0xFF \u0026amp; 77 w = [1, 4, 5, 7] for i in range(4): b = b | (1 \u0026lt;\u0026lt; w[i]); s = [] s.append(chr((a \u0026amp; 0xAA) | 0x1)) s.append(chr((a \u0026amp; 0x55) | 0x0)) s.append(chr((b \u0026amp; 0xAA) | 0x0)) s.append(chr((b \u0026amp; 0x55) | 0x0)) return \u0026#39;\u0026#39;.join(s) 对应8字节后面的四位33, 16, 162, 84\ndef gen_r_head1() -\u0026gt; str: # z = int(random.random() * 65535) # a = z \u0026amp; 0xFF # b = (z \u0026gt;\u0026gt; 8) \u0026amp; 0xFF a = (int(0.37632919615333793 * 65535)) \u0026amp; 0xFF b = (int(0.37632919615333793 * 65535) \u0026gt;\u0026gt; 8) \u0026amp; 0xFF s = [] s.append(chr((a \u0026amp; 0xAA) | 0x1)) s.append(chr((a \u0026amp; 0x55) | 0x0)) s.append(chr((b \u0026amp; 0xAA) | 0x0)) s.append(chr((b \u0026amp; 0x55) | 0x0)) return \u0026#39;\u0026#39;.join(s) Length of gen: 8 Generated r_head Decimal values: 3 84 32 64 33 16 162 84 正好对应上了\n网上回溯看一下这个是怎么生成的，这个时候可以看到这里面永远都会一组重复的数字145, 110, 66, 189, 44, 211\n根据上面可以写出加密逻辑\nimport random key = [145, 110, 66, 189, 44, 211] data = [1,14,252,201,0,242,0,0,1,220,1,3,217,24,5,230,154,0,201,239,34,44,31,0,208,0,31,123,6,24,0,0,206,82,0,0,154,97,177,0,1,0,0,41,240,123,44,0,4,0,49,53,49,50,124,55,55,50,124,49,53,49,50,124,56,57,51,124,49,53,49,50,124,56,57,51,124,49,53,49,50,124,57,56,50,124,77,97,99,73,110,116,101,108,50,52,53,44,159] result = [] rad = [0.21538688661648553,0.9212125883092179,0.11329993696990215,0.4012867884874777,0.7397694321593413,0.2345646507296566,0.48677241706302965,0.02660945354489941,0.3556811964939194,0.7736328373701941,0.6529429229670689,0.4924646761384377,0.7613914142703988,0.3780540061140839,0.9141587354910575,0.10551554793573337,0.15838251707991813,0.7137565040911108,0.4114927013372691,0.21053933074769915,0.5965956170259822,0.23215038617850303,0.2901816263862327,0.29295876428660983,0.6021625523305605,0.039574963495331406,0.6054109386072396,0.09645229970364944,0.5053147091841774,0.938315440828625,0.41117788486726015,0.05572314150793589,0.9985371346724156] for i in range(0, len(data), 3): #v = (int(random.random() * 1000)) \u0026amp; 0xFF v = (int(rad[i // 3] * 1000)) \u0026amp; 0xFF result.append(chr((v \u0026amp; key[0]) | (data[i] \u0026amp; key[1]))) result.append(chr((v \u0026amp; key[2]) | (data[i + 1] \u0026amp; key[3]))) result.append(chr((v \u0026amp; key[4]) | (data[i + 2] \u0026amp; key[5]))) result.append(chr((data[i] \u0026amp; key[0]) | (data[i + 1] \u0026amp; key[2]) | (data[i + 2] \u0026amp; key[4]))) data_result = \u0026#39;\u0026#39;.join(result).encode(\u0026#34;latin-1\u0026#34;) print(data_result) print(\u0026#34;values:\u0026#34;, \u0026#34; \u0026#34;.join(str(byte) for byte in data_result)) 同理解密逻辑为\ndef decode_data(data) -\u0026gt; str: key = [145, 110, 66, 189, 44, 211] out = [] for i in range(0, len(data), 4): r0, r1, r2, r3 = data[i:i+4] a = (r0 \u0026amp; key[1]) | (r3 \u0026amp; key[0]) b = (r1 \u0026amp; key[3]) | (r3 \u0026amp; key[2]) c = (r2 \u0026amp; key[5]) | (r3 \u0026amp; key[4]) out.extend([a, b, c]) return bytes(out) 对应了：\n[1,14,252,201,0,242,0,0,1,220,1,3,217,24,5,230,154,0,201,239,34,44,31,0,208,0,31,123,6,24,0,0,206,82,0,0,154,97,177,0,1,0,0,41,240,123,44,0,4,0,49,53,49,50,124,55,55,50,124,49,53,49,50,124,56,57,51,124,49,53,49,50,124,56,57,51,124,49,53,49,50,124,57,56,50,124,77,97,99,73,110,116,101,108,50,52,53,44,159 ] 继续往上根\n他把刚才的这些数据进行了分组\n[1,14,252,201,0,242,0,0,1,220,1,3,217,24,5,230,154,0,201,239,34,44,31,0,208,0,31,123,6,24,0,0,206,82,0,0,154,97,177,0,1,0,0,41,240,123,44,0,4,0] [49,53,49,50,124,55,55,50,124,49,53,49,50,124,56,57,51,124,49,53,49,50,124,56,57,51,124,49,53,49,50,124,57,56,50,124,77,97,99,73,110,116,101,108] [50,52,53,44] [159] 中间的第二组，从刚才的解密结果可以发现，这个数组是一些可能带有的参数\n1512|772|1512|893|1512|893|1512|982|MacIntel% 那么剩下关心的就是剩下的这几组的参数了\n四位的情况向上回溯，和时间戳有关系\n可以看到最后的那个单个的数字159是经过很多次的xor得到的\n如果你的记忆里很好的话，看到这里的时候你就一定会知道这些东西你见过，就是之前那个随机的8位数\nGenerated r_head Decimal values: 3 84 32 64 33 16 162 84\n这个时候就会疑问这个41后面的都是哪里来的，重新trace看一下对应的位置\nXor 41索引位置24\n依次把x都拿出来，就可以得到索引\n[24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 51, 52, 53, 55, 56, 57, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 79, 80, 84, 85] 写代码实现就是\nw = [24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 51, 52, 53, 55, 56, 57, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 79, 80, 84, 85] w_8 = [169, 21, 136, 81, 137, 81, 162, 21] table_gobal = [ [ { \u0026#34;5\u0026#34;: { \u0026#34;aid\u0026#34;: 6383, \u0026#34;pageId\u0026#34;: 6241, \u0026#34;boe\u0026#34;: 0, \u0026#34;ddrt\u0026#34;: 8.5, \u0026#34;paths\u0026#34;: { \u0026#34;include\u0026#34;: [ {}, {}, {}, {}, {}, {}, {}, {} ], \u0026#34;exclude\u0026#34;: [ {} ] }, \u0026#34;track\u0026#34;: { \u0026#34;mode\u0026#34;: 0, \u0026#34;delay\u0026#34;: 300, \u0026#34;paths\u0026#34;: [] }, \u0026#34;slU\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;dump\u0026#34;: 1, \u0026#34;rpU\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;ic\u0026#34;: 8.5 } }, {}, \u0026#34;dhzx\u0026#34;, 1763021788706, 5, { \u0026#34;name\u0026#34;: \u0026#34;Chrome\u0026#34; }, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], { \u0026#34;0\u0026#34;: 1, \u0026#34;1\u0026#34;: 0, \u0026#34;2\u0026#34;: 8, \u0026#34;3\u0026#34;: \u0026#34;device_platform=webapp\u0026amp;aid=6383\u0026amp;channel=channel_pc_web\u0026amp;sec_user_id=MS4wLjABAAAAofq0Vvn8ISgdgZ-eX4lgGoJb1BQDtjB3K7I8XzjTfW3hMgZ9gaaJnYy-Er1k5QRi\u0026amp;max_cursor=0\u0026amp;locate_query=false\u0026amp;show_live_replay_strategy=1\u0026amp;need_time_list=1\u0026amp;time_list_query=0\u0026amp;whale_cut_token=\u0026amp;cut_version=1\u0026amp;count=18\u0026amp;publish_video_strategy_type=2\u0026amp;from_user_page=1\u0026amp;update_version_code=170400\u0026amp;pc_client_type=1\u0026amp;pc_libra_divert=Mac\u0026amp;support_h265=1\u0026amp;support_dash=1\u0026amp;cpu_core_num=10\u0026amp;version_code=290100\u0026amp;version_name=29.1.0\u0026amp;cookie_enabled=true\u0026amp;screen_width=1512\u0026amp;screen_height=982\u0026amp;browser_language=zh-CN\u0026amp;browser_platform=MacIntel\u0026amp;browser_name=Chrome\u0026amp;browser_version=142.0.0.0\u0026amp;browser_online=true\u0026amp;engine_name=Blink\u0026amp;engine_version=142.0.0.0\u0026amp;os_name=Mac+OS\u0026amp;os_version=10.15.7\u0026amp;device_memory=8\u0026amp;platform=PC\u0026amp;downlink=10\u0026amp;effective_type=4g\u0026amp;round_trip_time=50\u0026amp;webid=7537255736499029513\u0026amp;uifid=ecb38e5e86f1f8799c3256ca6c3446710d152cd7b76a2f92ca888d379e861b9ef6c3c057199fbabeb251493a65cd070d26b3aeca82ccc95af03dc3a8930e7db657234d4ca4acb8174f8b9e3cab43ff6260ae432fd24dfe6de26ecc544bf0426c0fb819444e48099c31f99143dab6d5c48975b8b37a257b159ef2fe6dacc5252904813ff4b25bebd8458d1565ef36ce45b9144f443029919505f73dca564bcd4a\u0026amp;msToken=_ldHApyvIwdTTeKAtEdJ420xs1ltIcgsNMzR0bX8PJ5sv86p7ORbTipL0ylgxU3ZmrrxoR-Rv6qwyig0-yZPE26FFFIFwRgTGONu1NN5FlswqC5B2WRWvp3ESGTQNFgQOgIor-bnh8BYHfUnAyQGwl_VuKgrY2s_WeRVHHN4nLRd1nxcNjjF-A%3D%3D\u0026#34;, \u0026#34;4\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;5\u0026#34;: \u0026#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36\u0026#34;, \u0026#34;6\u0026#34;: 6241, \u0026#34;7\u0026#34;: 6383, \u0026#34;8\u0026#34;: \u0026#34;1.0.1.19-fix.01\u0026#34; }, 1, 0, 8, \u0026#34;device_platform=webapp\u0026amp;aid=6383\u0026amp;channel=channel_pc_web\u0026amp;sec_user_id=MS4wLjABAAAAofq0Vvn8ISgdgZ-eX4lgGoJb1BQDtjB3K7I8XzjTfW3hMgZ9gaaJnYy-Er1k5QRi\u0026amp;max_cursor=0\u0026amp;locate_query=false\u0026amp;show_live_replay_strategy=1\u0026amp;need_time_list=1\u0026amp;time_list_query=0\u0026amp;whale_cut_token=\u0026amp;cut_version=1\u0026amp;count=18\u0026amp;publish_video_strategy_type=2\u0026amp;from_user_page=1\u0026amp;update_version_code=170400\u0026amp;pc_client_type=1\u0026amp;pc_libra_divert=Mac\u0026amp;support_h265=1\u0026amp;support_dash=1\u0026amp;cpu_core_num=10\u0026amp;version_code=290100\u0026amp;version_name=29.1.0\u0026amp;cookie_enabled=true\u0026amp;screen_width=1512\u0026amp;screen_height=982\u0026amp;browser_language=zh-CN\u0026amp;browser_platform=MacIntel\u0026amp;browser_name=Chrome\u0026amp;browser_version=142.0.0.0\u0026amp;browser_online=true\u0026amp;engine_name=Blink\u0026amp;engine_version=142.0.0.0\u0026amp;os_name=Mac+OS\u0026amp;os_version=10.15.7\u0026amp;device_memory=8\u0026amp;platform=PC\u0026amp;downlink=10\u0026amp;effective_type=4g\u0026amp;round_trip_time=50\u0026amp;webid=7537255736499029513\u0026amp;uifid=ecb38e5e86f1f8799c3256ca6c3446710d152cd7b76a2f92ca888d379e861b9ef6c3c057199fbabeb251493a65cd070d26b3aeca82ccc95af03dc3a8930e7db657234d4ca4acb8174f8b9e3cab43ff6260ae432fd24dfe6de26ecc544bf0426c0fb819444e48099c31f99143dab6d5c48975b8b37a257b159ef2fe6dacc5252904813ff4b25bebd8458d1565ef36ce45b9144f443029919505f73dca564bcd4a\u0026amp;msToken=_ldHApyvIwdTTeKAtEdJ420xs1ltIcgsNMzR0bX8PJ5sv86p7ORbTipL0ylgxU3ZmrrxoR-Rv6qwyig0-yZPE26FFFIFwRgTGONu1NN5FlswqC5B2WRWvp3ESGTQNFgQOgIor-bnh8BYHfUnAyQGwl_VuKgrY2s_WeRVHHN4nLRd1nxcNjjF-A%3D%3D\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36\u0026#34;, 6241, 6383, \u0026#34;1.0.1.19-fix.01\u0026#34;, { \u0026#34;ink\u0026#34;: 1763021788706 }, 3, { \u0026#34;value\u0026#34;: \u0026#34;0X21\u0026#34;, \u0026#34;writable\u0026#34;: 0, \u0026#34;enumerable\u0026#34;: 1, \u0026#34;configurable\u0026#34;: 1 }, 1763021788708, { \u0026#34;reg\u0026#34;: [ 1937774191, 1226093241, 388252375, 3666478592, 2842636476, 372324522, 3817729613, 2969243214 ], \u0026#34;chunk\u0026#34;: [], \u0026#34;size\u0026#34;: 0 }, 1, 14, [ 75, 88, 25, 204, 46, 136, 235, 122, 51, 23, 207, 160, 3, 48, 143, 135, 1, 25, 54, 194, 0, 108, 224, 238, 26, 252, 36, 188, 147, 131, 240, 57 ], [ 64, 253, 156, 240, 44, 96, 159, 150, 27, 122, 82, 52, 197, 120, 234, 119, 245, 89, 71, 177, 99, 98, 28, 142, 5, 99, 123, 199, 176, 9, 152, 240 ], \u0026#34;eWgvhqF7obsvc6EpmziycV7XL8a0cgI1T8jgTKeNbjPeaKF1gvtiAPTEZavZAo08AIP6CdZALC6EbNqevfpUebcct0j7VPPDkRfsBmBXxwdsjBBMnjZ8biljt0Eg1OEzGvPt3LjptJUTYvu+JLsMBZ6mXcXV\u0026#34;, [ 34, 2, 135, 211, 192, 208, 65, 120, 79, 137, 215, 252, 68, 7, 137, 60, 10, 133, 247, 147, 234, 206, 193, 40, 81, 115, 135, 232, 128, 141, 33, 199 ], 1763021788706, [ 3, 82 ], 41, [ 1, 0, 1, 0, 1 ], 34, 6, 5, 36, 150, 73, 124, 154, 1, 1, 0, [ 0, 0, 0, 0, 1 ], 1, 0, 0, 0, 0, 0, 14, 0, 0, 0, 23, 54, 3, 204, 82, 177, 4, 44, 252, 206, 5, 208, 34, 150, 73, 124, 154, 1, 3, 97, 24, 0, 0, 239, 24, 0, 0, { \u0026#34;innerWidth\u0026#34;: 1512, \u0026#34;innerHeight\u0026#34;: 772, \u0026#34;outerWidth\u0026#34;: 1512, \u0026#34;outerHeight\u0026#34;: 893, \u0026#34;availWidth\u0026#34;: 1512, \u0026#34;availHeight\u0026#34;: 893, \u0026#34;sizeWidth\u0026#34;: 1512, \u0026#34;sizeHeight\u0026#34;: 982, \u0026#34;platform\u0026#34;: \u0026#34;MacIntel\u0026#34; }, \u0026#34;1512|772|1512|893|1512|893|1512|982|MacIntel\u0026#34;, [ 49, 53, 49, 50, 124, 55, 55, 50, 124, 49, 53, 49, 50, 124, 56, 57, 51, 124, 49, 53, 49, 50, 124, 56, 57, 51, 124, 49, 53, 49, 50, 124, 57, 56, 50, 124, 77, 97, 99, 73, 110, 116, 101, 108 ], 44, 44, 0, \u0026#34;39,\u0026#34;, [ 51, 57, 44 ], 3, 3, 0, [ 169, 21, 136, 81, 137, 81, 162, 21 ], 104, [ 1, 14, 252, 150, 0, 36, 0, 0, 1, 54, 1, 3, 204, 24, 5, 23, 154, 0, 150, 239, 34, 44, 73, 0, 208, 0, 73, 124, 6, 24, 0, 0, 206, 82, 0, 0, 154, 97, 177, 0, 1, 0, 0, 41, 34, 124, 44, 0, 3, 0, 49, 53, 49, 50, 124, 55, 55, 50, 124, 49, 53, 49, 50, 124, 56, 57, 51, 124, 49, 53, 49, 50, 124, 56, 57, 51, 124, 49, 53, 49, 50, 124, 57, 56, 50, 124, 77, 97, 99, 73, 110, 116, 101, 108, 51, 57, 44, 104 ], \u0026#34;\\u000b\\u0003r\\u0007\u0026#34;, [ 128, 12, 216, 47, 150, 2, 40, 180, 0, 0, 9, 0, 55, 3, 7, 16, 220, 90, 1, 132, 150, 216, 40, 19, 134, 173, 42, 242, 44, 11, 40, 64, 208, 0, 97, 152, 236, 70, 28, 26, 128, 0, 194, 12, 67, 0, 36, 16, 155, 33, 145, 240, 1, 3, 40, 0, 129, 107, 38, 32, 108, 44, 32, 16, 2, 66, 21, 33, 164, 51, 62, 49, 237, 55, 63, 54, 50, 126, 29, 112, 165, 115, 50, 49, 252, 120, 49, 56, 51, 124, 29, 113, 53, 51, 26, 49, 124, 122, 29, 56, 178, 60, 21, 113, 37, 115, 50, 49, 236, 121, 20, 56, 35, 62, 65, 92, 113, 99, 69, 75, 239, 54, 97, 100, 253, 115, 25, 42, 44, 104 ], \u0026#34;Õ5¨6°ø+¸¢¬¦ÿTëÉ\\u001f4#øFbÏëÔ®\\u0019¨sêaÊ.\u0026gt;(Ê) fL4\\u0017åä·\\u000fÞ \\u0004º·×e\\u001f|Á´Ñ°pPÔ¶HÕf\\u0016xEåÚH0*üÑm¾Ro6em¯ö\\u0018pã\\u0019(Zv¨pµûýªvi¤\\u0002s1ð\\u0000yvÞ\\u0007\\u0015\\u0003Ã\\u0001\\u0017dé«`C­Bgs\u0026#34;, \u0026#34;\\u000b\\u0003r\\u0007Õ5¨6°ø+¸¢¬¦ÿTëÉ\\u001f4#øFbÏëÔ®\\u0019¨sêaÊ.\u0026gt;(Ê) fL4\\u0017åä·\\u000fÞ \\u0004º·×e\\u001f|Á´Ñ°pPÔ¶HÕf\\u0016xEåÚH0*üÑm¾Ro6em¯ö\\u0018pã\\u0019(Zv¨pµûýªvi¤\\u0002s1ð\\u0000yvÞ\\u0007\\u0015\\u0003Ã\\u0001\\u0017dé«`C­Bgs\u0026#34;, \u0026#34;dj0nkt67Op5jCdKbYOnoe7VlcSLlNT8ymei2RueP7Qb4OZMORRNQBNbYnxoE4LjyhbpwiCVHLEeAYDVcztUwZHrkzmpvuZkfqtV9V0XohqihGUTmErDOe0hzFwsF0Yiw-5CWNlRRWsBN2VxAIq5YWB1ae5T955fdWrZjDZw9HEWXDS8kh93TO9kpP6sqWj==\u0026#34; ] key = [] key = w_8 for i in range(len(w)): key.append(table_gobal[w[i]]) s = key[0] for i in range(1, len(key)): s = s ^ key[i] print(\u0026#34;s:\u0026#34;, s) 可以对应上\n同理上面如果继续看的还会看到一个表\n[34, 44, 56, 61, 73, 29, 70, 45, 35, 49, 38, 66, 51, 68, 28, 48, 64, 47, 30, 71, 26, 55, 31, 69, 59, 40, 62, 63, 27, 72, 41, 74, 57, 52, 42, 39, 33, 67, 53, 43, 65, 46, 36, 24, 60, 32, 79, 80, 84, 85] 这个就是50位生成的地方，可以看到可以很完美的对应上\n继续向上看的话，可以看一个新的值\n这个位置对应了刚才分析到拿出来参数的这个位置\n可以很好的看出来这是一个sm3加密算法\n这个位置和js的某一个地方的源码一样，key = sum\n那么参数应该就是那个加密后的base64字符串\ndef sm3_hex(s: str) -\u0026gt; str: def rol(x, n): return ((x \u0026lt;\u0026lt; n) | (x \u0026gt;\u0026gt; (32 - n))) \u0026amp; 0xFFFFFFFF def P0(x): return x ^ rol(x, 9) ^ rol(x, 17) def P1(x): return x ^ rol(x, 15) ^ rol(x, 23) V = [ 0x7380166F, 0x4914B2B9, 0x172442D7, 0xDA8A0600, 0xA96F30BC, 0x163138AA, 0xE38DEE4D, 0xB0FB0E4E, ] m = bytearray(s.encode(\u0026#34;utf-8\u0026#34;)) bitlen = (len(m) * 8) \u0026amp; ((1 \u0026lt;\u0026lt; 64) - 1) m.append(0x80) while (len(m) + 8) % 64 != 0: m.append(0x00) m += bitlen.to_bytes(8, \u0026#34;big\u0026#34;) for off in range(0, len(m), 64): B = m[off:off+64] W = [int.from_bytes(B[i*4:i*4+4], \u0026#34;big\u0026#34;) for i in range(16)] + [0]*52 for i in range(16, 68): W[i] = (P1(W[i-16] ^ W[i-9] ^ rol(W[i-3], 15)) ^ rol(W[i-13], 7) ^ W[i-6]) \u0026amp; 0xFFFFFFFF W1 = [(W[i] ^ W[i+4]) \u0026amp; 0xFFFFFFFF for i in range(64)] A,Bb,C,D,E,F,G,H = V for j in range(64): T = 0x79CC4519 if j \u0026lt;= 15 else 0x7A879D8A SS1 = rol((rol(A,12) + E + rol(T, j \u0026amp; 31)) \u0026amp; 0xFFFFFFFF, 7) SS2 = SS1 ^ rol(A,12) FF = (A ^ Bb ^ C) if j \u0026lt;= 15 else ((A \u0026amp; Bb) | (A \u0026amp; C) | (Bb \u0026amp; C)) GG = (E ^ F ^ G) if j \u0026lt;= 15 else ((E \u0026amp; F) | ((~E) \u0026amp; G)) TT1 = (FF + D + SS2 + W1[j]) \u0026amp; 0xFFFFFFFF TT2 = (GG + H + SS1 + W[j]) \u0026amp; 0xFFFFFFFF D, C, Bb, A = C, rol(Bb, 9), A, TT1 H, G, F, E = G, rol(F, 19), E, P0(TT2) V = [(V[0]^A)\u0026amp;0xFFFFFFFF, (V[1]^Bb)\u0026amp;0xFFFFFFFF, (V[2]^C)\u0026amp;0xFFFFFFFF, (V[3]^D)\u0026amp;0xFFFFFFFF, (V[4]^E)\u0026amp;0xFFFFFFFF, (V[5]^F)\u0026amp;0xFFFFFFFF, (V[6]^G)\u0026amp;0xFFFFFFFF, (V[7]^H)\u0026amp;0xFFFFFFFF] return \u0026#34;\u0026#34;.join(f\u0026#34;{x:08x}\u0026#34; for x in V) if __name__ == \u0026#34;__main__\u0026#34;: s = \u0026#34;eWgvhqF7obsvc6EpmziycV7XL8a0cgI1T8jgTKeNbjPeaKF1gvtiAPTEZavZAo08AIP6CdZALC6EbNqevfpUebcct0j7VPPDkRfsBmBXxwdsjBBMnjZ8biljt0Eg1OEzGvPt3LjptJUTYvu+JLsMBZ6mXcXV\u0026#34; dec_s = sm3_hex(s) print(\u0026#34;SM3 Hash:\u0026#34;, dec_s) print(\u0026#34;values:\u0026#34;, \u0026#34; \u0026#34;.join(str(int(dec_s[i:i+2], 16)) for i in range(0, len(dec_s), 2))) 34 2 135 211 192 208 65 120 79 137 215 252 68 7 137 60 10 133 247 147 234 206 193 40 81 115 135 232 128 141 33 199 和加密位置吻合\n这上面生成的还是之前那个base64变表，只是table换成了：ckdp1h4ZKsUB80/Mfvw36XIgR25+WQAlEi7NLboqYTOPuzmFjJnryx9HVGDaStCe\n再往上看就是rc4的变种\n不过很奇怪，这个console的问题复制的变化后的表，不过可以通过输入和输出反推s盒\ndef rc4_reverse_initial_s(plaintext: bytes, ciphertext: list[int], s_final: list[int]) -\u0026gt; list[int]: assert len(plaintext) == len(ciphertext) K = [p ^ c for p, c in zip(plaintext, ciphertext)] N = len(K) S = s_final.copy() for r in range(N, 0, -1): i = r \u0026amp; 0xFF kbyte = K[r-1] q = S.index(kbyte) val = (q - S[i]) \u0026amp; 0xFF j = S.index(val) S[i], S[j] = S[j], S[i] return S p = b\u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36\u0026#34; c = [140,165,135,67,153,198,40,136,15,88,221,45,145,102,31,34,14,215,234,84,3,223,159,233, 21,43,30,231,92,190,76,138,7,196,171,154,89,46,118,89,242,253,199,34,54,46,101,113, 255,123,71,91,175,154,109,84,114,32,41,141,138,157,195,176,120,7,236,228,14,186,87, 175,153,105,244,128,158,187,60,242,102,168,43,233,122,180,166,124,195,121,110,230, 176,224,84,14,205,14,120,149,190,185,143,127,188,19,174,63,202,187,28] s_final = [110,11,105,14,79,174,199,147,251,20,88,215,152,179,85,128,74,18,80,163,155,195,197,176,246,145,208,172,144,114,48,148,16,90,180,118,154,96,245,139,34,84,162,229,39,193,243,108,240,42,0,9,221,87,106,70,81,29,31,189,102,164,55,219,157,64,30,38,109,196,142,183,236,217,228,115,224,182,177,123,86,125,213,140,233,175,36,51,111,22,10,250,78,222,7,127,46,137,171,104,97,158,43,225,204,3,93,166,146,67,178,63,198,89,57,23,254,242,239,207,192,150,45,44,40,59,17,65,237,223,132,37,253,50,238,188,21,100,230,226,200,27,28,248,99,116,13,247,165,1,210,249,131,206,107,138,161,191,168,26,141,194,186,143,4,72,202,68,135,56,83,218,98,190,117,227,15,201,12,173,235,205,69,77,120,209,61,129,231,181,241,60,41,66,214,119,94,8,71,82,76,62,6,75,167,112,25,95,156,19,160,151,159,122,47,136,134,24,203,73,92,58,121,113,187,32,211,153,101,126,54,130,252,91,220,35,234,2,149,52,232,216,5,244,124,184,169,33,170,255,49,103,53,133,185,212] s_initial = rc4_reverse_initial_s(p, c, s_final) print(s_initial) [110, 89, 245, 118, 200, 160, 49, 72, 67, 201, 108, 116, 250, 208, 8, 68, 126, 125, 165, 214, 55, 40, 217, 42, 66, 221, 189, 22, 123, 88, 122, 249, 159, 204, 198, 94, 163, 74, 105, 242, 87, 172, 252, 243, 174, 146, 206, 225, 43, 65, 229, 169, 168, 148, 248, 196, 247, 153, 150, 226, 48, 84, 240, 162, 139, 59, 157, 164, 31, 129, 52, 80, 103, 161, 81, 237, 75, 0, 177, 234, 219, 186, 223, 70, 155, 197, 37, 180, 246, 11, 56, 46, 62, 199, 86, 10, 179, 251, 181, 85, 193, 83, 97, 166, 141, 4, 230, 154, 51, 7, 36, 30, 233, 38, 57, 23, 254, 63, 239, 207, 192, 109, 45, 44, 195, 64, 17, 176, 115, 213, 132, 178, 253, 50, 238, 188, 21, 100, 93, 152, 79, 27, 28, 106, 99, 215, 13, 228, 183, 1, 210, 34, 131, 182, 107, 138, 175, 191, 145, 26, 90, 194, 18, 143, 3, 147, 202, 128, 135, 127, 158, 218, 98, 190, 117, 227, 15, 20, 12, 173, 235, 205, 69, 77, 120, 209, 61, 140, 231, 171, 241, 60, 41, 111, 114, 119, 14, 104, 71, 82, 76, 78, 6, 224, 167, 112, 25, 95, 156, 19, 39, 151, 16, 102, 47, 136, 134, 24, 203, 73, 92, 58, 121, 113, 187, 32, 211, 29, 101, 96, 54, 130, 137, 91, 220, 35, 144, 2, 149, 142, 232, 216, 5, 244, 124, 184, 9, 33, 170, 255, 222, 236, 53, 133, 185, 212] 加密逻辑：\nimport random BASE_TABLE = \u0026#34;ckdp1h4ZKsUB80/Mfvw36XIgR25+WQAlEi7NLboqYTOPuzmFjJnryx9HVGDaStCe\u0026#34; def b64_swap_decode(s: str, alphabet: str = BASE_TABLE) -\u0026gt; bytes: table = {ch: i for i, ch in enumerate(alphabet)} s = s.strip() if len(s) % 4: s += \u0026#34;=\u0026#34; * ((4 - len(s) % 4) % 4) out = bytearray() for i in range(0, len(s), 4): block = s[i:i+4] pad = block.count(\u0026#34;=\u0026#34;) vals = [] for ch in block: if ch == \u0026#34;=\u0026#34;: vals.append(0) else: if ch not in table: raise ValueError(f\u0026#34;字母表中不存在字符: {repr(ch)}\u0026#34;) vals.append(table[ch]) v = (vals[0] \u0026lt;\u0026lt; 18) | (vals[1] \u0026lt;\u0026lt; 12) | (vals[2] \u0026lt;\u0026lt; 6) | vals[3] out.append((v \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) if pad \u0026lt; 2: out.append((v \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) if pad \u0026lt; 1: out.append(v \u0026amp; 0xFF) return bytes(out) def b64_swap_encode(b: bytes, alphabet: str = BASE_TABLE) -\u0026gt; str: res = [] for i in range(0, len(b), 3): chunk = b[i:i+3] pad = 3 - len(chunk) if pad: chunk = chunk + b\u0026#34;\\x00\u0026#34; * pad val = (chunk[0] \u0026lt;\u0026lt; 16) | (chunk[1] \u0026lt;\u0026lt; 8) | chunk[2] res.append(alphabet[(val \u0026gt;\u0026gt; 18) \u0026amp; 0x3F]) res.append(alphabet[(val \u0026gt;\u0026gt; 12) \u0026amp; 0x3F]) res.append(\u0026#34;=\u0026#34; if pad == 2 else alphabet[(val \u0026gt;\u0026gt; 6) \u0026amp; 0x3F]) res.append(\u0026#34;=\u0026#34; if pad \u0026gt;= 1 else alphabet[val \u0026amp; 0x3F]) return \u0026#34;\u0026#34;.join(res) def sm3_hex(s: str) -\u0026gt; str: def rol(x, n): return ((x \u0026lt;\u0026lt; n) | (x \u0026gt;\u0026gt; (32 - n))) \u0026amp; 0xFFFFFFFF def P0(x): return x ^ rol(x, 9) ^ rol(x, 17) def P1(x): return x ^ rol(x, 15) ^ rol(x, 23) V = [ 0x7380166F, 0x4914B2B9, 0x172442D7, 0xDA8A0600, 0xA96F30BC, 0x163138AA, 0xE38DEE4D, 0xB0FB0E4E, ] m = bytearray(s.encode(\u0026#34;utf-8\u0026#34;)) bitlen = (len(m) * 8) \u0026amp; ((1 \u0026lt;\u0026lt; 64) - 1) m.append(0x80) while (len(m) + 8) % 64 != 0: m.append(0x00) m += bitlen.to_bytes(8, \u0026#34;big\u0026#34;) for off in range(0, len(m), 64): B = m[off:off+64] W = [int.from_bytes(B[i*4:i*4+4], \u0026#34;big\u0026#34;) for i in range(16)] + [0]*52 for i in range(16, 68): W[i] = (P1(W[i-16] ^ W[i-9] ^ rol(W[i-3], 15)) ^ rol(W[i-13], 7) ^ W[i-6]) \u0026amp; 0xFFFFFFFF W1 = [(W[i] ^ W[i+4]) \u0026amp; 0xFFFFFFFF for i in range(64)] A,Bb,C,D,E,F,G,H = V for j in range(64): T = 0x79CC4519 if j \u0026lt;= 15 else 0x7A879D8A SS1 = rol((rol(A,12) + E + rol(T, j \u0026amp; 31)) \u0026amp; 0xFFFFFFFF, 7) SS2 = SS1 ^ rol(A,12) FF = (A ^ Bb ^ C) if j \u0026lt;= 15 else ((A \u0026amp; Bb) | (A \u0026amp; C) | (Bb \u0026amp; C)) GG = (E ^ F ^ G) if j \u0026lt;= 15 else ((E \u0026amp; F) | ((~E) \u0026amp; G)) TT1 = (FF + D + SS2 + W1[j]) \u0026amp; 0xFFFFFFFF TT2 = (GG + H + SS1 + W[j]) \u0026amp; 0xFFFFFFFF D, C, Bb, A = C, rol(Bb, 9), A, TT1 H, G, F, E = G, rol(F, 19), E, P0(TT2) V = [(V[0]^A)\u0026amp;0xFFFFFFFF, (V[1]^Bb)\u0026amp;0xFFFFFFFF, (V[2]^C)\u0026amp;0xFFFFFFFF, (V[3]^D)\u0026amp;0xFFFFFFFF, (V[4]^E)\u0026amp;0xFFFFFFFF, (V[5]^F)\u0026amp;0xFFFFFFFF, (V[6]^G)\u0026amp;0xFFFFFFFF, (V[7]^H)\u0026amp;0xFFFFFFFF] return \u0026#34;\u0026#34;.join(f\u0026#34;{x:08x}\u0026#34; for x in V) def rc4_2(data: bytes) -\u0026gt; bytes: table = [110,89,245,118,200,160,49,72,67,201,108,116,250,208,8,68,126,125,165,214,55,40,217,42,66,221,189,22,123,88,122,249,159,204,198,94,163,74,105,242,87,172,252,243,174,146,206,225,43,65,229,169,168,148,248,196,247,153,150,226,48,84,240,162,139,59,157,164,31,129,52,80,103,161,81,237,75,0,177,234,219,186,223,70,155,197,37,180,246,11,56,46,62,199,86,10,179,251,181,85,193,83,97,166,141,4,230,154,51,7,36,30,233,38,57,23,254,63,239,207,192,109,45,44,195,64,17,176,115,213,132,178,253,50,238,188,21,100,93,152,79,27,28,106,99,215,13,228,183,1,210,34,131,182,107,138,175,191,145,26,90,194,18,143,3,147,202,128,135,127,158,218,98,190,117,227,15,20,12,173,235,205,69,77,120,209,61,140,231,171,241,60,41,111,114,119,14,104,71,82,76,78,6,224,167,112,25,95,156,19,39,151,16,102,47,136,134,24,203,73,92,58,121,113,187,32,211,29,101,96,54,130,137,91,220,35,144,2,149,142,232,216,5,244,124,184,9,33,170,255,222,236,53,133,185,212] out = bytearray() i = 0 j = 0 for b in data: i = (i + 1) % 256 j = (j + table[i]) % 256 table[i], table[j] = table[j], table[i] K = table[(table[i] + table[j]) % 256] out.append(b ^ K) return bytes(out) if __name__ == \u0026#34;__main__\u0026#34;: data = \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36\u0026#34; rc4_encoded = rc4_2(data.encode(\u0026#34;utf-8\u0026#34;)) print(\u0026#34;RC4 Encoded bytes:\u0026#34;, rc4_encoded) decoded_data = b64_swap_encode(rc4_encoded) print(\u0026#34;Encoded string:\u0026#34;, decoded_data) sm3_data = sm3_hex(decoded_data) print(\u0026#34;SM3 Hash:\u0026#34;, sm3_data) print(\u0026#34;SM3 Decimal values:\u0026#34;, \u0026#34; \u0026#34;.join(str(int(sm3_data[i:i+2], 16)) for i in range(0, len(sm3_data), 2))) 这里是UA进行加密\n再刷新一下，发现这个rc4的表是会变的，那就说明这个表的key是每一次不一样的，看一下为什么\n这里应该是索引：[0.00390625, 1, 14]\n这个第一个应该是固定的，可以很明显的看出来是1/256 = 0.00390625\ndef rc4_2(data: bytes) -\u0026gt; bytes: r = [] k = 0 y = [0, 1, 14] for i in range(255, -1, -1): r.append(i) for i in range(len(r)): a = r[i] k = (k * a + k + y[i % 3]) % 256 b = r[k] r[i], r[k] = b, a table = r out = bytearray() i = 0 j = 0 for b in data: i = (i + 1) % 256 j = (j + table[i]) % 256 table[i], table[j] = table[j], table[i] K = table[(table[i] + table[j]) % 256] out.append(b ^ K) return bytes(out) 这样表就可以生成了\n后面就没可以逆的算法了，都是sm3，请求参数拼接一个dhzx进行两次sm3，再对dhzx单独做两次sm3\n修改sm3函数\ndef enc_sum(n_str: str, as_hex: bool = False): def rotl(x, n): n \u0026amp;= 31 return ((x \u0026lt;\u0026lt; n) | (x \u0026gt;\u0026gt; (32 - n))) \u0026amp; 0xffffffff def Tj(j): if 0 \u0026lt;= j \u0026lt; 16: return 0x79cc4519 # 2043430169 elif 16 \u0026lt;= j \u0026lt; 64: return 0x7a879d8a # 2055708042 else: raise ValueError(\u0026#34;invalid j for Tj\u0026#34;) def FF(j, x, y, z): if 0 \u0026lt;= j \u0026lt; 16: return (x ^ y ^ z) \u0026amp; 0xffffffff elif 16 \u0026lt;= j \u0026lt; 64: return ((x \u0026amp; y) | (x \u0026amp; z) | (y \u0026amp; z)) \u0026amp; 0xffffffff else: raise ValueError(\u0026#34;invalid j for FF\u0026#34;) def GG(j, x, y, z): if 0 \u0026lt;= j \u0026lt; 16: return (x ^ y ^ z) \u0026amp; 0xffffffff elif 16 \u0026lt;= j \u0026lt; 64: return ((x \u0026amp; y) | (~x \u0026amp; z)) \u0026amp; 0xffffffff else: raise ValueError(\u0026#34;invalid j for GG\u0026#34;) class SM3: def __init__(self): self.reg = [0] * 8 self.chunk = bytearray() self.size = 0 self.reset() def reset(self): self.reg[0] = 0x7380166f # 1937774191 self.reg[1] = 0x4914b2b9 # 1226093241 self.reg[2] = 0x172442d7 # 388252375 self.reg[3] = 0xda8a0600 # 3666478592 self.reg[4] = 0xa96f30bc # 2842636476 self.reg[5] = 0x163138aa # 372324522 self.reg[6] = 0xe38dee4d # 3817729613 self.reg[7] = 0xb0fb0e4e # 2969243214 self.chunk = bytearray() self.size = 0 def write(self, data): if isinstance(data, str): bs = data.encode(\u0026#34;utf-8\u0026#34;) elif isinstance(data, (bytes, bytearray)): bs = bytes(data) else: bs = bytes(int(b) \u0026amp; 0xff for b in data) self.size += len(bs) self.chunk.extend(bs) while len(self.chunk) \u0026gt;= 64: block = self.chunk[:64] self._compress(block) self.chunk = self.chunk[64:] def _compress(self, block: bytes): if len(block) \u0026lt; 64: raise ValueError(\u0026#34;compress error: not enough data\u0026#34;) W = [0] * 132 for i in range(16): W[i] = ( (block[4 * i] \u0026lt;\u0026lt; 24) | (block[4 * i + 1] \u0026lt;\u0026lt; 16) | (block[4 * i + 2] \u0026lt;\u0026lt; 8) | (block[4 * i + 3]) ) \u0026amp; 0xffffffff for i in range(16, 68): tmp = W[i - 16] ^ W[i - 9] ^ rotl(W[i - 3], 15) tmp = tmp ^ rotl(tmp, 15) ^ rotl(tmp, 23) W[i] = (tmp ^ rotl(W[i - 13], 7) ^ W[i - 6]) \u0026amp; 0xffffffff for i in range(64): W[i + 68] = (W[i] ^ W[i + 4]) \u0026amp; 0xffffffff a, b, c, d, e, f, g, h = self.reg for j in range(64): ss1 = (rotl(a, 12) + e + rotl(Tj(j), j)) \u0026amp; 0xffffffff ss1 = rotl(ss1 \u0026amp; 0xffffffff, 7) ss2 = ss1 ^ rotl(a, 12) tt1 = (FF(j, a, b, c) + d + ss2 + W[j + 68]) \u0026amp; 0xffffffff tt2 = (GG(j, e, f, g) + h + ss1 + W[j]) \u0026amp; 0xffffffff d = c c = rotl(b, 9) b = a a = tt1 \u0026amp; 0xffffffff h = g g = rotl(f, 19) f = e e = (tt2 ^ rotl(tt2, 9) ^ rotl(tt2, 17)) \u0026amp; 0xffffffff self.reg = [ (self.reg[0] ^ a) \u0026amp; 0xffffffff, (self.reg[1] ^ b) \u0026amp; 0xffffffff, (self.reg[2] ^ c) \u0026amp; 0xffffffff, (self.reg[3] ^ d) \u0026amp; 0xffffffff, (self.reg[4] ^ e) \u0026amp; 0xffffffff, (self.reg[5] ^ f) \u0026amp; 0xffffffff, (self.reg[6] ^ g) \u0026amp; 0xffffffff, (self.reg[7] ^ h) \u0026amp; 0xffffffff, ] def _fill(self): t = self.size * 8 self.chunk.append(0x80) while (len(self.chunk) % 64) != 56: self.chunk.append(0) high = (t \u0026gt;\u0026gt; 32) \u0026amp; 0xffffffff low = t \u0026amp; 0xffffffff for e in range(4): self.chunk.append((high \u0026gt;\u0026gt; (8 * (3 - e))) \u0026amp; 0xff) for e in range(4): self.chunk.append((low \u0026gt;\u0026gt; (8 * (3 - e))) \u0026amp; 0xff) def sum(self, data=None, mode=None): if data is not None: self.reset() self.write(data) self._fill() for i in range(0, len(self.chunk), 64): self._compress(self.chunk[i:i + 64]) if mode == \u0026#34;hex\u0026#34;: out = \u0026#34;\u0026#34;.join(f\u0026#34;{x:08x}\u0026#34; for x in self.reg) else: out = [] for x in self.reg: out.extend([ (x \u0026gt;\u0026gt; 24) \u0026amp; 0xff, (x \u0026gt;\u0026gt; 16) \u0026amp; 0xff, (x \u0026gt;\u0026gt; 8) \u0026amp; 0xff, x \u0026amp; 0xff, ]) self.reset() return out sm3 = SM3() if as_hex: return sm3.sum(n_str, mode=\u0026#34;hex\u0026#34;) else: return sm3.sum(n_str) 测试解密均可以\n后续再整理，以上是整个过程中自己的所有思路，很乱！仅供参考\n","permalink":"https://l0x1c.com/posts/dy_web_a_bogus/","summary":"关于dy的a_bogus逆向，jsvmp\n进行抖音抓包，对应的位置在\nurl = \u0026#34;https://www.douyin.com/aweme/v1/web/aweme/post/\u0026#34; 可以看一下调用栈，不难发现主要的逻辑在bdms_1.0.1.19_fix.js\n直接跳过去可以看到d就是指令操作\n先一点一点的去看\n这个位置调用了atob，代表了对下面的那个字符进行了base64的解密，随后取第 4~7 字节求和得到单字节 key\n再用自定义 map 函数 _ 对余下字节逐个异或，最后把结果送进自带的 DEFLATE 解压器，从而得到可执行的数据块，这里可以很好的看出来这一块是一个压缩文件的格式，对应base64的UEsC\nimport base64, zlib, re, hashlib, os, sys from pathlib import Path BASE64_DATA = r\u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;.strip() # ============================================== def sanitize_b64(s: str) -\u0026gt; str: return re.sub(r\u0026#39;[^A-Za-z0-9+/=]\u0026#39;, \u0026#39;\u0026#39;, s) def xor_transform(decoded: bytes) -\u0026gt; tuple[bytes, int, int]: key_sum = sum(decoded[4:8]) \u0026amp; 0xFFFFFFFF km = key_sum % 256 step = km % 10 tail = decoded[8:] out = bytearray(len(tail)) for i, b in enumerate(tail): out[i] = (b ^ ((km + step * i) % 256)) \u0026amp; 0xFF return bytes(out), key_sum, km def inflate_raw(data: bytes) -\u0026gt; bytes: return zlib.","title":"dy a_bogus参数 逆向分析"},{"content":"这个是工作中遇见的一个app，需要分析一下app对于应用列表检测感知这个问题\n对应的样本的网址：https://github.com/TMLP-Team/TMLP-Detectors-and-Bypassers/blob/main/Detectors/%E5%87%8C%E5%8D%BF%E6%A3%80%E6%B5%8B_v1.6_fix.apk\n直接拖进jeb看一下\n调用lua，看一下lingqing.bin\nLua 介绍 C 语言和 Lua 的交互是通过 lua_State来实现的，所以首先需要创建一个 lua_State\n把 Lua 脚本加载进 Lua 虚拟机， Lua 提供了三个常用的函数\nLUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename, const char *mode); #define luaL_loadfile(L,f)\tluaL_loadfilex(L,f,NULL) LUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz, const char *name, const char *mode); LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s); 这三个函数最后走的都是 lua_load 函数，把经过编译后的代码放到了栈顶，执行加载到栈顶的 Lua 代码，上面的函数只是将程序加载到了栈顶，执行了之后才能变成虚拟机中的函数或者变量，因为在栈顶也没有需要传入的参数，所以只需要调用 lua_pcall 即可\nLUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k) 上面的常用的函数有对应的执行合并参数\nlua 加载执行流程 luaL_loadbufferx来直接看\nLUALIB_API int luaL_loadbufferx (lua_State *L, const char *buff, size_t size, const char *name, const char *mode) { LoadS ls; ls.s = buff; ls.size = size; return lua_load(L, getS, \u0026amp;ls, name, mode); } 调用lua_load\nLUA_API int lua_load (lua_State *L, lua_Reader reader, void *data, const char *chunkname, const char *mode) { ZIO z; int status; lua_lock(L); if (!chunkname) chunkname = \u0026#34;?\u0026#34;; luaZ_init(L, \u0026amp;z, reader, data); status = luaD_protectedparser(L, \u0026amp;z, chunkname, mode); if (status == LUA_OK) { /* no errors? */ LClosure *f = clLvalue(L-\u0026gt;top - 1); /* get newly created function */ if (f-\u0026gt;nupvalues \u0026gt;= 1) { /* does it have an upvalue? */ /* get global table from registry */ Table *reg = hvalue(\u0026amp;G(L)-\u0026gt;l_registry); const TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS); /* set global table as 1st upvalue of \u0026#39;f\u0026#39; (may be LUA_ENV) */ setobj(L, f-\u0026gt;upvals[0]-\u0026gt;v, gt); luaC_upvalbarrier(L, f-\u0026gt;upvals[0]); } } lua_unlock(L); return status; } luaD_protectedparser\nint luaD_protectedparser (lua_State *L, ZIO *z, const char *name, const char *mode) { struct SParser p; int status; L-\u0026gt;nny++; /* cannot yield during parsing */ p.z = z; p.name = name; p.mode = mode; p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0; p.dyd.gt.arr = NULL; p.dyd.gt.size = 0; p.dyd.label.arr = NULL; p.dyd.label.size = 0; luaZ_initbuffer(L, \u0026amp;p.buff); status = luaD_pcall(L, f_parser, \u0026amp;p, savestack(L, L-\u0026gt;top), L-\u0026gt;errfunc); luaZ_freebuffer(L, \u0026amp;p.buff); luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size); luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size); luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size); L-\u0026gt;nny--; return status; } f_parser\nstatic void f_parser (lua_State *L, void *ud) { LClosure *cl; struct SParser *p = cast(struct SParser *, ud); int c = zgetc(p-\u0026gt;z); /* read first character */ if (c == LUA_SIGNATURE[0]) { checkmode(L, p-\u0026gt;mode, \u0026#34;binary\u0026#34;); cl = luaU_undump(L, p-\u0026gt;z, p-\u0026gt;name); } else { checkmode(L, p-\u0026gt;mode, \u0026#34;text\u0026#34;); cl = luaY_parser(L, p-\u0026gt;z, \u0026amp;p-\u0026gt;buff, \u0026amp;p-\u0026gt;dyd, p-\u0026gt;name, c); } lua_assert(cl-\u0026gt;nupvalues == cl-\u0026gt;p-\u0026gt;sizeupvalues); luaF_initupvals(L, cl); } luaU_undump 或者luaY_parser，一个是luac的二进制文件，一个是luac的脚本文件\n思路和流程 因为有很多魔改对于文件的结构上的那些调整，可以在load完成之后，执行之前的时候，因为这个时候程序在栈顶的时候，调用标准的lua_dump函数，就可以获得luac文件了\ntypedef int (*lua_Writer) (lua_State *L, const void *p, size_t sz, void *ud); 当前的文件是lua 5.3.3版本：\n直接ida看一下luaL_loadbufferx，这个的luaL_loadbufferx和源码中的是不一样的所以如果frida hook的话，是要在leave的时候\n看这个反编译中带有lua_dump的函数，所以可以直接调用，脚本：\nvar lq_lua = Process.findModuleByName(\u0026#34;liblqd_lua.so\u0026#34;); var count = 0; var fopen = Process.findModuleByName(\u0026#34;libc.so\u0026#34;).findExportByName(\u0026#34;fopen\u0026#34;); var fwrite = Process.findModuleByName(\u0026#34;libc.so\u0026#34;).findExportByName(\u0026#34;fwrite\u0026#34;); var fopen_func = new NativeFunction(fopen, \u0026#39;pointer\u0026#39;, [\u0026#39;pointer\u0026#39;, \u0026#39;pointer\u0026#39;]); var fwrite_func = new NativeFunction(fwrite, \u0026#39;size_t\u0026#39;, [\u0026#39;pointer\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;pointer\u0026#39;]); var targetAddr = lq_lua.base.add(0x1660C); var lua_dump_ptr = lq_lua.base.add(0x13E14); var lua_dump = new NativeFunction(lua_dump_ptr, \u0026#39;int\u0026#39;, [\u0026#39;pointer\u0026#39;, \u0026#39;pointer\u0026#39;, \u0026#39;pointer\u0026#39;, \u0026#39;int\u0026#39;]); var currentFile = null; var writer_cb = new NativeCallback(function (L, p, sz, ud) { try { const n = Number(sz); if (n === 0) return 0; const wrote = fwrite_func(p, n, 1, ud); return (Number(wrote) === 1) ? 0 : 1; } catch (e) { //expected a pointer console.log(\u0026#34;writer_cb exception: \u0026#34; + e); return 1; } }, \u0026#39;int\u0026#39;, [\u0026#39;pointer\u0026#39;, \u0026#39;pointer\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;pointer\u0026#39;]); console.log(\u0026#34;lq_luaV_gettable @ \u0026#34; + targetAddr + \u0026#34; insn=\u0026#34; + Instruction.parse(targetAddr).toString()); console.log(\u0026#34;lua_dump @ \u0026#34; + lua_dump_ptr); Interceptor.attach(targetAddr, { onEnter: (args) =\u0026gt; { count += 1; this.fname = \u0026#34;/data/data/com.lingqing.detector/files/dump/dump.luac\u0026#34; + count; this.L = args[0]; }, onLeave: (retval) =\u0026gt; { console.log(\u0026#34;lq_luaV_gettable called \u0026#34; + count + \u0026#34; times\u0026#34;); try { currentFile = new File(this.fname, \u0026#34;wb\u0026#34;); } catch (e) { console.log(\u0026#34;Failed to open file \u0026#34; + this.fname + \u0026#34;: \u0026#34; + e); currentFile = null; } var cName = Memory.allocUtf8String(this.fname); var cMode = Memory.allocUtf8String(\u0026#34;wb\u0026#34;); var file = fopen_func(cName, cMode); if (currentFile) { try { //fwrite_func var status = lua_dump(this.L, writer_cb, file, 0); console.log(\u0026#34;lua_dump status=\u0026#34; + status); } catch (e2) { console.log(\u0026#34;lua_dump exception: \u0026#34; + e2); } try { currentFile.flush(); currentFile.close(); } catch (e3) {} } currentFile = null; } }); 可以抓到这6个luac，但是这么抓的还是会有加密的，说明需要调用原版本的lua的lua_dump，自己编译一个调用lua_dump\nvar lq_lua = Process.findModuleByName(\u0026#34;liblqd_lua.so\u0026#34;); var liblua = Module.load(\u0026#34;/data/data/com.lingqing.detector/files/liblua_share.so\u0026#34;); var pdump = liblua.findExportByName(\u0026#34;lua_dump\u0026#34;); var fun_dump = new NativeFunction(pdump, \u0026#34;int\u0026#34;, [\u0026#34;pointer\u0026#34;, \u0026#34;pointer\u0026#34;, \u0026#34;pointer\u0026#34;, \u0026#34;int\u0026#34;]); var count = 0; var fopen = Process.findModuleByName(\u0026#34;libc.so\u0026#34;).findExportByName(\u0026#34;fopen\u0026#34;); var fwrite = Process.findModuleByName(\u0026#34;libc.so\u0026#34;).findExportByName(\u0026#34;fwrite\u0026#34;); var fopen_func = new NativeFunction(fopen, \u0026#39;pointer\u0026#39;, [\u0026#39;pointer\u0026#39;, \u0026#39;pointer\u0026#39;]); var fwrite_func = new NativeFunction(fwrite, \u0026#39;size_t\u0026#39;, [\u0026#39;pointer\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;pointer\u0026#39;]); var targetAddr = lq_lua.base.add(0x1660C); var lua_dump_ptr = lq_lua.base.add(0x13E14); var lua_dump = new NativeFunction(lua_dump_ptr, \u0026#39;int\u0026#39;, [\u0026#39;pointer\u0026#39;, \u0026#39;pointer\u0026#39;, \u0026#39;pointer\u0026#39;, \u0026#39;int\u0026#39;]); var currentFile = null; var writer_cb = new NativeCallback(function (L, p, sz, ud) { try { const n = Number(sz); if (n === 0) return 0; const wrote = fwrite_func(p, n, 1, ud); return (Number(wrote) === 1) ? 0 : 1; } catch (e) { //expected a pointer console.log(\u0026#34;writer_cb exception: \u0026#34; + e); return 1; } }, \u0026#39;int\u0026#39;, [\u0026#39;pointer\u0026#39;, \u0026#39;pointer\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;pointer\u0026#39;]); console.log(\u0026#34;lq_luaV_gettable @ \u0026#34; + targetAddr + \u0026#34; insn=\u0026#34; + Instruction.parse(targetAddr).toString()); console.log(\u0026#34;lua_dump @ \u0026#34; + lua_dump_ptr); Interceptor.attach(targetAddr, { onEnter: (args) =\u0026gt; { count += 1; this.fname = \u0026#34;/data/data/com.lingqing.detector/files/dump/dump.luac\u0026#34; + count; this.L = args[0]; }, onLeave: (retval) =\u0026gt; { console.log(\u0026#34;lq_luaV_gettable called \u0026#34; + count + \u0026#34; times\u0026#34;); try { currentFile = new File(this.fname, \u0026#34;wb\u0026#34;); } catch (e) { console.log(\u0026#34;Failed to open file \u0026#34; + this.fname + \u0026#34;: \u0026#34; + e); currentFile = null; } var cName = Memory.allocUtf8String(this.fname); var cMode = Memory.allocUtf8String(\u0026#34;wb\u0026#34;); var file = fopen_func(cName, cMode); if (currentFile) { try { //fwrite_func var status = fun_dump(this.L, writer_cb, ptr(file), 0); console.log(\u0026#34;lua_dump status=\u0026#34; + status); } catch (e2) { console.log(\u0026#34;lua_dump exception: \u0026#34; + e2); } try { currentFile.flush(); currentFile.close(); } catch (e3) {} } currentFile = null; } }); 这次就可以进行反编译了\n但是a1和a6并不能反编译出来，这里可能有点问题，回看这个样本自带的关于lua的so，在lua_load里进行逆向可以发现\n因为按照之前看源码的流程，首先定位到luaD_protectedparser\n进来后定位到f_parser\n再定位到luaU_undump，但是这个里面还有一个luaU_undump在0x1a,0x1c两个case的是魔改的undump在sub_32D38的位置上\n进入sub_32d38中找到LoadFunction，可以看到loadstring是魔改的\n直接打开unluac源码的LStringType，添加解密代码逻辑\npackage unluac.parse; import java.io.IOException; import java.io.OutputStream; import java.nio.ByteBuffer; import java.nio.charset.StandardCharsets; import unluac.Version; public abstract class LStringType extends BObjectType\u0026lt;LString\u0026gt; { public static LStringType get(Version.StringType type) { switch (type) { case LUA50: return new LStringType50(); case LUA53: return new LStringType53(); case LUA54: return new LStringType54(); default: throw new IllegalStateException(); } } protected ThreadLocal\u0026lt;StringBuilder\u0026gt; b = new ThreadLocal\u0026lt;StringBuilder\u0026gt;() { @Override protected StringBuilder initialValue() { return new StringBuilder(); } }; } class LStringType50 extends LStringType { @Override public LString parse(final ByteBuffer buffer, BHeader header) { BInteger sizeT = header.sizeT.parse(buffer, header); final StringBuilder b = this.b.get(); b.setLength(0); sizeT.iterate(new Runnable() { @Override public void run() { b.append((char) (0xFF \u0026amp; buffer.get())); } }); if (b.length() == 0) { return LString.NULL; } else { char last = b.charAt(b.length() - 1); b.delete(b.length() - 1, b.length()); String s = b.toString(); if (header.debug) { System.out.println(\u0026#34;-- parsed \u0026lt;string\u0026gt; \\\u0026#34;\u0026#34; + s + \u0026#34;\\\u0026#34;\u0026#34;); } return new LString(s, last); } } @Override public void write(OutputStream out, BHeader header, LString string) throws IOException { int len = string.value.length(); if (string == LString.NULL) { header.sizeT.write(out, header, header.sizeT.create(0)); } else { header.sizeT.write(out, header, header.sizeT.create(len + 1)); for (int i = 0; i \u0026lt; len; i++) { out.write(string.value.charAt(i)); } out.write(0); } } } class LStringType53 extends LStringType { @Override public LString parse(final ByteBuffer buffer, BHeader header) { // 读取长度（含终止 0） BInteger sizeT; int sizeByte = 0xFF \u0026amp; buffer.get(); if (sizeByte == 0) { return LString.NULL; } else if (sizeByte == 0xFF) { sizeT = header.sizeT.parse(buffer, header); // 真实长度（含终止 0） } else { sizeT = new BInteger(sizeByte); } int fullLen = sizeT.asInt(); // 包括终止 0 int dataLen = fullLen - 1; // 实际字符串长度 if (dataLen \u0026lt; 0) { // 异常情况，返回空 return LString.NULL; } // 读取加壳后的原始数据（魔改版：全部被异或编码） byte[] encoded = new byte[dataLen]; for (int i = 0; i \u0026lt; dataLen; i++) { encoded[i] = buffer.get(); } // 解码：与 IDA 反编译出的 LoadString_xor 算法一致 byte[] decoded = decodeXor(encoded); String s = new String(decoded, StandardCharsets.ISO_8859_1); if (header.debug) { System.out.println(\u0026#34;-- parsed \u0026lt;string-xor\u0026gt; \\\u0026#34;\u0026#34; + s + \u0026#34;\\\u0026#34;\u0026#34;); } return new LString(s); } @Override public void write(OutputStream out, BHeader header, LString string) throws IOException { if (string == LString.NULL) { out.write(0); } else { // 写出时保持魔改前的格式（明文写出，未重新加壳）。 // 如果需要生成“加壳” dump，可在这里对 string.value 先 encodeXor 后再写。 int plainLenWithNull = string.value.length() + 1; if (plainLenWithNull \u0026lt; 0xFF) { out.write((byte) plainLenWithNull); } else { out.write(0xFF); header.sizeT.write(out, header, header.sizeT.create(plainLenWithNull)); } for (int i = 0; i \u0026lt; string.value.length(); i++) { out.write(string.value.charAt(i)); } } } // 魔改 XOR 解码逻辑：输入为被编码的实际数据（不含终止 0） private static byte[] decodeXor(byte[] enc) { int n = enc.length; if (n == 0) { return enc; // 空串 } byte[] out = new byte[n]; int mod = n % 255; int e0 = enc[0] \u0026amp; 0xFF; out[0] = (byte) (e0 ^ mod); int v8 = mod ^ e0; // (n % 255) ^ e0 long t = 2L * n + v8; // 可能超过 32 位，使用 long long step = n + v8; for (int i = 1; i \u0026lt; n; i++) { out[i] = (byte) (enc[i] ^ (int) (t % 255)); t += step; } return out; } // 如果未来需要重新加壳，可提供 encodeXor @SuppressWarnings(\u0026#34;unused\u0026#34;) private static byte[] encodeXor(byte[] plain) { int n = plain.length; if (n == 0) { return plain; } byte[] enc = new byte[n]; int mod = n % 255; int p0 = plain[0] \u0026amp; 0xFF; // 逆推：e0 = out[0] ^ (n % 255) int e0 = p0 ^ mod; enc[0] = (byte) e0; int v8 = mod ^ e0; long t = 2L * n + v8; long step = n + v8; for (int i = 1; i \u0026lt; n; i++) { int mask = (int) (t % 255); enc[i] = (byte) ((plain[i] \u0026amp; 0xFF) ^ mask); t += step; } return enc; } } class LStringType54 extends LStringType { @Override public LString parse(final ByteBuffer buffer, BHeader header) { BInteger sizeT = header.sizeT.parse(buffer, header); if (sizeT.asInt() == 0) { return LString.NULL; } final StringBuilder b = this.b.get(); b.setLength(0); sizeT.iterate(new Runnable() { boolean first = true; @Override public void run() { if (!first) { b.append((char) (0xFF \u0026amp; buffer.get())); } else { first = false; } } }); String s = b.toString(); if (header.debug) { System.out.println(\u0026#34;-- parsed \u0026lt;string\u0026gt; \\\u0026#34;\u0026#34; + s + \u0026#34;\\\u0026#34;\u0026#34;); } return new LString(s); } @Override public void write(OutputStream out, BHeader header, LString string) throws IOException { if (string == LString.NULL) { header.sizeT.write(out, header, header.sizeT.create(0)); } else { header.sizeT.write(out, header, header.sizeT.create(string.value.length() + 1)); for (int i = 0; i \u0026lt; string.value.length(); i++) { out.write(string.value.charAt(i)); } } } } 自己编译一下unluac然后运行\njava -jar /Users/l0x1c/decom/unluac.jar ./dump.luac6 --disassemble --output out.asm 编译回bin\njava -jar /Users/l0x1c/decom/unluac.jar ./out.asm -assemble --output out.bin 如果要用这个unluac的这个逻辑需要在lua_load的时候hook，因为如果调用原版的是已经解密完的了\nvar picStore = Process.findModuleByName(\u0026#34;liblqd_lua.so\u0026#34;); var count = 0; console.log(Instruction.parse(picStore.base.add(0x13D24)).toString()); Interceptor.attach(picStore.base.add(0x13D24), { // luaL_loadfilex func_addr onEnter: (args) =\u0026gt; { var reader = ptr(args[2]) count += 1; this.fname = \u0026#34;/data/data/com.lingqing.detector/files/dump/dump.luac\u0026#34; + count.toString() var file_handle = new File(this.fname + \u0026#34;hook\u0026#34;, \u0026#34;wb\u0026#34;); console.log(reader.readByteArray(16)) var len = ptr(reader.add(8)).readInt() file_handle.write(reader.readPointer().readByteArray(len)); file_handle.flush(); file_handle.close(); this.L = args[0]; }, onLeave: (retval) =\u0026gt; { } }) 这个时候dump出来的1文件可以看到头可以和那个case相对应上了\n这个时候调用编译好的unluac，看一下\n通过分析来看的话，6.lua的文件应该是字符串加密的解密器，直接hook一下lua_pushstring以及strncmp看一下大概的流程\nvar mInterval = setInterval(function () { var mod = Process.findModuleByName(\u0026#34;liblqd_lua.so\u0026#34;) var strncmp = mod.findExportByName(\u0026#34;strncmp\u0026#34;); if (mod == null) { console.log(\u0026#34;无\u0026#34;) return } clearInterval(mInterval); var addr = mod.base.add(0x12204) console.log(\u0026#34;hook addr: \u0026#34; + addr); console.log(Instruction.parse(addr).toString()); Interceptor.attach(addr, { onEnter: function (args) { if(args[1].readCString().indexOf(\u0026#34;_\u0026#34;)!=0) console.log(args[1].readCString()) } }) //endline Interceptor.attach(strncmp, { onEnter: function (args) { var s1 = args[0].readCString(); var s2 = args[1].readCString(); var n = args[2].toInt32(); console.log(\u0026#34;strncmp called: \u0026#34; + s1 + \u0026#34; , \u0026#34; + s2 + \u0026#34; , \u0026#34; + n); } }); }, 1) hook后可以看见一个关键的东西就是\nhttps://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/services/core/java/com/android/server/pm/ComputerEngine.java;l=2018;drc=61197364367c9e404c7da6900658f1b16c42d0da\n可以理解为通过uid来进行查询的，然后再通过GetPackageInfo来看是否存在来看是否有隐藏的app\n","permalink":"https://l0x1c.com/posts/luadec/","summary":"这个是工作中遇见的一个app，需要分析一下app对于应用列表检测感知这个问题\n对应的样本的网址：https://github.com/TMLP-Team/TMLP-Detectors-and-Bypassers/blob/main/Detectors/%E5%87%8C%E5%8D%BF%E6%A3%80%E6%B5%8B_v1.6_fix.apk\n直接拖进jeb看一下\n调用lua，看一下lingqing.bin\nLua 介绍 C 语言和 Lua 的交互是通过 lua_State来实现的，所以首先需要创建一个 lua_State\n把 Lua 脚本加载进 Lua 虚拟机， Lua 提供了三个常用的函数\nLUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename, const char *mode); #define luaL_loadfile(L,f)\tluaL_loadfilex(L,f,NULL) LUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz, const char *name, const char *mode); LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s); 这三个函数最后走的都是 lua_load 函数，把经过编译后的代码放到了栈顶，执行加载到栈顶的 Lua 代码，上面的函数只是将程序加载到了栈顶，执行了之后才能变成虚拟机中的函数或者变量，因为在栈顶也没有需要传入的参数，所以只需要调用 lua_pcall 即可\nLUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k) 上面的常用的函数有对应的执行合并参数","title":"unluac xxx_app 分析"},{"content":"xv6 环境配置问题 ( vmare or docker ) 配置的地址: https://pdos.csail.mit.edu/6.828/2020/tools.html 准备的系统： vmware + ubuntu\nvmare mit的实验代码:\ngit clone git://g.csail.mit.edu/xv6-labs-2020 git checkout util 这边遇见的坑大概网上都有解答，唯一的一个位置是，如果出现 user/sh.c:58:1: error 的问题修改代码\n加入__attribute__((noreturn)) 即可，后面直接目录下make qemu就可以启动了\n配置gdb调试也有点繁琐，主要就是在这个目录下进行 make qemu-gdb，新开一个窗口，那个窗口运行 gdb\n举个例子用sleep\n这样就可以调试了，具体的一些命令可以看：https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf https://xv6.dgs.zone/tranlate_books/Use%20GUN%20Debugger.html\ndocker 因为后面准备看csapp lab的适合还是得用到docker去配置环境，所以索性就直接学一下，后面就可以直接用了\n直接网上下载docker就可以\ndocker pull ubuntu docker run -i -t -w /root --name ubuntu ubuntu bash # 连接ubuntu系统 docker start -i ubuntu apt-get update apt-get install vim 需要换个源\nvim /etc/apt/source.list #替换 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 按照mit上面给的文档安装就行\nsudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu git clone git://g.csail.mit.edu/xv6-labs-2025 cd xv6-labs-2025 git checkout util make qemu 就可以安装成功了 需要配置一下ssh，后面和vscode联动的用的\n目录下创建一个makefile conn-docker: ssh -t root@localhost -p 20000 \u0026#34;cd xv6-labs-2025; bash\u0026#34; 配置ssh\napt-get install openssh-server vim /etc/ssh/sshd_config PermitRootLogin yes # 可以登录 root 用户 PubkeyAuthentication yes # 可以使用 ssh 公钥许可 AuthorizedKeysFile .ssh/authorized_keys # 公钥信息保存到文件 .ssh/authorized_keys 中 /etc/init.d/ssh restart 添加主机的 ssh 公钥\ndocker的ubuntu下 mkdir ~/.ssh touch ~/.ssh/authorized_keys mac下 ssh-keygen -t rsa cat id_rsa.pub 再把id_rsa.pub 的内容复制到 authorized_keys中 提交修改到镜像\ndocker ps -a docker commit -m \u0026#39;add ssh\u0026#39; -a \u0026#39;L0x1c\u0026#39; eacf5681c653 xv6-ssh docker image ls docker rm {没用的那个docker容器} 最终的docker容器\ndocker run -d -p 20000:22 --name xv6-lab xv6-ssh /usr/sbin/sshd -D 对应的vscode的配置就好很多了，安装ssh的那个插件配置一下就行\n就可以安心的改代码，看代码了\n进行gdb调试\ngdb-multiarch kernel/kernel # (gdb) 进入gdb后执行 set confirm off set architecture riscv:rv64 target remote localhost:25000 set riscv use-compressed-breakpoints yes 保存镜像到本地\ndocker export -o xv6-lab.rar xv6-labs ","permalink":"https://l0x1c.com/posts/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","summary":"xv6 环境配置问题 ( vmare or docker ) 配置的地址: https://pdos.csail.mit.edu/6.828/2020/tools.html 准备的系统： vmware + ubuntu\nvmare mit的实验代码:\ngit clone git://g.csail.mit.edu/xv6-labs-2020 git checkout util 这边遇见的坑大概网上都有解答，唯一的一个位置是，如果出现 user/sh.c:58:1: error 的问题修改代码\n加入__attribute__((noreturn)) 即可，后面直接目录下make qemu就可以启动了\n配置gdb调试也有点繁琐，主要就是在这个目录下进行 make qemu-gdb，新开一个窗口，那个窗口运行 gdb\n举个例子用sleep\n这样就可以调试了，具体的一些命令可以看：https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf https://xv6.dgs.zone/tranlate_books/Use%20GUN%20Debugger.html\ndocker 因为后面准备看csapp lab的适合还是得用到docker去配置环境，所以索性就直接学一下，后面就可以直接用了\n直接网上下载docker就可以\ndocker pull ubuntu docker run -i -t -w /root --name ubuntu ubuntu bash # 连接ubuntu系统 docker start -i ubuntu apt-get update apt-get install vim 需要换个源\nvim /etc/apt/source.list #替换 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.","title":"xv6 环境配置 vmare or docker"},{"content":"ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧\n主要的学习流程大概这两个：\n看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 \u0026amp; 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件 cemu 做辅助支持 : https://github.com/hugsy/cemu\n在ubuntu下面折腾了一下，感觉还行\n当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）\nAndroid studio \u0026amp; ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下\n安装完之后自己在 .zshrc 中配置一下环境变量\nexport ANDROID_HOME=\u0026#34;Android/sdk所在路径\u0026#34; export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了\n代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下\n进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}\n以后避免每次都打开 android studio可以用emulator里面命令来启动avd\n⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了\n配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发\n这样后ida attach就可以看到对应的进程那些了\nc编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en\n主要需要的是 Application.mk 和 Android.mk 这两个文件，现在写一个c然后编译一下试试\nAPP_ABI := arm64-v8a APP_BUILD_SCRIPT := Android.mk APP_PLATFORM := android-16 LOCAL_PATH := $(call my-dir) #LOCAL_ARM_MODE := arm LOCAL_MODULE := hello LOCAL_SRC_FILES := hello.c include $(BUILD_EXECUTABLE) 执行 ndk-build NDK_PROJECT_PATH=. NDK_APPLICATION_MK=Application.mk\n可以看到已经生成了，一个是debug版本的一个是release版本的，ida这样就可以开始调试起来了\n⚠️ 好像mac m1还没办法运行32位的，所以该文章主要都以64位为主，学的时候也是多学一下64位的毕竟是主流 ( 当然也可以先用32位的来做 )\n寄存器和指令基本格式 寄存器介绍 找了一台手机可以支持32位的，以及64位的，这样就可以都学一下了\n这次就可以32位调试起来了，可以很好看到32位的寄存器\narm32下一共有16个通用寄存器和一个状态寄存器\n其中r13叫做SP叫做栈指针寄存器相当于x86汇编中的esp LR叫做linker指针，当执行函数调用指令 BL func（Branch with Link）时，CPU 会自动把下一条指令的地址（PC + 4）写入 LR，并且跳转到 func 标签执行 BL func ; lr = pc + 4, 跳转到 func 函数如果想要返回的话 MOV PC, LR ; 回到调用点继续执行 如果函数内又调用了别的函数，LR 会被覆盖，所以通常编译器会 STMDB sp!, {LR} ; 保存返回地址 ... LDMIA sp!, {PC} ; 恢复并返回 PC (Program Counter) 里面存放的是当前的地址，对应x86里的eip PSR相当于x86中的eflag寄存器 可以看到arm手册里的介绍 对于PSR (当前程序状态寄存器) 这些位的介绍：\n位 名称 含义 说明 N (bit 31) Negative 结果为负 若算术结果为负，N=1 Z (bit 30) Zero 结果为零 若结果为 0，Z=1 C (bit 29) Carry 进位标志 加法进位或减法借位 V (bit 28) Overflow 溢出标志 有符号运算时溢出 ADD r0, r1, r2 ; CPSR.C 被设置为进位标志 SUBS r0, r1, r2 ; 带S的指令会更新 N Z C V 标志 27 位：Q（Saturation flag，饱和标志）\n用于 饱和运算（Saturating Arithmetic）指令，如 QADD、QDADD 当运算结果超出表示范围时，Q=1 可用 MSR CPSR_f, #0 或 MRS/MSR 指令清除或读取 26–25 位：IT[7:6]（If-Then 块标志）\n用于 Thumb 模式的 IT（If-Then）块控制 ITE EQ MOVEQ r0, #1 MOVNE r0, #0 #这时 CPSR 的 IT 位会被硬件自动设置与清空 19–16 位：GE[3:0]（Greater or Equal flags）\n用于 SIMD（多数据并行）中的比较结果标志（例如 UADD8, USUB8 等） 每一位对应 8 位操作结果是否大于等于 9 位：E（Endian bit）现在arm系统几乎都是小端的\nE = 0 → 小端（Little-endian） E = 1 → 大端（Big-endian） 5 位：T（Thumb state）\nT = 0 → ARM 模式（32 位指令） T = 1 → Thumb 模式（16 位指令） BX R0 ; 跳转到R0地址，并根据最低位决定T标志 # 如果 R0 的最低位为 1，会自动切换到 Thumb 模式 4–0 位：M[4:0]（处理器模式位）\n模式位（M4:M0） 模式名 权限 说明 10000 User 非特权 普通用户态 10001 FIQ 特权 快速中断 10010 IRQ 特权 普通中断 10011 Supervisor (SVC) 特权 系统调用 / 启动模式 10111 Abort 特权 内存访问异常 11011 Undefined 特权 未定义指令异常 11111 System 特权 特殊内核态 总体设计和指令规格 arm汇编中没有隐式内存操作指令\n这个怎么理解呢？ 可以这么来说，在x86汇编中有很多的隐式内存操作指令，比如push pop call，比如push这个指令，这个指令本身是没有内存的索引地址的，这个指令操作后会隐式的把esp指针的地址-4并且往其中写一个数，那么这个push这个指令就隐式的操作了内存，包括中断指令int 等等\narm汇编中，指令是 0 - 3个操作数，内存操作数和立即数操作数不能同时存在（因为 ARM 是典型的 load–store（取数-运算分离） 架构），内存操作数至多出现1次，寄存器操作数一般都是在前面\n这里大概理解了一下为什么内存操作数和立即操作数不能同时存在： 指令位数固定，要同时编码“访存寻址模式 + 数据算术的立即数/移位 + 寄存器号 + 条件码”，位不够用，解码也会变复杂，所以把复杂操作拆成两条简单指令，可以更好的乱序执行，把“访存”和“算术”拆开，硬件解码与执行更规整，单周期（或固定多周期）更容易保证；条件执行也更可控\n可以观察看到，左边的都是寄存器操作数，上面看到的LDR R6, [R6,#0xC]这种的属于两个操作数，后面的只是内存的一种索引模式 再比如：MOV.W R7, R9,LSR#12 这也是两个操作数，第二个R9,LSR#12这属于一个操作数\n读pc寄存器 在arm的这个汇编的情况中，pc寄存器属于那种正常的寄存器，可以对这个寄存器进行写，那么写到这个寄存器就相当于了指令跳转，写了个例子方便理解，可以看到跳过了地址是8的位置，直接到了c的地址\n读取pc寄存器有很多比较奇怪的行为，读取pc寄存器的时候，如果是arm模式会+8，thumb模式+4，因为ARM的流水线是为了性能优化设计的让CPU在执行当前指令的同时，已经把下一条、下下条都装载进指令缓存\n模式 指令长度 流水线深度 读取 PC 实际值 偏移原因 ARM 模式 4 字节 提前取两条 当前地址 + 8 三段流水线取指超前 Thumb 模式 2 字节 提前取一条 当前地址 + 4 指令短、取指周期短 ldr的指令读pc的内存也同理，可以看到后面的pc读取的数据pc被+8，然后读取8位置的值，所以pc寄存器只要有读的指令存在就是读的就是pc+8\n这里说一个问题就是ldr r0,[pc, #-4]\n但是比如你在ida调试那些环境下，那么读的就不是这个值了\n这里加一个小trips (关于ida安装keypatch): 这里我用了高版本的ida9.0，keypatch不支持：https://bbs.kanxue.com/thread-286591.htm#msg_header_h3_4\n编译之前看一下自己ida的架构，然后编译的keystone的dylib要对应上\n就可以用了\n继续回到主题！调试环境下的为什么不是这个值，我们看一下 这里我写的是 ldr r0, [pc, #-4]，ida帮我们优化了一下可以直接看到地址，之前说的pc寄存器遇见读的指令pc在arm模式下会+8，由于我-4了，所以应该是pc+4，读到的值r0应该是912fff1e\n我们现在看一下，读取到底是什么值，可以看到读取的是E7F001F0，这个是什么呢，我在下面硬编码改了一下，发现时UND #10，这个是什么？！\n网上查了一下，这个值都和反调试有关系，那么可以理解为，这里相当于读的断点的中断指令，类似于x86中f8的int 3，相当于单步的时候会有一个信号，信号呢被调试器捕获，然后ida捕获到异常，然后进行处理\nthumb模式下：\n先看第一个指令ldr r0,[pc] 这个在thumb模式下是pc + 4的地址读取出来\n可以看到又读了一个中断 DE10\n但是这里有疑问了，不是pc+4吗，继续往下看下面的两个都是e4的那个，就可以知道了，其实是有地址对齐的问题存在，所以才会两个条指令都是相同的pc+4但是对应的地址是一样的情况，所以thumb模式下还需要对齐，可以总结规律thumb模式下ldr reg,[pc]的pc地址是要 pc - pc % 4\n看一下公式准不准确用上面的d6的地址做一下对应的计算，可以看到是d8\n这种的东西在arm模式下不考虑，因为arm模式下都是4字节的，所以都是对齐的情况\n条件和标志位响应 Trips:（大部分的指令的说明都在arm手册的F5.1 以及 C6.2下）可以自己没事的时候看看\n上面的图代表了arm中的条件标志位的一些标识，比如如果相等就是EQ那么z就等于1这些，上面的这些助记符扩展都可以加入一些指令后面，比如 addeq r0, r0, #1 那么这句的含义就是当z=1的时候r0 = r0 + 1\n让这些标志位进行改变的，举例大概有cmp，或者是某些指令加了后面加了s的，因为加了s就可以把指令影响的标志寄存器进行改，用add进行举例可以看到，adds如果reg不是pc，他会更新psr中的标志位的\n直接写汇编调试一下运行看看，写的是add r0,r0,r1 r0 = 1 r1 = 0xffffffff，是进位的，但是add指令是不改变标志寄存器只改变结果，所以没有看到\n现在我变成adds可以看一下，可以看到改表了标志寄存器的值，发生了进位和为0，所以c位和z位变成了1\n查看手册可以发现上面说的第20位为S位，如果是1就是adds，如果是0那么就是add\n01 00 80 E0 ADD R0, R0, R1 01 00 90 E0 ADDS R0, R0, R1 0000 0001 0000 0000 1000 0000 1110 0000 0000 0001 0000 0000 1001 0000 1110 0000 其中有一个和x86相反的规则是减法指令，可以看一下，第一个sub r0,r0,r1 其中的r0 = 0, r1 = 0xffffffff，第二个r0 = 2，r1 = 1\n可以看到结果对了，但是c位没有变成1，但是第二个的时候c位变成了1\n这个位置就和之前x86学习汇编有一点不一样的情况，这里的情况是产生借位c是0，不产生借位c是0，规则就是减法就是加法器a−b=a+(∼b+1)\n这边有几个对应的指令\nsub subs cmp add adds cmn 如果想判断哪些指令有没有更新标志寄存器，你只需要看第20位是不是1，或者第五个十六进制是不是奇数就行，我在libc中随便找的一个函数，可以看到第五个如果是奇数的话，那么就是会改变psr寄存器的\nMOV指令 mov指令没有访存的操作，所以两个操作数要不就是reg要不就是imm\nmov,movs (immediate) 因为arm的指令集是4字节的指令，立即数如果是32位的肯定放不下，所以arm的imm没办法直接写32位的立即数，mov立即数的情况手册中分成了两种指令格式一种是A1，一种是A2\nA2编码格式 先看一下A2的指令格式，上面有写到，A2的指令格式支持所有16位的立即数，这16位的立即数会写在0-11为以及16-19位，其中的12-15位代表了寄存器正好是4位代表了16个寄存器\n举个例子 mov r1, #0x1234 对应的硬编码是E3011234，那么正好就是0-11为234，16-19为1，12-15为1，正好和上面对应上了\nA1编码格式 比如这个指令：mov r1, #0x80000000，这个立即数已经超过了16位的范围，是32位的范围，那么这种情况就是对应的A1编码格式的情况，为什么要这么设计呢？\n虽然他比16位大，但是他的有效位只有最开始那一位\n这个硬编码根据A1拆分，0-11位是102，12-15的rd为1不变，16-19是0\n上面的解释是A32ExpandImm_C(imm12, PSTATE.C)，imm12需要拆成rot = imm12[11:8]，以及imm8 = imm12[7:0]，其中的rot的单位为2，所以上面的102可以为 02像右循环移为2，因为是32位02为10，像右循环移位2就是1（31个0），所以就是0x80000000，那么说明这个就可以表示0x0 - 0xff的情况都可以像右循环移位，移动的位数是0-16，为什么要乘2，那么就可以覆盖32位，那么就覆盖了0-32位的偶数\nmovt movt是像高4位写，如果像写32位的可以这么写\nmov r1,#0x5678 movt r1,#0x1234 ida优化就直接合并成了一条指令，这个movt的指令一定是先写mov后写movt，因为mov指令会把前面的4字节变成0，那么先写movt就没用了\n那么在实际代码中编译器怎么写的这个情况呢，可以看一下\n#include \u0026lt;stdio.h\u0026gt; int main() { u_int32_t test_var = 0x12345678; printf(\u0026#34;Test variable value: 0x%X\\n\u0026#34;, test_var); while (1) { printf(\u0026#34;Hello, World!\\n\u0026#34;); getchar(); } return 0; } 可以看到真实的环境下的寻址，都是通过ldr的这种方式去寻址的，movt这种一般是后面写shellcode的时候比较有用处\nmov,movs (register) 这个普通的mov reg,reg肯定都比较了解了，其中的0-3位为源寄存器，12-15为目标寄存器，举例中的这个mov r0,r1，其中r1就是0-3位为1，r0就是12-15位为0\n这个上面的图中的imm5就代表了可以进行移位的数字，可以看到是7-11位，一共是5位，5位就是代表了0-31，就是32个数字，也对应了32位\n下面这个例子就是左移1位，怎么移就要看5-6位的stype位了，因为有两位所以对应了四种情况：逻辑左移，逻辑右移，算数右移，循环移位 （没有算数左移，因为这个是和逻辑左移式一样的）\n在看一下移位的汇编，其实和mov的硬编码是一样的，因为他们的原理等价了mov的东西，其实移位的操作可以理解为是mov指令的一个宏定义\nmov,movs (register-shifted register) 这个是寄存器移位寄存器赋值给寄存器，所以和上面的大概的流程是一样的不重复了\n基本整型运算 基本运算基本不会出现两个imm，因为举个例子，比如 add r0,1,2 相当于r0 = 3，这个写出来就很奇怪了，早就在编译器的那一步就给你优化掉了\n像这种基本整形运算其实大部分都一样，格式所以主要以add来举例说明，后面的简单介绍功能就可以\nADD 见到这种12位的imm，其实本质上都是之前说的mov的那种形式 8位代表数字，4位代表移位\n寄存器的就比较简单了，两个寄存器想加写在第三个寄存器里，其中的imm5和stype就是之前mov中的说的移位操作\n这个就也和上面的mov类似就是寄存器移位寄存器\n这个就是pc+imm给到另一个寄存器了\n看一下汇编 add r0,pc,4\nida中对应什么呢，因为pc进行读就需要当前的pc+8，上面的指令加上4，所以就是2c的位置，但是在正常的调试环境中，或者运行环境中会根据imagebase进行调整可以在这里看一下printf的位置的这个情况\nprintf这个情况，可以看到他把imagebase加上去了\nSUB/CMP 减法操作 SUB Rd, Rn, Op2：Rd = Rn - Op2 CMP Rn, Op2：只比较不写寄存器，等价于 SUBS (丢弃结果)\n; i--，并在为零时跳走 SUBS r0, r0, #1 BEQ don ; 比较 a 与 b CMP r1, r2 ; 相当于 SUBS r?, r1, r2 BGE ge_path ; 大于等于走这里（无借位 + 非溢出） RSB 反减 RSB Rd, Rn, Op2：Rd = Op2 - Rn\n; 取负：Rd = -Rm RSBS r0, r1, #0 ; r0 = 0 - r1，顺带写标志 AND/TST 与操作 AND Rd, Rn, Op2：Rd = Rn \u0026amp; Op2 TST Rn, Op2：与运算并只写标志，等价于 ANDS (丢弃结果)\n; 测试 r0 的 bit 7 是否为 1 TST r0, #(1\u0026lt;\u0026lt;7) BNE bit7_is_one BIC 反与，按位清零 BIC Rd, Rn, Op2：Rd = Rn \u0026amp; ~Op2\n; 清 r0 的低 4 位 BIC r0, r0, #0xF ; 清 r1 的 bit 20（把 bit20 置 0） BIC r1, r1, #(1\u0026lt;\u0026lt;20) ORR 或 ORR Rd, Rn, Op2：Rd = Rn | Op2\n; 置 r0 的 bit 3 和 bit 5 ORR r0, r0, #(1\u0026lt;\u0026lt;3) | (1\u0026lt;\u0026lt;5) EOR/TEQ 异或 EOR Rd, Rn, Op2：Rd = Rn ^ Op2（按位异或/翻转） TEQ Rn, Op2：只写标志，等价于 EORS (丢弃结果)，常用来“测试相等性（按位相同则结果 0）”或“测试奇偶”\n; 翻转 r0 的 bit 8 EOR r0, r0, #(1\u0026lt;\u0026lt;8) ; 判断 r1 与 r2 的比特是否完全相同 TEQ r1, r2 BEQ equal_bits ; r1 ^ r2 == 0 访存指令 LDR: 读内存 STR: 写内存\nldr r1, [r0] 代表了从r0的地址中读取4个字节给r1寄存器\nldr r1, [r0, #4] 代表了从r0 + 4的地址中读取4个字节给r1寄存器\n可以大概看到ldr的指令基础大概这样，和之前学到的差不多，但是这些都是没有后续行为的\n有后续附加行为的比如，可以在内存的后面加一个！号，LDR R0, [R1,#4]! 这个指令的含义是把R1 + 4李的内存内容给到R0后，R1 = R1 + 4，LDR R0, [R1], #4 这个指令的含义是把R1的内存内容给到R0后，R1 = R1 + 4\n写内存的指令其实同理，str指令是把左边的寄存器赋值给右边的内存，和ldr的方向相反了而已，我们现在直接调试，给举例就可以明白了，我们用push和pop对应的arm指令就可以说明白了！\narm 中的push reg，pop reg对应的真实指令是：str {reg},[sp,#-4]! 和 LDR {reg},[sp],#4\n执行完的结果就是：\n手册里也写了，这个里面还有一个知识点就是p位如果是1就是立即数在里面，如果是0就是在外面，因为立即数只有12位，所以只能是里面和外面只能有一个同时存在\n手册中的ldrd, ldrh，ldrb，代表了64位，16位，8位，str的相关知识同理上面 其中的ldrd如下代表了，偶数寄存器，第二个是偶数寄存器+1的寄存器，后面时内存地址比如：ldrd r8,r9,[pc]\n块访存指令 块访存指令从内存读到寄存器时ldm，可以理解为load memory\n这个读取的ia，da，ib，db的含义是，如下图，i代表增加，d代表减少，a代表after，b代表before\n这里举个例子是：ldmia r0 ,{r1-r8}\n这个就代表了把r0地址中的内存数据从低地址放入从小到大的编号的寄存器中，这个寄存器可以看上面手册中的register_list，这个register_list一共是16位，代表了对应的16个寄存器，因为一共有16位\n这个指令第一个操作数后面如果不带感叹号，代表他不会移动位置，如果带了，代表要移动后面的操作数*4字节，a和b的区别就是读取的东西差了4字节，因为一个是先移动再读，一个是先读再移动\n主要的块访存指令大部分都是针对于堆栈操作，比如保存环境什么的等等，那么堆栈操作最常用的是ia!和db!这两个指令\n因为可以看到db的指令是指针上移，地址-4然后存放数据，那么这个操作很像push，那么ia是，pop了一个数据后指针下移动，因为push需要的是存数据，所以是stmdb，那么pop需要的读数据，所以是ldmia\n我在ida中写的是stmdb sp!,{r0-r4} ldmia sp!,{r0-r4}，自动给我识别成了push和pop 块访存指令还主要多数用于内存拷贝，实际上用的最多的是ia，da\n直接看几个函数来看一下对应的情况就知道了，这种就是对应的是 stmdb sp!,{r4-r8,lr} ldmia sp!,{r4-r8,lr}，因为是从小地址到大地址对应的寄存器，所以stmdb的时候相当于lr r8 r7 r6 r5 r4依次的顺序入栈，ldmia的是相当于是r4 r5 r6 r7 r8 lr这种顺序出栈，所以一一对应上了\n有一些时候ida会把stmdb和ldmia的指令后面是sp的话，翻译成stmfd，ldmfd，所以看到就是push pop\n块访存指令，可以用ldmia 和 stmia进行联动，先用ldmia指令读一个地址写到寄存器中，再用stmia把寄存器的值写到另一个内存地址中，这么重复就是复制内存的操作了\n直接把上面说的实验一下：\n同理就不测试了！\n分支和模式切换 这里介绍 B BL BX BLX 这四种指令的情况，后面分成相应的imm和reg两种，其中的BLX后面既可以加立即数，又可以加寄存器这两种情况\n这里主要探究跳转目标，模式切换，写入LR的值这三种情况的可能性\nB IMM B指令后面只能加立即数，这里的汇编的形式是相对地址偏移，直接f7就会到下面的CMN的那一行\nB指令是不带模式切换的，他是直接到写到的地址那里，比如这里是thumb模式\n我是直接跳到的这个位置，原来是arm模式，所以过来的时候因为B指令不带模式切换所以这里就识别成了arm指令\n这个B指令有一个很常用的字节码就是FE FF FF EA，这个相当于-2乘4以后就是自己的本身的地址了，因为pc寄存器arm中如果读的话就是相当于+8，所以这里字节码-2相当于自己这里\nB指令手册中的说明，这里后面的字节码是24位，因为寻址相当于*4，那么寻址范围是26位\n这个字节码循环自己，相当于别人写的代码，我们要attach，但是对方没有循环的情况下，那么我们可以patch最开始的位置，我们就可以attach上去了，等attach后把开始的位置正确的字节码patch回去就可以调试了，这个有点相当于之前调试windows的时候那个双进程守护，直接patch开始的时候就可以针对于这个情况进行调试了\nBL IMM BL指令后面也是立即数，并且不带有模式切换，他这个和B指令不同的话，这个BL指令执行的时候可以修改LR寄存器的值，这里指令有点相当于call把返回地址保存了\n在arm模式下，这个的跳转LR寄存器保存的是他的下一条指令的地址\n在thumb模式下，这个跳转保存的LR寄存器的值，要或上T位标志寄存器的值，这样返回的时候就可以识别是arm模式还是thumb模式\n这里我改成了BL这个位置的地址，按道理来说thumb模式下一条应该是76，发现LR寄存器这里位置是77，所以thumb模式下的情况如果要识别这个返回地址是不是就和T位进行或\nBX REG BX REG的指令带有了模式切换，但是模式要不要切换得看REG的值末尾有没有与上1\n与1的情况\nBLX IMM/REG BLX代表有模式切换，并且写入LR寄存器中\nIMM的情况是固定的模式切换，如果是REG还需要看最后一位\nThumb模式, IT块 IT指令块\n比如现在写的是ITTET EQ\nIT指令块的大小，看EQ是属于一个，IT后面开始算，T代表满足，E代表不满足的情况，相对应执行下面对应的代码\n所以上面的情况只有第三句话执行了因为对应的位置是E，代表不满足EQ的时候，他执行，所以结果就是r2 = 3\n调用约定和栈帧分析 调用了一个函数后，可以发现对应的非易变寄存器是R4 - R11, SP\n我们直接用ida开始看画一下堆栈图 代码：\n#include \u0026lt;stdio.h\u0026gt; int add(int a, int b, int c, int d, int e, int f) { printf(\u0026#34;%d\u0026#34;,a); int n = d + e; return n; } int main() { int n = 1; add(1, 2, 3, 4, 5, 6); return 0; } 开始画对应的堆栈图：\n总结起来就是：r0–r3:存储传递给函数的参数值，多余的参数通过压栈传递\ninlineHook #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; typedef FILE *(*fopen64_fn)(const char *path, const char *mode); uint32_t ret_addr = 0; uint64_t original_code = 0; uint32_t arg1; uint32_t arg2; void restore_original_code(void) { *(uint32_t *)(ret_addr - 1) = (uint32_t)(original_code \u0026amp; 0xFFFFFFFF); *(uint32_t *)(ret_addr + 4 -1) = (uint32_t)(original_code \u0026gt;\u0026gt; 32); } void __attribute__((naked)) myhook() { asm(\u0026#34;STMFD sp!, {R0-R12, LR, PC}\u0026#34;); //保存现场 asm(\u0026#34;mrs R0, CPSR\u0026#34;); asm(\u0026#34;STMFD sp!, {R0}\u0026#34;); //保存CPSR asm(\u0026#34;LDR R4, [sp, #4]\u0026#34;); //获取参数1，即fopen的第一个参数filename asm(\u0026#34;STR R4, %0\u0026#34; : \u0026#34;=m\u0026#34;(arg1)); //保存参数1到全局变量arg1 asm(\u0026#34;LDR R4, [sp, #8]\u0026#34;); //获取参数2，即fopen的第二个参数mode asm(\u0026#34;STR R4, %0\u0026#34; : \u0026#34;=m\u0026#34;(arg2)); //保存参数2到全局变量arg2 //修复现场，执行原始指令 asm(\u0026#34;BL restore_original_code\u0026#34;); asm(\u0026#34;LDR R0, %0\u0026#34; : : \u0026#34;m\u0026#34;(ret_addr)); //设置返回地址到下一条指令 asm(\u0026#34;STR R0, [sp, #0x3C]\u0026#34;); //修改栈中的返回地址 asm(\u0026#34;LDMFD sp!, {R0}\u0026#34;); //恢复CPSR asm(\u0026#34;msr CPSR, R0\u0026#34;); asm(\u0026#34;LDMFD sp!, {R0-R12, LR, PC}\u0026#34;); //恢复现场 } int main() { void *hand = dlopen(\u0026#34;/apex/com.android.runtime/lib/bionic/libc.so\u0026#34;, RTLD_NOW); printf(\u0026#34;libc handle: %p\\n\u0026#34;, hand); void *add_addr = dlsym(hand, \u0026#34;fopen64\u0026#34;); mprotect((void *)((unsigned long)add_addr \u0026amp; ~0xfff), 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC); printf(\u0026#34;faddr: %p\\n\u0026#34;, add_addr); //从add_addr开始读八个字节 original_code = *(uint64_t *)(add_addr - 1); //original code: 0x48444606b084b570 /* .text:000AB3B8 70 B5 PUSH {R4-R6,LR} ; Alternative name is \u0026#39;fopen\u0026#39; .text:000AB3BA 84 B0 SUB SP, SP, #0x10 .text:000AB3BC 06 46 MOV R6, R0 .text:000AB3BE 44 48 LDR R0, =0x15474 */ printf(\u0026#34;original code: 0x%llx\\n\u0026#34;, original_code); *(uint32_t*)((uint32_t)add_addr - 1) = 0xf000f8df; // ldr pc, [pc, #-4] *(uint32_t *)((uint32_t)add_addr - 1 + 4) = (uint32_t)myhook; ret_addr = (uint32_t)(add_addr); //一会回到最开始执行的位置 FILE *fp = fopen(\u0026#34;/data/local/tmp/study_arm/1.txt\u0026#34;, \u0026#34;rb\u0026#34;); printf(\u0026#34;fopen returned: %p\\n\u0026#34;, fp); uint32_t data; //fread(\u0026amp;data, 4, 1, fp); printf(\u0026#34;fopen arg1: %s\\n\u0026#34;, (char *)arg1); printf(\u0026#34;fopen arg2: %s\\n\u0026#34;, (char *)arg2); fclose(fp); return 0; } ","permalink":"https://l0x1c.com/posts/arm-%E6%B1%87%E7%BC%96/","summary":"ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧\n主要的学习流程大概这两个：\n看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 \u0026amp; 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件 cemu 做辅助支持 : https://github.com/hugsy/cemu\n在ubuntu下面折腾了一下，感觉还行\n当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）\nAndroid studio \u0026amp; ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下\n安装完之后自己在 .zshrc 中配置一下环境变量\nexport ANDROID_HOME=\u0026#34;Android/sdk所在路径\u0026#34; export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了\n代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下\n进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}\n以后避免每次都打开 android studio可以用emulator里面命令来启动avd\n⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了\n配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发\n这样后ida attach就可以看到对应的进程那些了\nc编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en\n主要需要的是 Application.mk 和 Android.","title":"Arm 汇编学习"},{"content":"VAD_私有内存 私有内存 像malloc, virtualalloc申请的内存都是私有内存, MapViewofFile, MapViewOfSize, mdl, 这种是映射的内存\n这些内存是由一个叫做vadroot的节点来管理的, 可以看一下这个位置 这里如果后续想获取到这个位置的话, 因为每个版本的偏移可能不一样, 可以通过函数PsGetProcessExitStatus来获取对应的偏移 + 4就是vadRoot win10上的结构\n+0x658 VadRoot : _RTL_AVL_TREE +0x660 VadHint : 0xffff900f`4bf43e10 Void +0x668 VadCount : 0xde VadRoot: _RTL_AVL_TREE 里面就是代表了二叉搜索树的节点, 而里面的每个节点的结构都是__MMVAD的结构, VadHint多次查询的节点会放在这里, VadCount代表vad节点的个数\nkd\u0026gt; dt _RTL_AVL_TREE ffff900f4c129400+0x658 nt!_RTL_AVL_TREE +0x000 Root : 0xffff900f`4bf44810 _RTL_BALANCED_NODE kd\u0026gt; dt 0xffff900f`4bf44810 _RTL_BALANCED_NODE nt!_RTL_BALANCED_NODE +0x000 Children : [2] 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE +0x000 Left : 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE +0x008 Right : 0xffff900f`4bfe65c0 _RTL_BALANCED_NODE +0x010 Red : 0y0 +0x010 Balance : 0y00 +0x010 ParentValue : 0 !vad即可查询 其中start和End代表了开始和结束, 都需要乘上pagesize -\u0026gt; 0x1000其中end不一样(end + 1)*pagesize - 1, 里面的每一个节点都是_MMVAD的结构, 可以找一个私有内存看一下结构\nkd\u0026gt; dt _MMVAD ffff900f4bf449a0 nt!_MMVAD +0x000 Core : _MMVAD_SHORT +0x040 u2 : \u0026lt;anonymous-tag\u0026gt; +0x048 Subsection : 0x01dbdb86`7175af69 _SUBSECTION +0x050 FirstPrototypePte : (null) +0x058 LastContiguousPte : (null) +0x060 ViewLinks : _IST_ENTRY [ 0xffff900f`4bfe4540 - 0x00000026`00000020 ] +0x070 VadsProcess : (null) +0x078 u4 : \u0026lt;anonymous-tag\u0026gt; +0x080 FileObject : 0x00000004`00100200 _FILE_OBJECT kd\u0026gt; dt _MMVAD_SHORT ffff900f4bf449a0 nt!_MMVAD_SHORT +0x000 NextVad : 0xffff900f`4bfe4e00 _MMVAD_SHORT +0x008 ExtraCreateInfo : 0xffff900f`4bfe29c0 Void +0x000 VadNode : _RTL_BALANCED_NODE +0x018 StartingVpn : 0x160 +0x01c EndingVpn : 0x166 +0x020 StartingVpnHigh : 0 \u0026#39;\u0026#39; +0x021 c : 0 \u0026#39;\u0026#39; +0x022 CommitChargeHigh : 0 \u0026#39;\u0026#39; +0x023 SpareNT64VadUChar : 0 \u0026#39;\u0026#39; +0x024 ReferenceCount : 0n0 +0x028 PushLock : _EX_PUSH_LOCK +0x030 u : \u0026lt;anonymous-tag\u0026gt; +0x034 u1 : \u0026lt;anonymous-tag\u0026gt; +0x038 EventList : (null) 其中的__MMVAD_SHORT的前三个其实是union, 代表了下一个vad节点的地址, NextVad是左子树, ExtraCreateInfo是右子树\nStartingVpn, EndingVpn, StartingVpnHigh, StartingVpnHigh可以看一下MiLocateAddress的写法, win10会和win7有不同, 计算方式为(result-\u0026gt;Core.StartingVpn | ((unsigned __int64)result-\u0026gt;Core.StartingVpnHigh \u0026lt;\u0026lt; 32))和(result-\u0026gt;Core.EndingVpn | ((unsigned __int64)result-\u0026gt;Core.EndingVpnHigh \u0026lt;\u0026lt; 32)) 在_MMVAD_SHORT结构里有一项是u-\u0026gt;_MMVAD_FLAGS结构, 其中的PrivateMemory代表了这里是不是私有内存, Protection代表了属性是多少, vadtype用于标记这段虚拟内存的用途或分配方式 看一下这个vadtype\n值（十进制） 名称 含义说明 0 VadNone 未指定类型（保留） 1 VadDevicePhysicalMemory 映射的物理设备内存 2 VadImageMap 映像（如 EXE、DLL 文件）映射 3 VadAwe 使用 AWE（Address Windowing Extensions）分配的内存 4 VadWriteWatch 启用了写监视（Write-Watch）的内存，用于检测哪些页面被写入 5 VadLargePages 使用大页（Large Pages）分配的内存 6 VadRotatePhysical 映射旋转的物理内存（罕见） 7 VadLargePageSection 段式大页分配（仅在某些版本支持） 看一下这个Protection, 看一下NtAllocateVirtualMemory这个函数里关于Protection的字段可以很好的定位到MiMakeProtectionMask这个函数\n看一下这个函数, 可以发现他把这个申请的内存属性分成了两个属性, 也刚好的在两个表中\n我们可以举一个例子, 假设是PAGE_EXECUTE_READWRITE = 0x40\n那么根据代码的逻辑, 他会被分成两个部分, 0100 0000一个是4一个是0, 那么就会在这个表中找一下, 因为第一个是0所以要直接在第二个表中找一下属性, 可以看到数组的第五个刚好是MM_EXECUTE_READWRITE 所以我们上面内存这个位置是0x4, 所以属性就是MM_READWRITE\n写了三个功能:\n1.打开IDA分析内核MiLocateAddress这个函数, 给一个R3地址, 返回一个VAD节点\n2.给一个进程ID, 解析出此进程的所有VAD节点\n3.移除内存所在vad节点的位置\n#include \u0026#34;struct.h\u0026#34; void RtlAvlRemoveNode(PVOID tree, PVOID node); PEPROCESS LookUpProcess(HANDLE Pid) { PEPROCESS eprocess = NULL; NTSTATUS Status = STATUS_UNSUCCESSFUL; Status = PsLookupProcessByProcessId(Pid, \u0026amp;eprocess); if (NT_SUCCESS(Status)) return eprocess; return NULL; } ULONG64 GetVadOffset() { UNICODE_STRING func; RtlInitUnicodeString(\u0026amp;func, L\u0026#34;PsGetProcessExitStatus\u0026#34;); ULONG64 funcAddr = MmGetSystemRoutineAddress(\u0026amp;func); if (funcAddr == NULL) { return FALSE; } //8B 81 D4 07 00 00 mov eax, [rcx+7D4h] PUCHAR funcBytes = (PUCHAR)funcAddr; //DbgPrint(\u0026#34;funcAddr : %p\\n\u0026#34;, funcAddr); //DbgPrint(\u0026#34;funcBytes : %p\\n\u0026#34;, funcBytes); for (size_t i = 0; i \u0026lt; 0x10; i++) { if (funcBytes[0] == 0x8B \u0026amp;\u0026amp; funcBytes[1] == 0x81) { UINT32 offset = *(UINT32*)(funcBytes + 2); return offset + 0x4; } } return FALSE; } PMMVAD MiLocateAddress(PEPROCESS eProcess, ULONG64 virtualAddress) { PRTL_AVL_TREE vadRoot = (PRTL_AVL_TREE)((PUCHAR)eProcess + GetVadOffset()); if (!vadRoot || !vadRoot-\u0026gt;Root) { return NULL; // VAD tree is empty or invalid } PMMVAD vad = (PMMVAD)vadRoot-\u0026gt;Root; if (!MmIsAddressValid(vad)) { return NULL; } ULONG64 address = virtualAddress \u0026gt;\u0026gt; 12; if (address \u0026lt; (vad-\u0026gt;Core.StartingVpn | (vad-\u0026gt;Core.StartingVpnHigh \u0026lt;\u0026lt; 32)) || address \u0026gt;(vad-\u0026gt;Core.EndingVpn | (vad-\u0026gt;Core.EndingVpn \u0026lt;\u0026lt; 32))) { while (vad) { if (address \u0026gt; (vad-\u0026gt;Core.EndingVpn | (vad-\u0026gt;Core.EndingVpnHigh \u0026lt;\u0026lt; 32))) { vad = (PMMVAD)vad-\u0026gt;Core.VadNode.Right; } else { if (address \u0026gt;= (vad-\u0026gt;Core.StartingVpn | (vad-\u0026gt;Core.StartingVpnHigh \u0026lt;\u0026lt; 32))) { return vad; } vad = (PMMVAD)vad-\u0026gt;Core.VadNode.Left; } } } return NULL; } PVOID EnumVad(PMMVAD vad) { if (!vad) { return NULL; } PVOID stack[256]; int stackIndex = 0; stack[stackIndex++] = vad; while (stackIndex \u0026gt; 0) { PMMVAD currentVad = (PMMVAD)stack[--stackIndex]; DbgPrintEx(77, 0, \u0026#34;Vad: %p | start : %x | end : %x | vadflags : %x \\n\u0026#34;, currentVad, currentVad-\u0026gt;Core.StartingVpn, currentVad-\u0026gt;Core.EndingVpn, currentVad-\u0026gt;Core.u.VadFlags); if (currentVad-\u0026gt;Core.VadNode.Right) { stack[stackIndex++] = (PVOID)currentVad-\u0026gt;Core.VadNode.Right; } if (currentVad-\u0026gt;Core.VadNode.Left) { stack[stackIndex++] = (PVOID)currentVad-\u0026gt;Core.VadNode.Left; } } return NULL; } PVOID ParserProcessVad(PEPROCESS eProcess) { PRTL_AVL_TREE vadRoot = (PRTL_AVL_TREE)((PUCHAR)eProcess + GetVadOffset()); if (!vadRoot || !vadRoot-\u0026gt;Root) { return NULL; // VAD tree is empty or invalid } ULONG64 vadCount = *(PULONG64)((PUCHAR)eProcess + GetVadOffset() + 0x10); PMMVAD vad = (PMMVAD)vadRoot-\u0026gt;Root; if (!MmIsAddressValid(vad)) { return NULL; } EnumVad(vad); } PVOID LockPageProction(PEPROCESS eProcess, ULONG64 virtualaddress, PMMVAD vad) { } PVOID RemoveVad(PEPROCESS eProcess, ULONG64 virtualaddress) { PMMVAD vad = MiLocateAddress(eProcess, virtualaddress); if (!MmIsAddressValid(vad)) { return NULL; } PRTL_AVL_TREE vadRoot = (PRTL_AVL_TREE)((PUCHAR)eProcess + GetVadOffset()); if (!vadRoot || !vadRoot-\u0026gt;Root) { return NULL; } RtlAvlRemoveNode(vadRoot, vad); ObReferenceObject(eProcess); } PVOID UnloadDriver( _In_ PDRIVER_OBJECT DriverObject ) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(77, 0, \u0026#34;Driver unloaded successfully.\\n\u0026#34;); return STATUS_SUCCESS; } NTSTATUS DriverEntry( _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath ) { UNREFERENCED_PARAMETER(RegistryPath); DbgPrintEx(77, 0, \u0026#34;Driver loaded successfully.\\n\u0026#34;); //1. 分析内核 MiLocateAddress 这个函数，然后照抄此判断是: 给一个R3地址，返回一个VAD 节点 //2. 给一个进程ID，解析出此进程的所有VAD节点 //3. 代码实现WIN10 WIN11 私有内存锁页 //4. 移除内存所在vad节点的位置 //DbgBreakPoint(); PEPROCESS eproc = NULL; eproc = LookUpProcess(0x16c8); if (!eproc) { return STATUS_UNSUCCESSFUL; } UINT32 vadOffset = GetVadOffset(); if (!vadOffset) { return STATUS_UNSUCCESSFUL; } //1: over PMMVAD vad = MiLocateAddress(eproc, 0xDCE0000); DbgPrintEx(77, 0, \u0026#34;Find Vad: %p\\n\u0026#34;, vad); /* +0x658 VadRoot : _RTL_AVL_TREE +0x660 VadHint : 0xffffce01`8de7d9a0 Void +0x668 VadCount : 0xaa +0x670 VadPhysicalPages : 0 +0x678 VadPhysicalPagesLimit : 0 */ //vadRoot是根节点, vadHint是上一次MiLocateAddress找到的指针, vadCount是vad的数量 //2: over ParserProcessVad(eproc); //3. over RemoveVad(eproc, 0xDCE0000); ObDereferenceObject(eproc); DriverObject-\u0026gt;DriverUnload = UnloadDriver; return STATUS_SUCCESS; } VAD映射内存 Win10锁页 插入一个锁页的知识点, win10和win7有差别, 主要还是看win10, 直接看一下MmProtectVirtualMemory这个函数, 可以看到如果满足这两个逻辑的话, 就会返回失败\n测试一个, 用CE申请了一块内存, 看一下对应的 +0x30的位置, 因为上面的\u0026amp; 0x3F800可以用不用考虑, 因为这个参数可以用的属性加起来也不会超过0x800所以这里为0, 那么我们让这个位置 Core.u.LongFlags \u0026amp; 0x1100000 == 0x1100000 就可以了\n可以发现Graphics: 0y1 PrivateMemoryAlwaysSet: 0y1这个两个位置为1即可\n代码实现:\nPVOID LockVadProction(PEPROCESS eProcess, ULONG64 virtualaddress) { PMMVAD_SHORT vad = MiLocateAddress(eProcess, virtualaddress); if (!MmIsAddressValid(vad)) { return NULL; } vad-\u0026gt;u.PrivateVadFlags.Graphics = 0x1; vad-\u0026gt;u.PrivateVadFlags.PrivateMemoryAlwaysSet = 0x1; } 这样这个内存的页就不能被修改属性了\n映射内存 找一个map的内存看一下, MMVAD_SHORT的结构\nX64页表 页表自映射 页帧\n物理页是有一个地方去管理，管理的时候用的是数组，没有用链表，因为数组的查找很快，因为物理地址是频繁运行，所以必须有一个很快的算法 有一个这样的数组叫做：mmpfndatabase, 数组里的每一个元素都是mmpfn结构,\n数组的索引, pte的页帧 \u0026mdash;\u0026gt; 某些属性 + 页帧 + 属性\nmmpfndatabase[pte.页帧]\nx64分页\nx64 获取PTEbase\n#include \u0026lt;ntifs.h\u0026gt; ULONG64 g_PteAddress = 0; ULONG64 g_PdeAddress = 0; ULONG64 g_PpeAddress = 0; ULONG64 g_PxeAddress = 0; ULONG64 GetPteAddress(ULONG64 Address) { return (ULONG64)(((Address \u0026gt;\u0026gt; 9) \u0026amp; 0x7FFFFFFFF8) + g_PteAddress); } ULONG64 GetPdeAddress(ULONG64 Address) { return (ULONG64)(((Address \u0026gt;\u0026gt; 9) \u0026amp; 0x7FFFFFFFF8) + g_PteAddress); } ULONG64 GetPpeAddress(ULONG64 Address) { return (ULONG64)(((Address \u0026gt;\u0026gt; 9) \u0026amp; 0x7FFFFFFFF8) + g_PteAddress); } ULONG64 GetPxeAddress(ULONG64 Address) { return (ULONG64)(((Address \u0026gt;\u0026gt; 9) \u0026amp; 0x7FFFFFFFF8) + g_PteAddress); } VOID GetFourTableBASE() { ULONG64 DirectoryTableBase = *(PULONG64)((PUCHAR)PsInitialSystemProcess + 0x28); //后12位属性 DirectoryTableBase \u0026amp;= ~0xFFF; PHYSICAL_ADDRESS address; address.QuadPart = DirectoryTableBase; PULONG64 VirtualDirectorBase = MmGetVirtualForPhysical(address); ULONG64 index = -1; for (size_t i = 0; i \u0026lt; 512; i++) { ULONG64 data = VirtualDirectorBase[i]; //8000 0000001aa063 //48 0xFFFFFFFFFFFF //ULONG64 testData = ((data \u0026amp; ~0xFFF) \u0026amp; 0xFFFFFFFFFFFF); if (DirectoryTableBase == ((data \u0026amp; ~0xFFF) \u0026amp; 0xFFFFFFFFFFFF)) { index = i; break; } } if (index != -1) { g_PteAddress = (index + 0x1FFFE00) \u0026lt;\u0026lt; 39; g_PdeAddress = (index \u0026lt;\u0026lt; 30) + g_PteAddress; g_PpeAddress = (index \u0026lt;\u0026lt; 21) + g_PdeAddress; g_PxeAddress = (index \u0026lt;\u0026lt; 12) + g_PpeAddress; } } VOID DriverUnload(PDRIVER_OBJECT pDriver) { } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pSeg) { //1. 获取pte的基址 （ MmGetVirtualForPhysical ） //2. 解析 返回PTE PDE PDPTE PML4的地址 ( MmIsAddressValidEx ) //1. over DbgBreakPoint(); GetFourTableBASE(); if (g_PteAddress != NULL) { DbgPrintEx(77, 0, \u0026#34;PTEBASE: %p\\n\u0026#34;, g_PteAddress); DbgPrintEx(77, 0, \u0026#34;PDEBASE: %p\\n\u0026#34;, g_PdeAddress); DbgPrintEx(77, 0, \u0026#34;PPEBASE: %p\\n\u0026#34;, g_PpeAddress); DbgPrintEx(77, 0, \u0026#34;PXEBASE: %p\\n\u0026#34;, g_PxeAddress); } else { DbgPrintEx(77, 0, \u0026#34;ERROR\\n\u0026#34;); } //2. over ULONG64 gdtr = 0xfffff80258bc4fb0; ULONG64 gdtrPte = GetPteAddress(gdtr); ULONG64 gdtrPde = GetPdeAddress(gdtrPte); ULONG64 gdtrPpe = GetPpeAddress(gdtrPde); ULONG64 gdtrPxe = GetPxeAddress(gdtrPpe); DbgPrintEx(77, 0, \u0026#34;gdtrPte: %p\\n\u0026#34;, gdtrPte); DbgPrintEx(77, 0, \u0026#34;gdtrPde: %p\\n\u0026#34;, gdtrPde); DbgPrintEx(77, 0, \u0026#34;gdtrPpe: %p\\n\u0026#34;, gdtrPpe); DbgPrintEx(77, 0, \u0026#34;gdtrPxe: %p\\n\u0026#34;, gdtrPxe); pDriver-\u0026gt;DriverUnload = DriverUnload; return STATUS_SUCCESS; } PTE的原型 原型PTE本质上就是我们PTE的生命周期\n我们的dll还有exe是多个进程共用一个文件的存在，重新创建一个进程跑起来，还是会使用dll，\nallocatememory 当我们申请内存的时候，如果一次都没有访问过，是一个没有挂物理页的虚拟地址，当我们访问一下的时候，此时回给他挂上物理页\n上面的四种当我们申请内存的时候有可能是空的, d的表述, 此时申请完，我们去访问的时候，会发生页异常错误，抛给14号中断，判断是用户态模式还是内核态的模式，内核态的话直接就蓝屏，因为内核态模式是没有vad的，在用户态还要去检测一下有没有vad，如果在vad中，而且保护属性不是noaccess的话，其他的页属性的话会进一步的去给他挂物理页然后去修复\n","permalink":"https://l0x1c.com/posts/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","summary":"VAD_私有内存 私有内存 像malloc, virtualalloc申请的内存都是私有内存, MapViewofFile, MapViewOfSize, mdl, 这种是映射的内存\n这些内存是由一个叫做vadroot的节点来管理的, 可以看一下这个位置 这里如果后续想获取到这个位置的话, 因为每个版本的偏移可能不一样, 可以通过函数PsGetProcessExitStatus来获取对应的偏移 + 4就是vadRoot win10上的结构\n+0x658 VadRoot : _RTL_AVL_TREE +0x660 VadHint : 0xffff900f`4bf43e10 Void +0x668 VadCount : 0xde VadRoot: _RTL_AVL_TREE 里面就是代表了二叉搜索树的节点, 而里面的每个节点的结构都是__MMVAD的结构, VadHint多次查询的节点会放在这里, VadCount代表vad节点的个数\nkd\u0026gt; dt _RTL_AVL_TREE ffff900f4c129400+0x658 nt!_RTL_AVL_TREE +0x000 Root : 0xffff900f`4bf44810 _RTL_BALANCED_NODE kd\u0026gt; dt 0xffff900f`4bf44810 _RTL_BALANCED_NODE nt!_RTL_BALANCED_NODE +0x000 Children : [2] 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE +0x000 Left : 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE +0x008 Right : 0xffff900f`4bfe65c0 _RTL_BALANCED_NODE +0x010 Red : 0y0 +0x010 Balance : 0y00 +0x010 ParentValue : 0 !","title":"内存管理"},{"content":"这周主要看了一下minifilter的东西, 网吧, 杀软, 反作弊都会相应的用到这个\nminifilter_Nt启动 ","permalink":"https://l0x1c.com/posts/minifilter/","summary":"这周主要看了一下minifilter的东西, 网吧, 杀软, 反作弊都会相应的用到这个\nminifilter_Nt启动 ","title":"minifilter"},{"content":"很久没打ctf了, 正好碰见周末有一点空, 就看了一下d3ctf和windows相关的题目\nlocked-door 加的是vmp的壳子, 需要调试的话直接用TitanHide - \u0026gt; https://github.com/mrexodia/TitanHide就可以调试起来, download后自行加个签名即可, 发现题目有两个bin文件, 直接可以得到的思路是先dump, 因为一定要读取文件一定会调用readfile, 所以可以根据回溯找到关键位置进行调试 通过readfile回溯已经找到了关键位置, 然后用过函数特征入口点来dump, 正常编程的也就那几个软件, 这个问题在之前我发过看雪的文章可以看一下, 可以看到这里很像入口点了, 看一个正常vs编译出来的程序 比较后可以看很像入口点的位置, 直接dump设置oep, 这样dump后的逻辑就很清晰了 可以看到一个算法, 本身程序对他们的校验的算法是一样的 加密完的数据进行evp的校验 校验过了后才可以走到正确的流程, 参数是key+加密的bin里的data, 那直接替换一下, 就可以得到flag了 d3rpg-revenge 这是一个游戏, 正好我是一个游戏安全的从业者, 直接打开ce开始干, 进入一个房间后, 他让我输入密码, 那么可以对密码的位置进行访问断点, 可以看到可以被很好的断下来 d3rpg.dll+50DEA这里的地址, 这个字符串很可疑, 去搜一下 module Scene_RPG class Secret_Class DELTA = | (($de1ta + 1) * 0xf0000000) def initialize(new_key) @key = str_to_longs(new_key) if @key.length \u0026lt; 4 @key.length.upto(4) { |i| @key[i] = 0 } end end def self.str_to_longs(s, include_count = false) s = s.dup length = s.length ((4 - s.length % 4) \u0026amp; 3).times { s \u0026lt;\u0026lt; \u0026#34;\\0\u0026#34; } unpacked = s.unpack(\u0026#39;V*\u0026#39;).collect { |n| int32 n } unpacked \u0026lt;\u0026lt; length if include_count unpacked end def str_to_longs(s, include_count = false) self.class.str_to_longs s, include_count end def self.longs_to_str(l, count_included = false) s = l.pack(\u0026#39;V*\u0026#39;) s = s[0...(l[-1])] if count_included s end def longs_to_str(l, count_included = false) self.class.longs_to_str l, count_included end def self.int32(n) n -= 4_294_967_296 while (n \u0026gt;= 2_147_483_648) n += 4_294_967_296 while (n \u0026lt;= -2_147_483_648) n.to_i end def int32(n) self.class.int32 n end def mx(z, y, sum, p, e) int32( ((z \u0026gt;\u0026gt; 5 \u0026amp; 0x07FFFFFF) ^ (y \u0026lt;\u0026lt; 2)) + ((y \u0026gt;\u0026gt; 3 \u0026amp; 0x1FFFFFFF) ^ (z \u0026lt;\u0026lt; 4)) ) ^ int32((sum ^ y) + (@key[(p \u0026amp; 3) ^ e] ^ z)) end def self.encrypt(key, plaintext) self.new(key).encrypt(plaintext) end def encrypt(plaintext) return \u0026#39;\u0026#39; if plaintext.length == 0 v = str_to_longs(plaintext, true) v[1] = 0 if v.length == 1 n = v.length - 1 z = v[n] y = v[0] q = (6 + 52 / (n + 1)).floor sum = $de1ta * DELTA p = 0 while(0 \u0026lt;= (q -= 1)) do sum = int32(sum + DELTA) e = sum \u0026gt;\u0026gt; 2 \u0026amp; 3 n.times do |i| y = v[i + 1]; z = v[i] = int32(v[i] + mx(z, y, sum, i, e)) p = i end p += 1 y = v[0]; z = v[p] = int32(v[p] + mx(z, y, sum, p, e)) end longs_to_str(v).unpack(\u0026#39;a*\u0026#39;).pack(\u0026#39;m\u0026#39;).delete(\u0026#34;\\n\u0026#34;) end def self.decrypt(key, ciphertext) self.new(key).decrypt(ciphertext) end end end def validate_flag(input_flag) c_flag = input_flag + \u0026#34;\\0\u0026#34; result = $check_flag.call(c_flag) result == 1 end def check flag = $game_party.actors[0].name key = Scene_RPG::Secret_Class.new(\u0026#39;rpgmakerxp_D3CTF\u0026#39;) cyphertext = key.encrypt(flag) if validate_flag(cyphertext) $game_variables[1] = 100 else $game_variables[1] = 0 end end def check1 flag = $game_party.actors[0].name if flag == \u0026#34;ImPsw\u0026#34; $game_variables[2] = 100 else $game_variables[2] = 0 end end 直接写python解密即可\nfrom regadgets import * data = decode_b64(\u0026#39;LhVvfepywFIsHb8G8kNdu49J3k0=\u0026#39;) key = b\u0026#39;rpgmakerxp_D3CTF\u0026#39; #xxtea decode data = xxtea_decrypt(data, key, delta=0xf1919810) print(data) #Y0u_R_RPG_M4st3r ","permalink":"https://l0x1c.com/posts/d3ctf_writeup/","summary":"很久没打ctf了, 正好碰见周末有一点空, 就看了一下d3ctf和windows相关的题目\nlocked-door 加的是vmp的壳子, 需要调试的话直接用TitanHide - \u0026gt; https://github.com/mrexodia/TitanHide就可以调试起来, download后自行加个签名即可, 发现题目有两个bin文件, 直接可以得到的思路是先dump, 因为一定要读取文件一定会调用readfile, 所以可以根据回溯找到关键位置进行调试 通过readfile回溯已经找到了关键位置, 然后用过函数特征入口点来dump, 正常编程的也就那几个软件, 这个问题在之前我发过看雪的文章可以看一下, 可以看到这里很像入口点了, 看一个正常vs编译出来的程序 比较后可以看很像入口点的位置, 直接dump设置oep, 这样dump后的逻辑就很清晰了 可以看到一个算法, 本身程序对他们的校验的算法是一样的 加密完的数据进行evp的校验 校验过了后才可以走到正确的流程, 参数是key+加密的bin里的data, 那直接替换一下, 就可以得到flag了 d3rpg-revenge 这是一个游戏, 正好我是一个游戏安全的从业者, 直接打开ce开始干, 进入一个房间后, 他让我输入密码, 那么可以对密码的位置进行访问断点, 可以看到可以被很好的断下来 d3rpg.dll+50DEA这里的地址, 这个字符串很可疑, 去搜一下 module Scene_RPG class Secret_Class DELTA = | (($de1ta + 1) * 0xf0000000) def initialize(new_key) @key = str_to_longs(new_key) if @key.length \u0026lt; 4 @key.length.upto(4) { |i| @key[i] = 0 } end end def self.","title":"D3CTF-WriteUp"},{"content":"初步分析 分析到一个E语言的外挂, 但是说的是过检测的外挂, 分析一下, 直接ida一把梭大概看到有用的信息, 内部测试3-A.exe explorer.exe 打开外挂后看到的功能大概有这几个, 加载过检, 开始过检, 伪装进程, 隐藏进程这几个, 大概就能猜到肯定用到了驱动 跑起来后, 第一个功能是开始过检测, 发现修改了R3层的应用层访问的状态为拒绝 直接打开process explorer, 可以发现进程的Protection属性变成了PsProtectedSignerWinTcb-Light, 这里的保护和今年的腾讯游戏安全初赛的那个是一样的PPL 直接windbg看一下进程的EPROCESS结构, 可以看到Protection为0x61 -\u0026gt; 0110 0001b, 可以看到修改的为PsProtectedTypeProtectedLight,PsProtectedSignerWinTcb\n//进程保护类型 typedef enum _PS_PROTECTED_TYPE { PsProtectedTypeNone = 0, PsProtectedTypeProtectedLight = 1, PsProtectedTypeProtected = 2 } PS_PROTECTED_TYPE, *PPS_PROTECTED_TYPE; //Audit 审计标志（很少使用） //Signer 签名了进程 typedef enum _PS_PROTECTED_SIGNER { PsProtectedSignerNone = 0, PsProtectedSignerAuthenticode, PsProtectedSignerCodeGen, PsProtectedSignerAntimalware, PsProtectedSignerLsa, PsProtectedSignerWindows, PsProtectedSignerWinTcb, PsProtectedSignerWinSystem, PsProtectedSignerApp, PsProtectedSignerMax } PS_PROTECTED_SIGNER, *PPS_PROTECTED_SIGNER; 直接把这个位置修改为0即可\nCmRegisterCallback 直接开始分析一下这个东西具体都干什么了吧, 可以打开了解到这个是一个E语言的东西, 并且他一定是有一个通信码在和什么东西通信的, 因为有一个点击事件, 直接ida开始分析, 打开后直接可以看到了一个地址，R3反正也是通信做的, 大部分功能应该是在驱动里，直接去驱动分析看一下 发现直接download可以的, 发现这个东西在疯狂套娃, ExAllocatePoolWithTag后创建一个系统线程, 线程的入口点就是申请的内存的位置, 由这个sys中藏的一个PE的oep的位置开始执行 直接双机调试开始搞一下, 还是老地方ioploaddriver, 直接下断释放的函数可以看到这个位置是一个PE 在StartRoutine下断看一下主要在做什么 经过分析后, 可以分析到它通过设置CmRegisterCallback注册表回调, 把代码放在这里开始执行用于隐藏自己的驱动代码 分析BE的时候发现实际上是有对这种情况进行检测的, BE中分别对进程线程回调, 以及注册表回调判断回调函数的其实位置是不是被hook, 是不是jmp reg的跳转来判断是不是有问题 直接打开BE逆向发现他取了CmUnRegisterCallback的特征, 因为这里存有相应的表, 里面存放了相对的地址和cookie\nlea rdx, [rsp+38h] lea rcx, [ntkrnlmp!CallbackListHead (fffff8015ea60920)] 直接跑通, 写个代码测试一下可不可以找到相应的位置\n#include \u0026lt;ntddk.h\u0026gt; PVOID GetCmCallbackListHead() { UNICODE_STRING ustr; RtlInitUnicodeString(\u0026amp;ustr, L\u0026#34;CmUnRegisterCallback\u0026#34;); PUCHAR pBase = (PUCHAR)MmGetSystemRoutineAddress(\u0026amp;ustr); if (!pBase) return NULL; for (PUCHAR p = pBase; p \u0026lt; pBase + 0x1000; ++p) { if (!MmIsAddressValid(p) || !MmIsAddressValid(p + 6)) continue; if (p[0] == 0x48 \u0026amp;\u0026amp; p[1] == 0x8D \u0026amp;\u0026amp; p[2] == 0x0D \u0026amp;\u0026amp; p[-5] == 0x48 \u0026amp;\u0026amp; p[-4] == 0x8D \u0026amp;\u0026amp; p[-3] == 0x54) { INT32 disp = *(INT32*)(p + 3); UINT64 off = 0; if (disp \u0026lt;= 0) off = (UINT32)disp | 0xFFFFFFFF00000000ull; else off = (UINT32)disp; PUCHAR pListHead = p + off + 7; if (MmIsAddressValid(pListHead)) return pListHead; } } return NULL; } extern USHORT NtBuildNumber; void DumpCmRegisterCallback() { PVOID pListHead = GetCmCallbackListHead(); //DbgBreakPoint(); if (!pListHead) { DbgPrint(\u0026#34;[-] CallbackListHead not found!\\n\u0026#34;); return; } char* Head = (char*)pListHead; char* Entry = *(char**)Head; int idx = 0; ULONG_PTR Offset = 8; // Win7 SP1及以上偏移 if (NtBuildNumber \u0026lt;= 7600) Offset = 0; // Win7 RTM及以下偏移 while (Entry \u0026amp;\u0026amp; Entry != Head \u0026amp;\u0026amp; MmIsAddressValid(Entry)) { char* p = Entry + Offset; ULONGLONG CallbackAddr = *((ULONGLONG*)p + 5); ULONGLONG Cookie = *((ULONGLONG*)p + 3); if (CallbackAddr \u0026gt;= 0x8000000000000000ull \u0026amp;\u0026amp; MmIsAddressValid((PVOID)CallbackAddr)) DbgPrint(\u0026#34;[CMCallback %d] Callback: %p Cookie: %llx\\n\u0026#34;, idx, (PVOID)CallbackAddr, Cookie); Entry = *(char**)Entry; if (++idx \u0026gt; 64) break; // 防止死循环 } } VOID DriverUnload(PDRIVER_OBJECT pDriver) { DbgPrint(\u0026#34;Unload called!\\n\u0026#34;); } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { DbgPrint(\u0026#34;Driver Loaded\\n\u0026#34;); pDriver-\u0026gt;DriverUnload = DriverUnload; //DbgBreakPoint(); DumpCmRegisterCallback(); return STATUS_SUCCESS; } 可以找到相应的位置, 这里的check的就是模块的头部是jmp reg, 并且reg过去的地址是无模块地址 相应的BE的检测的伪代码 开始过检按钮 相应的回调的位置的check已经可以搞定, 继续分析点击过检测的时候一定会和驱动层进行通信, 直接在这个位置下断即可 点击开始过检, 可以知道流程为控制码0822 -\u0026gt; 0814, 调试可以知道这里通过获取到Protection的offset获取的分别是自己本身的程序和smss.exe的Protection属性进行了交换\nPROCESS ffffc081d05ab080 SessionId: 1 Cid: 1010 Peb: e9f5789000 ParentCid: 0e34 DirBase: 1406a002 ObjectTable: ffff9d8e2a8f2c80 HandleCount: 47. Image: A.exe PROCESS ffffc081cd7634c0 SessionId: none Cid: 0208 Peb: 843a07b000 ParentCid: 0004 DirBase: 136b7b002 ObjectTable: ffff9d8e1f3768c0 HandleCount: 53. Image: smss.exe 因为smss.exe的EPROCESS他获取了后, 可以拿到该进程的保护属性和父进程的pid, 第二个操作就是交换了父进程的pid, 可以看到InheritedFromUniqueProcessId等于了4 取消就是explorer.exe的ParentCid和Protection赋值给了该被保护的程序 伪装进程按钮 获取自身和另一个进程的名字, 把名字复制到被保护的进程里 可以看到名字已经被修改成了explorer.exe 主要这个模块处理了很多peb里的信息这里省略一下有点多, github有一个比较好的项目很像这个模块https://github.com/zhuhuibeishadiao/PathModification\n进程隐藏按钮 发现比较有趣的事情, 好像ydark还是可以扫描到这个被隐藏的进程, 但是任务管理器的没了 看一下他是怎么做的, 他直接把+0x2e8 UniqueProcessId : (null)清空了, 所以任务管理器看不见 但是ydark为什么能看见, 研究了一下是通过句柄表来做的进程的遍历, 可以使用PspCidTable来做这个事情\n遍历PspCidTable枚举进程 PspCidTable这个位置需要通过特征码匹配来看一下是什么值 通过PsLookupProcessByProcessId的E8 call获取到地址后, 直接dq看一下, 这里大概说一下思路和找寻的方法, 代码就不贴了 dq pspcidtable获取了表的地址后, 实际上的类型是_HANDLE_TABLE类型, 可以看到tablecode的低两位代表句柄表的层数, 最多有三层 随便进一个看一下, 可以看到是加密的情况 win10的解密是\u0026gt;\u0026gt; 0x10 \u0026amp; 0xfffffffffffffff0 解密后看一下EPROCESS, 发现是第一个的system 通过这个就可以遍历出id和对应的object, 但是如果要遍历进程的, 还要进行筛选需要知道一个东西叫做OBJECT_TYPE和OBJECT_HEADER, 实际上OBJECT_HEADER是在EPROCESS结构上面的\nkd\u0026gt; dt _OBJECT_HEADER nt!_OBJECT_HEADER +0x000 PointerCount : Int8B +0x008 HandleCount : Int8B +0x008 NextToFree : Ptr64 Void +0x010 Lock : _EX_PUSH_LOCK +0x018 TypeIndex : UChar +0x019 TraceFlags : UChar +0x019 DbgRefTrace : Pos 0, 1 Bit +0x019 DbgTracePermanent : Pos 1, 1 Bit +0x01a InfoMask : UChar +0x01b Flags : UChar +0x01b NewObject : Pos 0, 1 Bit +0x01b KernelObject : Pos 1, 1 Bit +0x01b KernelOnlyAccess : Pos 2, 1 Bit +0x01b ExclusiveObject : Pos 3, 1 Bit +0x01b PermanentObject : Pos 4, 1 Bit +0x01b DefaultSecurityQuota : Pos 5, 1 Bit +0x01b SingleHandleEntry : Pos 6, 1 Bit +0x01b DeletedInline : Pos 7, 1 Bit +0x01c Reserved : Uint4B +0x020 ObjectCreateInfo : Ptr64 _OBJECT_CREATE_INFORMATION +0x020 QuotaBlockCharged : Ptr64 Void +0x028 SecurityDescriptor : Ptr64 Void +0x030 Body : _QUAD 那么windbg看一下这个结构, 判断类型主要的还是这个TypeIndex 这里的解密可以看一下ObGetObjectType 那么实际上的解密就是0xfa ^ 0x8f ^ 0x72 = 0x7 按照这个思路写的代码效果如下: ","permalink":"https://l0x1c.com/posts/dg-pass_anti%E5%88%86%E6%9E%90/","summary":"初步分析 分析到一个E语言的外挂, 但是说的是过检测的外挂, 分析一下, 直接ida一把梭大概看到有用的信息, 内部测试3-A.exe explorer.exe 打开外挂后看到的功能大概有这几个, 加载过检, 开始过检, 伪装进程, 隐藏进程这几个, 大概就能猜到肯定用到了驱动 跑起来后, 第一个功能是开始过检测, 发现修改了R3层的应用层访问的状态为拒绝 直接打开process explorer, 可以发现进程的Protection属性变成了PsProtectedSignerWinTcb-Light, 这里的保护和今年的腾讯游戏安全初赛的那个是一样的PPL 直接windbg看一下进程的EPROCESS结构, 可以看到Protection为0x61 -\u0026gt; 0110 0001b, 可以看到修改的为PsProtectedTypeProtectedLight,PsProtectedSignerWinTcb\n//进程保护类型 typedef enum _PS_PROTECTED_TYPE { PsProtectedTypeNone = 0, PsProtectedTypeProtectedLight = 1, PsProtectedTypeProtected = 2 } PS_PROTECTED_TYPE, *PPS_PROTECTED_TYPE; //Audit 审计标志（很少使用） //Signer 签名了进程 typedef enum _PS_PROTECTED_SIGNER { PsProtectedSignerNone = 0, PsProtectedSignerAuthenticode, PsProtectedSignerCodeGen, PsProtectedSignerAntimalware, PsProtectedSignerLsa, PsProtectedSignerWindows, PsProtectedSignerWinTcb, PsProtectedSignerWinSystem, PsProtectedSignerApp, PsProtectedSignerMax } PS_PROTECTED_SIGNER, *PPS_PROTECTED_SIGNER; 直接把这个位置修改为0即可\nCmRegisterCallback 直接开始分析一下这个东西具体都干什么了吧, 可以打开了解到这个是一个E语言的东西, 并且他一定是有一个通信码在和什么东西通信的, 因为有一个点击事件, 直接ida开始分析, 打开后直接可以看到了一个地址，R3反正也是通信做的, 大部分功能应该是在驱动里，直接去驱动分析看一下 发现直接download可以的, 发现这个东西在疯狂套娃, ExAllocatePoolWithTag后创建一个系统线程, 线程的入口点就是申请的内存的位置, 由这个sys中藏的一个PE的oep的位置开始执行 直接双机调试开始搞一下, 还是老地方ioploaddriver, 直接下断释放的函数可以看到这个位置是一个PE 在StartRoutine下断看一下主要在做什么 经过分析后, 可以分析到它通过设置CmRegisterCallback注册表回调, 把代码放在这里开始执行用于隐藏自己的驱动代码 分析BE的时候发现实际上是有对这种情况进行检测的, BE中分别对进程线程回调, 以及注册表回调判断回调函数的其实位置是不是被hook, 是不是jmp reg的跳转来判断是不是有问题 直接打开BE逆向发现他取了CmUnRegisterCallback的特征, 因为这里存有相应的表, 里面存放了相对的地址和cookie","title":"关于CmRegisterCallback的检测/windows进程隐藏的问题"},{"content":"About Profile ctfer@W\u0026amp;M (Intern) Feiyu Security (2020.8 ~2020.9) (Intern) Virus Analysis Engineer@sangfor (2020.9 ~ 2021.5) Security Enginner@QiAnXin (2021.7 ~ 2024.1) Anti-cheat Engineer@Tencent GameSecurity Interest Cybersecurity Binary Play Game Contact L0x1c3r (at) gmail (dot) com\n","permalink":"https://l0x1c.com/about/","summary":"About Profile ctfer@W\u0026amp;M (Intern) Feiyu Security (2020.8 ~2020.9) (Intern) Virus Analysis Engineer@sangfor (2020.9 ~ 2021.5) Security Enginner@QiAnXin (2021.7 ~ 2024.1) Anti-cheat Engineer@Tencent GameSecurity Interest Cybersecurity Binary Play Game Contact L0x1c3r (at) gmail (dot) com","title":""}]