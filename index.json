[{"content":"xv6 环境配置问题 ( vmare or docker ) 配置的地址: https://pdos.csail.mit.edu/6.828/2020/tools.html 准备的系统： vmware + ubuntu\nvmare mit的实验代码:\ngit clone git://g.csail.mit.edu/xv6-labs-2020 git checkout util 这边遇见的坑大概网上都有解答，唯一的一个位置是，如果出现 user/sh.c:58:1: error 的问题修改代码\n加入__attribute__((noreturn)) 即可，后面直接目录下make qemu就可以启动了\n配置gdb调试也有点繁琐，主要就是在这个目录下进行 make qemu-gdb，新开一个窗口，那个窗口运行 gdb\n举个例子用sleep\n这样就可以调试了，具体的一些命令可以看：https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf https://xv6.dgs.zone/tranlate_books/Use%20GUN%20Debugger.html\ndocker 因为后面准备看csapp lab的适合还是得用到docker去配置环境，所以索性就直接学一下，后面就可以直接用了\n直接网上下载docker就可以\ndocker pull ubuntu docker run -i -t -w /root --name ubuntu ubuntu bash # 连接ubuntu系统 docker start -i ubuntu apt-get update apt-get install vim 需要换个源\nvim /etc/apt/source.list #替换 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 按照mit上面给的文档安装就行\nsudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu git clone git://g.csail.mit.edu/xv6-labs-2025 cd xv6-labs-2025 git checkout util make qemu 就可以安装成功了 需要配置一下ssh，后面和vscode联动的用的\n目录下创建一个makefile conn-docker: ssh -t root@localhost -p 20000 \u0026#34;cd xv6-labs-2025; bash\u0026#34; 配置ssh\napt-get install openssh-server vim /etc/ssh/sshd_config PermitRootLogin yes # 可以登录 root 用户 PubkeyAuthentication yes # 可以使用 ssh 公钥许可 AuthorizedKeysFile .ssh/authorized_keys # 公钥信息保存到文件 .ssh/authorized_keys 中 /etc/init.d/ssh restart 添加主机的 ssh 公钥\ndocker的ubuntu下 mkdir ~/.ssh touch ~/.ssh/authorized_keys mac下 ssh-keygen -t rsa cat id_rsa.pub 再把id_rsa.pub 的内容复制到 authorized_keys中 提交修改到镜像\ndocker ps -a docker commit -m \u0026#39;add ssh\u0026#39; -a \u0026#39;L0x1c\u0026#39; eacf5681c653 xv6-ssh docker image ls docker rm {没用的那个docker容器} 最终的docker容器\ndocker run -d -p 20000:22 --name xv6-lab xv6-ssh /usr/sbin/sshd -D 对应的vscode的配置就好很多了，安装ssh的那个插件配置一下就行\n就可以安心的改代码，看代码了\n进行gdb调试\ngdb-multiarch kernel/kernel # (gdb) 进入gdb后执行 set confirm off set architecture riscv:rv64 target remote localhost:25000 set riscv use-compressed-breakpoints yes 保存镜像到本地\ndocker export -o xv6-lab.rar xv6-labs ","permalink":"https://l0x1c.com/posts/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","summary":"xv6 环境配置问题 ( vmare or docker ) 配置的地址: https://pdos.csail.mit.edu/6.828/2020/tools.html 准备的系统： vmware + ubuntu\nvmare mit的实验代码:\ngit clone git://g.csail.mit.edu/xv6-labs-2020 git checkout util 这边遇见的坑大概网上都有解答，唯一的一个位置是，如果出现 user/sh.c:58:1: error 的问题修改代码\n加入__attribute__((noreturn)) 即可，后面直接目录下make qemu就可以启动了\n配置gdb调试也有点繁琐，主要就是在这个目录下进行 make qemu-gdb，新开一个窗口，那个窗口运行 gdb\n举个例子用sleep\n这样就可以调试了，具体的一些命令可以看：https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf https://xv6.dgs.zone/tranlate_books/Use%20GUN%20Debugger.html\ndocker 因为后面准备看csapp lab的适合还是得用到docker去配置环境，所以索性就直接学一下，后面就可以直接用了\n直接网上下载docker就可以\ndocker pull ubuntu docker run -i -t -w /root --name ubuntu ubuntu bash # 连接ubuntu系统 docker start -i ubuntu apt-get update apt-get install vim 需要换个源\nvim /etc/apt/source.list #替换 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.","title":"xv6 环境配置 vmare or docker"},{"content":"ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧\n主要的学习流程大概这两个：\n看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 \u0026amp; 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件 cemu 做辅助支持 : https://github.com/hugsy/cemu\n在ubuntu下面折腾了一下，感觉还行\n当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）\nAndroid studio \u0026amp; ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下\n安装完之后自己在 .zshrc 中配置一下环境变量\nexport ANDROID_HOME=\u0026#34;Android/sdk所在路径\u0026#34; export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了\n代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下\n进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}\n以后避免每次都打开 android studio可以用emulator里面命令来启动avd\n⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了\n配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发\n这样后ida attach就可以看到对应的进程那些了\nc编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en\n主要需要的是 Application.mk 和 Android.mk 这两个文件，现在写一个c然后编译一下试试\nAPP_ABI := arm64-v8a APP_BUILD_SCRIPT := Android.mk APP_PLATFORM := android-16 LOCAL_PATH := $(call my-dir) #LOCAL_ARM_MODE := arm LOCAL_MODULE := hello LOCAL_SRC_FILES := hello.c include $(BUILD_EXECUTABLE) 执行 ndk-build NDK_PROJECT_PATH=. NDK_APPLICATION_MK=Application.mk\n可以看到已经生成了，一个是debug版本的一个是release版本的，ida这样就可以开始调试起来了\n⚠️ 好像mac m1还没办法运行32位的，所以该文章主要都以64位为主，学的时候也是多学一下64位的毕竟是主流 ( 当然也可以先用32位的来做 )\n寄存器和指令基本格式 寄存器介绍 找了一台手机可以支持32位的，以及64位的，这样就可以都学一下了\n这次就可以32位调试起来了，可以很好看到32位的寄存器\narm32下一共有16个通用寄存器和一个状态寄存器\n其中r13叫做SP叫做栈指针寄存器相当于x86汇编中的esp LR叫做linker指针，当执行函数调用指令 BL func（Branch with Link）时，CPU 会自动把下一条指令的地址（PC + 4）写入 LR，并且跳转到 func 标签执行 BL func ; lr = pc + 4, 跳转到 func 函数如果想要返回的话 MOV PC, LR ; 回到调用点继续执行 如果函数内又调用了别的函数，LR 会被覆盖，所以通常编译器会 STMDB sp!, {LR} ; 保存返回地址 ... LDMIA sp!, {PC} ; 恢复并返回 PC (Program Counter) 里面存放的是当前的地址，对应x86里的eip PSR相当于x86中的eflag寄存器 可以看到arm手册里的介绍 对于PSR (当前程序状态寄存器) 这些位的介绍：\n位 名称 含义 说明 N (bit 31) Negative 结果为负 若算术结果为负，N=1 Z (bit 30) Zero 结果为零 若结果为 0，Z=1 C (bit 29) Carry 进位标志 加法进位或减法借位 V (bit 28) Overflow 溢出标志 有符号运算时溢出 ADD r0, r1, r2 ; CPSR.C 被设置为进位标志 SUBS r0, r1, r2 ; 带S的指令会更新 N Z C V 标志 27 位：Q（Saturation flag，饱和标志）\n用于 饱和运算（Saturating Arithmetic）指令，如 QADD、QDADD 当运算结果超出表示范围时，Q=1 可用 MSR CPSR_f, #0 或 MRS/MSR 指令清除或读取 26–25 位：IT[7:6]（If-Then 块标志）\n用于 Thumb 模式的 IT（If-Then）块控制 ITE EQ MOVEQ r0, #1 MOVNE r0, #0 #这时 CPSR 的 IT 位会被硬件自动设置与清空 19–16 位：GE[3:0]（Greater or Equal flags）\n用于 SIMD（多数据并行）中的比较结果标志（例如 UADD8, USUB8 等） 每一位对应 8 位操作结果是否大于等于 9 位：E（Endian bit）现在arm系统几乎都是小端的\nE = 0 → 小端（Little-endian） E = 1 → 大端（Big-endian） 5 位：T（Thumb state）\nT = 0 → ARM 模式（32 位指令） T = 1 → Thumb 模式（16 位指令） BX R0 ; 跳转到R0地址，并根据最低位决定T标志 # 如果 R0 的最低位为 1，会自动切换到 Thumb 模式 4–0 位：M[4:0]（处理器模式位）\n模式位（M4:M0） 模式名 权限 说明 10000 User 非特权 普通用户态 10001 FIQ 特权 快速中断 10010 IRQ 特权 普通中断 10011 Supervisor (SVC) 特权 系统调用 / 启动模式 10111 Abort 特权 内存访问异常 11011 Undefined 特权 未定义指令异常 11111 System 特权 特殊内核态 总体设计和指令规格 arm汇编中没有隐式内存操作指令\n这个怎么理解呢？ 可以这么来说，在x86汇编中有很多的隐式内存操作指令，比如push pop call，比如push这个指令，这个指令本身是没有内存的索引地址的，这个指令操作后会隐式的把esp指针的地址-4并且往其中写一个数，那么这个push这个指令就隐式的操作了内存，包括中断指令int 等等\narm汇编中，指令是 0 - 3个操作数，内存操作数和立即数操作数不能同时存在（因为 ARM 是典型的 load–store（取数-运算分离） 架构），内存操作数至多出现1次，寄存器操作数一般都是在前面\n这里大概理解了一下为什么内存操作数和立即操作数不能同时存在： 指令位数固定，要同时编码“访存寻址模式 + 数据算术的立即数/移位 + 寄存器号 + 条件码”，位不够用，解码也会变复杂，所以把复杂操作拆成两条简单指令，可以更好的乱序执行，把“访存”和“算术”拆开，硬件解码与执行更规整，单周期（或固定多周期）更容易保证；条件执行也更可控\n可以观察看到，左边的都是寄存器操作数，上面看到的LDR R6, [R6,#0xC]这种的属于两个操作数，后面的只是内存的一种索引模式 再比如：MOV.W R7, R9,LSR#12 这也是两个操作数，第二个R9,LSR#12这属于一个操作数\n读pc寄存器 在arm的这个汇编的情况中，pc寄存器属于那种正常的寄存器，可以对这个寄存器进行写，那么写到这个寄存器就相当于了指令跳转，写了个例子方便理解，可以看到跳过了地址是8的位置，直接到了c的地址\n读取pc寄存器有很多比较奇怪的行为，读取pc寄存器的时候，如果是arm模式会+8，thumb模式+4，因为ARM的流水线是为了性能优化设计的让CPU在执行当前指令的同时，已经把下一条、下下条都装载进指令缓存\n模式 指令长度 流水线深度 读取 PC 实际值 偏移原因 ARM 模式 4 字节 提前取两条 当前地址 + 8 三段流水线取指超前 Thumb 模式 2 字节 提前取一条 当前地址 + 4 指令短、取指周期短 ldr的指令读pc的内存也同理，可以看到后面的pc读取的数据pc被+8，然后读取8位置的值，所以pc寄存器只要有读的指令存在就是读的就是pc+8\n这里说一个问题就是ldr r0,[pc, #-4]\n但是比如你在ida调试那些环境下，那么读的就不是这个值了\n这里加一个小trips (关于ida安装keypatch): 这里我用了高版本的ida9.0，keypatch不支持：https://bbs.kanxue.com/thread-286591.htm#msg_header_h3_4\n编译之前看一下自己ida的架构，然后编译的keystone的dylib要对应上\n就可以用了\n继续回到主题！调试环境下的为什么不是这个值，我们看一下 这里我写的是 ldr r0, [pc, #-4]，ida帮我们优化了一下可以直接看到地址，之前说的pc寄存器遇见读的指令pc在arm模式下会+8，由于我-4了，所以应该是pc+4，读到的值r0应该是912fff1e\n我们现在看一下，读取到底是什么值，可以看到读取的是E7F001F0，这个是什么呢，我在下面硬编码改了一下，发现时UND #10，这个是什么？！\n网上查了一下，这个值都和反调试有关系，那么可以理解为，这里相当于读的断点的中断指令，类似于x86中f8的int 3，相当于单步的时候会有一个信号，信号呢被调试器捕获，然后ida捕获到异常，然后进行处理\nthumb模式下：\n先看第一个指令ldr r0,[pc] 这个在thumb模式下是pc + 4的地址读取出来\n可以看到又读了一个中断 DE10\n但是这里有疑问了，不是pc+4吗，继续往下看下面的两个都是e4的那个，就可以知道了，其实是有地址对齐的问题存在，所以才会两个条指令都是相同的pc+4但是对应的地址是一样的情况，所以thumb模式下还需要对齐，可以总结规律thumb模式下ldr reg,[pc]的pc地址是要 pc - pc % 4\n看一下公式准不准确用上面的d6的地址做一下对应的计算，可以看到是d8\n这种的东西在arm模式下不考虑，因为arm模式下都是4字节的，所以都是对齐的情况\n条件和标志位响应 Trips:（大部分的指令的说明都在arm手册的F5.1 以及 C6.2下）可以自己没事的时候看看\n上面的图代表了arm中的条件标志位的一些标识，比如如果相等就是EQ那么z就等于1这些，上面的这些助记符扩展都可以加入一些指令后面，比如 addeq r0, r0, #1 那么这句的含义就是当z=1的时候r0 = r0 + 1\n让这些标志位进行改变的，举例大概有cmp，或者是某些指令加了后面加了s的，因为加了s就可以把指令影响的标志寄存器进行改，用add进行举例可以看到，adds如果reg不是pc，他会更新psr中的标志位的\n直接写汇编调试一下运行看看，写的是add r0,r0,r1 r0 = 1 r1 = 0xffffffff，是进位的，但是add指令是不改变标志寄存器只改变结果，所以没有看到\n现在我变成adds可以看一下，可以看到改表了标志寄存器的值，发生了进位和为0，所以c位和z位变成了1\n查看手册可以发现上面说的第20位为S位，如果是1就是adds，如果是0那么就是add\n01 00 80 E0 ADD R0, R0, R1 01 00 90 E0 ADDS R0, R0, R1 0000 0001 0000 0000 1000 0000 1110 0000 0000 0001 0000 0000 1001 0000 1110 0000 其中有一个和x86相反的规则是减法指令，可以看一下，第一个sub r0,r0,r1 其中的r0 = 0, r1 = 0xffffffff，第二个r0 = 2，r1 = 1\n可以看到结果对了，但是c位没有变成1，但是第二个的时候c位变成了1\n这个位置就和之前x86学习汇编有一点不一样的情况，这里的情况是产生借位c是0，不产生借位c是0，规则就是减法就是加法器a−b=a+(∼b+1)\n这边有几个对应的指令\nsub subs cmp add adds cmn 如果想判断哪些指令有没有更新标志寄存器，你只需要看第20位是不是1，或者第五个十六进制是不是奇数就行，我在libc中随便找的一个函数，可以看到第五个如果是奇数的话，那么就是会改变psr寄存器的\nMOV指令 mov指令没有访存的操作，所以两个操作数要不就是reg要不就是imm\nmov,movs (immediate) 因为arm的指令集是4字节的指令，立即数如果是32位的肯定放不下，所以arm的imm没办法直接写32位的立即数，mov立即数的情况手册中分成了两种指令格式一种是A1，一种是A2\nA2编码格式 先看一下A2的指令格式，上面有写到，A2的指令格式支持所有16位的立即数，这16位的立即数会写在0-11为以及16-19位，其中的12-15位代表了寄存器正好是4位代表了16个寄存器\n举个例子 mov r1, #0x1234 对应的硬编码是E3011234，那么正好就是0-11为234，16-19为1，12-15为1，正好和上面对应上了\nA1编码格式 比如这个指令：mov r1, #0x80000000，这个立即数已经超过了16位的范围，是32位的范围，那么这种情况就是对应的A1编码格式的情况，为什么要这么设计呢？\n虽然他比16位大，但是他的有效位只有最开始那一位\n这个硬编码根据A1拆分，0-11位是102，12-15的rd为1不变，16-19是0\n上面的解释是A32ExpandImm_C(imm12, PSTATE.C)，imm12需要拆成rot = imm12[11:8]，以及imm8 = imm12[7:0]，其中的rot的单位为2，所以上面的102可以为 02像右循环移为2，因为是32位02为10，像右循环移位2就是1（31个0），所以就是0x80000000，那么说明这个就可以表示0x0 - 0xff的情况都可以像右循环移位，移动的位数是0-16，为什么要乘2，那么就可以覆盖32位，那么就覆盖了0-32位的偶数\nmovt movt是像高4位写，如果像写32位的可以这么写\nmov r1,#0x5678 movt r1,#0x1234 ida优化就直接合并成了一条指令，这个movt的指令一定是先写mov后写movt，因为mov指令会把前面的4字节变成0，那么先写movt就没用了\n那么在实际代码中编译器怎么写的这个情况呢，可以看一下\n#include \u0026lt;stdio.h\u0026gt; int main() { u_int32_t test_var = 0x12345678; printf(\u0026#34;Test variable value: 0x%X\\n\u0026#34;, test_var); while (1) { printf(\u0026#34;Hello, World!\\n\u0026#34;); getchar(); } return 0; } 可以看到真实的环境下的寻址，都是通过ldr的这种方式去寻址的，movt这种一般是后面写shellcode的时候比较有用处\nmov,movs (register) 这个普通的mov reg,reg肯定都比较了解了，其中的0-3位为源寄存器，12-15为目标寄存器，举例中的这个mov r0,r1，其中r1就是0-3位为1，r0就是12-15位为0\n这个上面的图中的imm5就代表了可以进行移位的数字，可以看到是7-11位，一共是5位，5位就是代表了0-31，就是32个数字，也对应了32位\n下面这个例子就是左移1位，怎么移就要看5-6位的stype位了，因为有两位所以对应了四种情况：逻辑左移，逻辑右移，算数右移，循环移位 （没有算数左移，因为这个是和逻辑左移式一样的）\n在看一下移位的汇编，其实和mov的硬编码是一样的，因为他们的原理等价了mov的东西，其实移位的操作可以理解为是mov指令的一个宏定义\nmov,movs (register-shifted register) 这个是寄存器移位寄存器赋值给寄存器，所以和上面的大概的流程是一样的不重复了\n基本整型运算 基本运算基本不会出现两个imm，因为举个例子，比如 add r0,1,2 相当于r0 = 3，这个写出来就很奇怪了，早就在编译器的那一步就给你优化掉了\n像这种基本整形运算其实大部分都一样，格式所以主要以add来举例说明，后面的简单介绍功能就可以\nADD 见到这种12位的imm，其实本质上都是之前说的mov的那种形式 8位代表数字，4位代表移位\n寄存器的就比较简单了，两个寄存器想加写在第三个寄存器里，其中的imm5和stype就是之前mov中的说的移位操作\n这个就也和上面的mov类似就是寄存器移位寄存器\n这个就是pc+imm给到另一个寄存器了\n看一下汇编 add r0,pc,4\nida中对应什么呢，因为pc进行读就需要当前的pc+8，上面的指令加上4，所以就是2c的位置，但是在正常的调试环境中，或者运行环境中会根据imagebase进行调整可以在这里看一下printf的位置的这个情况\nprintf这个情况，可以看到他把imagebase加上去了\nSUB/CMP 减法操作 SUB Rd, Rn, Op2：Rd = Rn - Op2 CMP Rn, Op2：只比较不写寄存器，等价于 SUBS (丢弃结果)\n; i--，并在为零时跳走 SUBS r0, r0, #1 BEQ don ; 比较 a 与 b CMP r1, r2 ; 相当于 SUBS r?, r1, r2 BGE ge_path ; 大于等于走这里（无借位 + 非溢出） RSB 反减 RSB Rd, Rn, Op2：Rd = Op2 - Rn\n; 取负：Rd = -Rm RSBS r0, r1, #0 ; r0 = 0 - r1，顺带写标志 AND/TST 与操作 AND Rd, Rn, Op2：Rd = Rn \u0026amp; Op2 TST Rn, Op2：与运算并只写标志，等价于 ANDS (丢弃结果)\n; 测试 r0 的 bit 7 是否为 1 TST r0, #(1\u0026lt;\u0026lt;7) BNE bit7_is_one BIC 反与，按位清零 BIC Rd, Rn, Op2：Rd = Rn \u0026amp; ~Op2\n; 清 r0 的低 4 位 BIC r0, r0, #0xF ; 清 r1 的 bit 20（把 bit20 置 0） BIC r1, r1, #(1\u0026lt;\u0026lt;20) ORR 或 ORR Rd, Rn, Op2：Rd = Rn | Op2\n; 置 r0 的 bit 3 和 bit 5 ORR r0, r0, #(1\u0026lt;\u0026lt;3) | (1\u0026lt;\u0026lt;5) EOR/TEQ 异或 EOR Rd, Rn, Op2：Rd = Rn ^ Op2（按位异或/翻转） TEQ Rn, Op2：只写标志，等价于 EORS (丢弃结果)，常用来“测试相等性（按位相同则结果 0）”或“测试奇偶”\n; 翻转 r0 的 bit 8 EOR r0, r0, #(1\u0026lt;\u0026lt;8) ; 判断 r1 与 r2 的比特是否完全相同 TEQ r1, r2 BEQ equal_bits ; r1 ^ r2 == 0 访存指令 LDR: 读内存 STR: 写内存\nldr r1, [r0] 代表了从r0的地址中读取4个字节给r1寄存器\nldr r1, [r0, #4] 代表了从r0 + 4的地址中读取4个字节给r1寄存器\n可以大概看到ldr的指令基础大概这样，和之前学到的差不多，但是这些都是没有后续行为的\n有后续附加行为的比如，可以在内存的后面加一个！号，LDR R0, [R1,#4]! 这个指令的含义是把R1 + 4李的内存内容给到R0后，R1 = R1 + 4，LDR R0, [R1], #4 这个指令的含义是把R1的内存内容给到R0后，R1 = R1 + 4\n写内存的指令其实同理，str指令是把左边的寄存器赋值给右边的内存，和ldr的方向相反了而已，我们现在直接调试，给举例就可以明白了，我们用push和pop对应的arm指令就可以说明白了！\narm 中的push reg，pop reg对应的真实指令是：str {reg},[sp,#-4]! 和 LDR {reg},[sp],#4\n执行完的结果就是：\n手册里也写了，这个里面还有一个知识点就是p位如果是1就是立即数在里面，如果是0就是在外面，因为立即数只有12位，所以只能是里面和外面只能有一个同时存在\n手册中的ldrd, ldrh，ldrb，代表了64位，16位，8位，str的相关知识同理上面 其中的ldrd如下代表了，偶数寄存器，第二个是偶数寄存器+1的寄存器，后面时内存地址比如：ldrd r8,r9,[pc]\n块访存指令 分支和模式切换 Thumb模式, IT块 ","permalink":"https://l0x1c.com/posts/arm-%E6%B1%87%E7%BC%96/","summary":"ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧\n主要的学习流程大概这两个：\n看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 \u0026amp; 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件 cemu 做辅助支持 : https://github.com/hugsy/cemu\n在ubuntu下面折腾了一下，感觉还行\n当然如果有真机做测试使用是最好的了 （ 这里我最后选择的真机，因为机器就在手里，hhhh ）\nAndroid studio \u0026amp; ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下\n安装完之后自己在 .zshrc 中配置一下环境变量\nexport ANDROID_HOME=\u0026#34;Android/sdk所在路径\u0026#34; export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了\n代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下\n进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}\n以后避免每次都打开 android studio可以用emulator里面命令来启动avd\n⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了\n配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发\n这样后ida attach就可以看到对应的进程那些了\nc编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en\n主要需要的是 Application.mk 和 Android.","title":"Arm 汇编学习"},{"content":"VAD_私有内存 私有内存 像malloc, virtualalloc申请的内存都是私有内存, MapViewofFile, MapViewOfSize, mdl, 这种是映射的内存\n这些内存是由一个叫做vadroot的节点来管理的, 可以看一下这个位置 这里如果后续想获取到这个位置的话, 因为每个版本的偏移可能不一样, 可以通过函数PsGetProcessExitStatus来获取对应的偏移 + 4就是vadRoot win10上的结构\n+0x658 VadRoot : _RTL_AVL_TREE +0x660 VadHint : 0xffff900f`4bf43e10 Void +0x668 VadCount : 0xde VadRoot: _RTL_AVL_TREE 里面就是代表了二叉搜索树的节点, 而里面的每个节点的结构都是__MMVAD的结构, VadHint多次查询的节点会放在这里, VadCount代表vad节点的个数\nkd\u0026gt; dt _RTL_AVL_TREE ffff900f4c129400+0x658 nt!_RTL_AVL_TREE +0x000 Root : 0xffff900f`4bf44810 _RTL_BALANCED_NODE kd\u0026gt; dt 0xffff900f`4bf44810 _RTL_BALANCED_NODE nt!_RTL_BALANCED_NODE +0x000 Children : [2] 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE +0x000 Left : 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE +0x008 Right : 0xffff900f`4bfe65c0 _RTL_BALANCED_NODE +0x010 Red : 0y0 +0x010 Balance : 0y00 +0x010 ParentValue : 0 !vad即可查询 其中start和End代表了开始和结束, 都需要乘上pagesize -\u0026gt; 0x1000其中end不一样(end + 1)*pagesize - 1, 里面的每一个节点都是_MMVAD的结构, 可以找一个私有内存看一下结构\nkd\u0026gt; dt _MMVAD ffff900f4bf449a0 nt!_MMVAD +0x000 Core : _MMVAD_SHORT +0x040 u2 : \u0026lt;anonymous-tag\u0026gt; +0x048 Subsection : 0x01dbdb86`7175af69 _SUBSECTION +0x050 FirstPrototypePte : (null) +0x058 LastContiguousPte : (null) +0x060 ViewLinks : _IST_ENTRY [ 0xffff900f`4bfe4540 - 0x00000026`00000020 ] +0x070 VadsProcess : (null) +0x078 u4 : \u0026lt;anonymous-tag\u0026gt; +0x080 FileObject : 0x00000004`00100200 _FILE_OBJECT kd\u0026gt; dt _MMVAD_SHORT ffff900f4bf449a0 nt!_MMVAD_SHORT +0x000 NextVad : 0xffff900f`4bfe4e00 _MMVAD_SHORT +0x008 ExtraCreateInfo : 0xffff900f`4bfe29c0 Void +0x000 VadNode : _RTL_BALANCED_NODE +0x018 StartingVpn : 0x160 +0x01c EndingVpn : 0x166 +0x020 StartingVpnHigh : 0 \u0026#39;\u0026#39; +0x021 c : 0 \u0026#39;\u0026#39; +0x022 CommitChargeHigh : 0 \u0026#39;\u0026#39; +0x023 SpareNT64VadUChar : 0 \u0026#39;\u0026#39; +0x024 ReferenceCount : 0n0 +0x028 PushLock : _EX_PUSH_LOCK +0x030 u : \u0026lt;anonymous-tag\u0026gt; +0x034 u1 : \u0026lt;anonymous-tag\u0026gt; +0x038 EventList : (null) 其中的__MMVAD_SHORT的前三个其实是union, 代表了下一个vad节点的地址, NextVad是左子树, ExtraCreateInfo是右子树\nStartingVpn, EndingVpn, StartingVpnHigh, StartingVpnHigh可以看一下MiLocateAddress的写法, win10会和win7有不同, 计算方式为(result-\u0026gt;Core.StartingVpn | ((unsigned __int64)result-\u0026gt;Core.StartingVpnHigh \u0026lt;\u0026lt; 32))和(result-\u0026gt;Core.EndingVpn | ((unsigned __int64)result-\u0026gt;Core.EndingVpnHigh \u0026lt;\u0026lt; 32)) 在_MMVAD_SHORT结构里有一项是u-\u0026gt;_MMVAD_FLAGS结构, 其中的PrivateMemory代表了这里是不是私有内存, Protection代表了属性是多少, vadtype用于标记这段虚拟内存的用途或分配方式 看一下这个vadtype\n值（十进制） 名称 含义说明 0 VadNone 未指定类型（保留） 1 VadDevicePhysicalMemory 映射的物理设备内存 2 VadImageMap 映像（如 EXE、DLL 文件）映射 3 VadAwe 使用 AWE（Address Windowing Extensions）分配的内存 4 VadWriteWatch 启用了写监视（Write-Watch）的内存，用于检测哪些页面被写入 5 VadLargePages 使用大页（Large Pages）分配的内存 6 VadRotatePhysical 映射旋转的物理内存（罕见） 7 VadLargePageSection 段式大页分配（仅在某些版本支持） 看一下这个Protection, 看一下NtAllocateVirtualMemory这个函数里关于Protection的字段可以很好的定位到MiMakeProtectionMask这个函数\n看一下这个函数, 可以发现他把这个申请的内存属性分成了两个属性, 也刚好的在两个表中\n我们可以举一个例子, 假设是PAGE_EXECUTE_READWRITE = 0x40\n那么根据代码的逻辑, 他会被分成两个部分, 0100 0000一个是4一个是0, 那么就会在这个表中找一下, 因为第一个是0所以要直接在第二个表中找一下属性, 可以看到数组的第五个刚好是MM_EXECUTE_READWRITE 所以我们上面内存这个位置是0x4, 所以属性就是MM_READWRITE\n写了三个功能:\n1.打开IDA分析内核MiLocateAddress这个函数, 给一个R3地址, 返回一个VAD节点\n2.给一个进程ID, 解析出此进程的所有VAD节点\n3.移除内存所在vad节点的位置\n#include \u0026#34;struct.h\u0026#34; void RtlAvlRemoveNode(PVOID tree, PVOID node); PEPROCESS LookUpProcess(HANDLE Pid) { PEPROCESS eprocess = NULL; NTSTATUS Status = STATUS_UNSUCCESSFUL; Status = PsLookupProcessByProcessId(Pid, \u0026amp;eprocess); if (NT_SUCCESS(Status)) return eprocess; return NULL; } ULONG64 GetVadOffset() { UNICODE_STRING func; RtlInitUnicodeString(\u0026amp;func, L\u0026#34;PsGetProcessExitStatus\u0026#34;); ULONG64 funcAddr = MmGetSystemRoutineAddress(\u0026amp;func); if (funcAddr == NULL) { return FALSE; } //8B 81 D4 07 00 00 mov eax, [rcx+7D4h] PUCHAR funcBytes = (PUCHAR)funcAddr; //DbgPrint(\u0026#34;funcAddr : %p\\n\u0026#34;, funcAddr); //DbgPrint(\u0026#34;funcBytes : %p\\n\u0026#34;, funcBytes); for (size_t i = 0; i \u0026lt; 0x10; i++) { if (funcBytes[0] == 0x8B \u0026amp;\u0026amp; funcBytes[1] == 0x81) { UINT32 offset = *(UINT32*)(funcBytes + 2); return offset + 0x4; } } return FALSE; } PMMVAD MiLocateAddress(PEPROCESS eProcess, ULONG64 virtualAddress) { PRTL_AVL_TREE vadRoot = (PRTL_AVL_TREE)((PUCHAR)eProcess + GetVadOffset()); if (!vadRoot || !vadRoot-\u0026gt;Root) { return NULL; // VAD tree is empty or invalid } PMMVAD vad = (PMMVAD)vadRoot-\u0026gt;Root; if (!MmIsAddressValid(vad)) { return NULL; } ULONG64 address = virtualAddress \u0026gt;\u0026gt; 12; if (address \u0026lt; (vad-\u0026gt;Core.StartingVpn | (vad-\u0026gt;Core.StartingVpnHigh \u0026lt;\u0026lt; 32)) || address \u0026gt;(vad-\u0026gt;Core.EndingVpn | (vad-\u0026gt;Core.EndingVpn \u0026lt;\u0026lt; 32))) { while (vad) { if (address \u0026gt; (vad-\u0026gt;Core.EndingVpn | (vad-\u0026gt;Core.EndingVpnHigh \u0026lt;\u0026lt; 32))) { vad = (PMMVAD)vad-\u0026gt;Core.VadNode.Right; } else { if (address \u0026gt;= (vad-\u0026gt;Core.StartingVpn | (vad-\u0026gt;Core.StartingVpnHigh \u0026lt;\u0026lt; 32))) { return vad; } vad = (PMMVAD)vad-\u0026gt;Core.VadNode.Left; } } } return NULL; } PVOID EnumVad(PMMVAD vad) { if (!vad) { return NULL; } PVOID stack[256]; int stackIndex = 0; stack[stackIndex++] = vad; while (stackIndex \u0026gt; 0) { PMMVAD currentVad = (PMMVAD)stack[--stackIndex]; DbgPrintEx(77, 0, \u0026#34;Vad: %p | start : %x | end : %x | vadflags : %x \\n\u0026#34;, currentVad, currentVad-\u0026gt;Core.StartingVpn, currentVad-\u0026gt;Core.EndingVpn, currentVad-\u0026gt;Core.u.VadFlags); if (currentVad-\u0026gt;Core.VadNode.Right) { stack[stackIndex++] = (PVOID)currentVad-\u0026gt;Core.VadNode.Right; } if (currentVad-\u0026gt;Core.VadNode.Left) { stack[stackIndex++] = (PVOID)currentVad-\u0026gt;Core.VadNode.Left; } } return NULL; } PVOID ParserProcessVad(PEPROCESS eProcess) { PRTL_AVL_TREE vadRoot = (PRTL_AVL_TREE)((PUCHAR)eProcess + GetVadOffset()); if (!vadRoot || !vadRoot-\u0026gt;Root) { return NULL; // VAD tree is empty or invalid } ULONG64 vadCount = *(PULONG64)((PUCHAR)eProcess + GetVadOffset() + 0x10); PMMVAD vad = (PMMVAD)vadRoot-\u0026gt;Root; if (!MmIsAddressValid(vad)) { return NULL; } EnumVad(vad); } PVOID LockPageProction(PEPROCESS eProcess, ULONG64 virtualaddress, PMMVAD vad) { } PVOID RemoveVad(PEPROCESS eProcess, ULONG64 virtualaddress) { PMMVAD vad = MiLocateAddress(eProcess, virtualaddress); if (!MmIsAddressValid(vad)) { return NULL; } PRTL_AVL_TREE vadRoot = (PRTL_AVL_TREE)((PUCHAR)eProcess + GetVadOffset()); if (!vadRoot || !vadRoot-\u0026gt;Root) { return NULL; } RtlAvlRemoveNode(vadRoot, vad); ObReferenceObject(eProcess); } PVOID UnloadDriver( _In_ PDRIVER_OBJECT DriverObject ) { UNREFERENCED_PARAMETER(DriverObject); DbgPrintEx(77, 0, \u0026#34;Driver unloaded successfully.\\n\u0026#34;); return STATUS_SUCCESS; } NTSTATUS DriverEntry( _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath ) { UNREFERENCED_PARAMETER(RegistryPath); DbgPrintEx(77, 0, \u0026#34;Driver loaded successfully.\\n\u0026#34;); //1. 分析内核 MiLocateAddress 这个函数，然后照抄此判断是: 给一个R3地址，返回一个VAD 节点 //2. 给一个进程ID，解析出此进程的所有VAD节点 //3. 代码实现WIN10 WIN11 私有内存锁页 //4. 移除内存所在vad节点的位置 //DbgBreakPoint(); PEPROCESS eproc = NULL; eproc = LookUpProcess(0x16c8); if (!eproc) { return STATUS_UNSUCCESSFUL; } UINT32 vadOffset = GetVadOffset(); if (!vadOffset) { return STATUS_UNSUCCESSFUL; } //1: over PMMVAD vad = MiLocateAddress(eproc, 0xDCE0000); DbgPrintEx(77, 0, \u0026#34;Find Vad: %p\\n\u0026#34;, vad); /* +0x658 VadRoot : _RTL_AVL_TREE +0x660 VadHint : 0xffffce01`8de7d9a0 Void +0x668 VadCount : 0xaa +0x670 VadPhysicalPages : 0 +0x678 VadPhysicalPagesLimit : 0 */ //vadRoot是根节点, vadHint是上一次MiLocateAddress找到的指针, vadCount是vad的数量 //2: over ParserProcessVad(eproc); //3. over RemoveVad(eproc, 0xDCE0000); ObDereferenceObject(eproc); DriverObject-\u0026gt;DriverUnload = UnloadDriver; return STATUS_SUCCESS; } VAD映射内存 Win10锁页 插入一个锁页的知识点, win10和win7有差别, 主要还是看win10, 直接看一下MmProtectVirtualMemory这个函数, 可以看到如果满足这两个逻辑的话, 就会返回失败\n测试一个, 用CE申请了一块内存, 看一下对应的 +0x30的位置, 因为上面的\u0026amp; 0x3F800可以用不用考虑, 因为这个参数可以用的属性加起来也不会超过0x800所以这里为0, 那么我们让这个位置 Core.u.LongFlags \u0026amp; 0x1100000 == 0x1100000 就可以了\n可以发现Graphics: 0y1 PrivateMemoryAlwaysSet: 0y1这个两个位置为1即可\n代码实现:\nPVOID LockVadProction(PEPROCESS eProcess, ULONG64 virtualaddress) { PMMVAD_SHORT vad = MiLocateAddress(eProcess, virtualaddress); if (!MmIsAddressValid(vad)) { return NULL; } vad-\u0026gt;u.PrivateVadFlags.Graphics = 0x1; vad-\u0026gt;u.PrivateVadFlags.PrivateMemoryAlwaysSet = 0x1; } 这样这个内存的页就不能被修改属性了\n映射内存 找一个map的内存看一下, MMVAD_SHORT的结构\nX64页表 页表自映射 页帧\n物理页是有一个地方去管理，管理的时候用的是数组，没有用链表，因为数组的查找很快，因为物理地址是频繁运行，所以必须有一个很快的算法 有一个这样的数组叫做：mmpfndatabase, 数组里的每一个元素都是mmpfn结构,\n数组的索引, pte的页帧 \u0026mdash;\u0026gt; 某些属性 + 页帧 + 属性\nmmpfndatabase[pte.页帧]\nx64分页\nx64 获取PTEbase\n#include \u0026lt;ntifs.h\u0026gt; ULONG64 g_PteAddress = 0; ULONG64 g_PdeAddress = 0; ULONG64 g_PpeAddress = 0; ULONG64 g_PxeAddress = 0; ULONG64 GetPteAddress(ULONG64 Address) { return (ULONG64)(((Address \u0026gt;\u0026gt; 9) \u0026amp; 0x7FFFFFFFF8) + g_PteAddress); } ULONG64 GetPdeAddress(ULONG64 Address) { return (ULONG64)(((Address \u0026gt;\u0026gt; 9) \u0026amp; 0x7FFFFFFFF8) + g_PteAddress); } ULONG64 GetPpeAddress(ULONG64 Address) { return (ULONG64)(((Address \u0026gt;\u0026gt; 9) \u0026amp; 0x7FFFFFFFF8) + g_PteAddress); } ULONG64 GetPxeAddress(ULONG64 Address) { return (ULONG64)(((Address \u0026gt;\u0026gt; 9) \u0026amp; 0x7FFFFFFFF8) + g_PteAddress); } VOID GetFourTableBASE() { ULONG64 DirectoryTableBase = *(PULONG64)((PUCHAR)PsInitialSystemProcess + 0x28); //后12位属性 DirectoryTableBase \u0026amp;= ~0xFFF; PHYSICAL_ADDRESS address; address.QuadPart = DirectoryTableBase; PULONG64 VirtualDirectorBase = MmGetVirtualForPhysical(address); ULONG64 index = -1; for (size_t i = 0; i \u0026lt; 512; i++) { ULONG64 data = VirtualDirectorBase[i]; //8000 0000001aa063 //48 0xFFFFFFFFFFFF //ULONG64 testData = ((data \u0026amp; ~0xFFF) \u0026amp; 0xFFFFFFFFFFFF); if (DirectoryTableBase == ((data \u0026amp; ~0xFFF) \u0026amp; 0xFFFFFFFFFFFF)) { index = i; break; } } if (index != -1) { g_PteAddress = (index + 0x1FFFE00) \u0026lt;\u0026lt; 39; g_PdeAddress = (index \u0026lt;\u0026lt; 30) + g_PteAddress; g_PpeAddress = (index \u0026lt;\u0026lt; 21) + g_PdeAddress; g_PxeAddress = (index \u0026lt;\u0026lt; 12) + g_PpeAddress; } } VOID DriverUnload(PDRIVER_OBJECT pDriver) { } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pSeg) { //1. 获取pte的基址 （ MmGetVirtualForPhysical ） //2. 解析 返回PTE PDE PDPTE PML4的地址 ( MmIsAddressValidEx ) //1. over DbgBreakPoint(); GetFourTableBASE(); if (g_PteAddress != NULL) { DbgPrintEx(77, 0, \u0026#34;PTEBASE: %p\\n\u0026#34;, g_PteAddress); DbgPrintEx(77, 0, \u0026#34;PDEBASE: %p\\n\u0026#34;, g_PdeAddress); DbgPrintEx(77, 0, \u0026#34;PPEBASE: %p\\n\u0026#34;, g_PpeAddress); DbgPrintEx(77, 0, \u0026#34;PXEBASE: %p\\n\u0026#34;, g_PxeAddress); } else { DbgPrintEx(77, 0, \u0026#34;ERROR\\n\u0026#34;); } //2. over ULONG64 gdtr = 0xfffff80258bc4fb0; ULONG64 gdtrPte = GetPteAddress(gdtr); ULONG64 gdtrPde = GetPdeAddress(gdtrPte); ULONG64 gdtrPpe = GetPpeAddress(gdtrPde); ULONG64 gdtrPxe = GetPxeAddress(gdtrPpe); DbgPrintEx(77, 0, \u0026#34;gdtrPte: %p\\n\u0026#34;, gdtrPte); DbgPrintEx(77, 0, \u0026#34;gdtrPde: %p\\n\u0026#34;, gdtrPde); DbgPrintEx(77, 0, \u0026#34;gdtrPpe: %p\\n\u0026#34;, gdtrPpe); DbgPrintEx(77, 0, \u0026#34;gdtrPxe: %p\\n\u0026#34;, gdtrPxe); pDriver-\u0026gt;DriverUnload = DriverUnload; return STATUS_SUCCESS; } PTE的原型 原型PTE本质上就是我们PTE的生命周期\n我们的dll还有exe是多个进程共用一个文件的存在，重新创建一个进程跑起来，还是会使用dll，\nallocatememory 当我们申请内存的时候，如果一次都没有访问过，是一个没有挂物理页的虚拟地址，当我们访问一下的时候，此时回给他挂上物理页\n上面的四种当我们申请内存的时候有可能是空的, d的表述, 此时申请完，我们去访问的时候，会发生页异常错误，抛给14号中断，判断是用户态模式还是内核态的模式，内核态的话直接就蓝屏，因为内核态模式是没有vad的，在用户态还要去检测一下有没有vad，如果在vad中，而且保护属性不是noaccess的话，其他的页属性的话会进一步的去给他挂物理页然后去修复\n","permalink":"https://l0x1c.com/posts/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","summary":"VAD_私有内存 私有内存 像malloc, virtualalloc申请的内存都是私有内存, MapViewofFile, MapViewOfSize, mdl, 这种是映射的内存\n这些内存是由一个叫做vadroot的节点来管理的, 可以看一下这个位置 这里如果后续想获取到这个位置的话, 因为每个版本的偏移可能不一样, 可以通过函数PsGetProcessExitStatus来获取对应的偏移 + 4就是vadRoot win10上的结构\n+0x658 VadRoot : _RTL_AVL_TREE +0x660 VadHint : 0xffff900f`4bf43e10 Void +0x668 VadCount : 0xde VadRoot: _RTL_AVL_TREE 里面就是代表了二叉搜索树的节点, 而里面的每个节点的结构都是__MMVAD的结构, VadHint多次查询的节点会放在这里, VadCount代表vad节点的个数\nkd\u0026gt; dt _RTL_AVL_TREE ffff900f4c129400+0x658 nt!_RTL_AVL_TREE +0x000 Root : 0xffff900f`4bf44810 _RTL_BALANCED_NODE kd\u0026gt; dt 0xffff900f`4bf44810 _RTL_BALANCED_NODE nt!_RTL_BALANCED_NODE +0x000 Children : [2] 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE +0x000 Left : 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE +0x008 Right : 0xffff900f`4bfe65c0 _RTL_BALANCED_NODE +0x010 Red : 0y0 +0x010 Balance : 0y00 +0x010 ParentValue : 0 !","title":"内存管理"},{"content":"这周主要看了一下minifilter的东西, 网吧, 杀软, 反作弊都会相应的用到这个\nminifilter_Nt启动 ","permalink":"https://l0x1c.com/posts/minifilter/","summary":"这周主要看了一下minifilter的东西, 网吧, 杀软, 反作弊都会相应的用到这个\nminifilter_Nt启动 ","title":"minifilter"},{"content":"很久没打ctf了, 正好碰见周末有一点空, 就看了一下d3ctf和windows相关的题目\nlocked-door 加的是vmp的壳子, 需要调试的话直接用TitanHide - \u0026gt; https://github.com/mrexodia/TitanHide就可以调试起来, download后自行加个签名即可, 发现题目有两个bin文件, 直接可以得到的思路是先dump, 因为一定要读取文件一定会调用readfile, 所以可以根据回溯找到关键位置进行调试 通过readfile回溯已经找到了关键位置, 然后用过函数特征入口点来dump, 正常编程的也就那几个软件, 这个问题在之前我发过看雪的文章可以看一下, 可以看到这里很像入口点了, 看一个正常vs编译出来的程序 比较后可以看很像入口点的位置, 直接dump设置oep, 这样dump后的逻辑就很清晰了 可以看到一个算法, 本身程序对他们的校验的算法是一样的 加密完的数据进行evp的校验 校验过了后才可以走到正确的流程, 参数是key+加密的bin里的data, 那直接替换一下, 就可以得到flag了 d3rpg-revenge 这是一个游戏, 正好我是一个游戏安全的从业者, 直接打开ce开始干, 进入一个房间后, 他让我输入密码, 那么可以对密码的位置进行访问断点, 可以看到可以被很好的断下来 d3rpg.dll+50DEA这里的地址, 这个字符串很可疑, 去搜一下 module Scene_RPG class Secret_Class DELTA = | (($de1ta + 1) * 0xf0000000) def initialize(new_key) @key = str_to_longs(new_key) if @key.length \u0026lt; 4 @key.length.upto(4) { |i| @key[i] = 0 } end end def self.str_to_longs(s, include_count = false) s = s.dup length = s.length ((4 - s.length % 4) \u0026amp; 3).times { s \u0026lt;\u0026lt; \u0026#34;\\0\u0026#34; } unpacked = s.unpack(\u0026#39;V*\u0026#39;).collect { |n| int32 n } unpacked \u0026lt;\u0026lt; length if include_count unpacked end def str_to_longs(s, include_count = false) self.class.str_to_longs s, include_count end def self.longs_to_str(l, count_included = false) s = l.pack(\u0026#39;V*\u0026#39;) s = s[0...(l[-1])] if count_included s end def longs_to_str(l, count_included = false) self.class.longs_to_str l, count_included end def self.int32(n) n -= 4_294_967_296 while (n \u0026gt;= 2_147_483_648) n += 4_294_967_296 while (n \u0026lt;= -2_147_483_648) n.to_i end def int32(n) self.class.int32 n end def mx(z, y, sum, p, e) int32( ((z \u0026gt;\u0026gt; 5 \u0026amp; 0x07FFFFFF) ^ (y \u0026lt;\u0026lt; 2)) + ((y \u0026gt;\u0026gt; 3 \u0026amp; 0x1FFFFFFF) ^ (z \u0026lt;\u0026lt; 4)) ) ^ int32((sum ^ y) + (@key[(p \u0026amp; 3) ^ e] ^ z)) end def self.encrypt(key, plaintext) self.new(key).encrypt(plaintext) end def encrypt(plaintext) return \u0026#39;\u0026#39; if plaintext.length == 0 v = str_to_longs(plaintext, true) v[1] = 0 if v.length == 1 n = v.length - 1 z = v[n] y = v[0] q = (6 + 52 / (n + 1)).floor sum = $de1ta * DELTA p = 0 while(0 \u0026lt;= (q -= 1)) do sum = int32(sum + DELTA) e = sum \u0026gt;\u0026gt; 2 \u0026amp; 3 n.times do |i| y = v[i + 1]; z = v[i] = int32(v[i] + mx(z, y, sum, i, e)) p = i end p += 1 y = v[0]; z = v[p] = int32(v[p] + mx(z, y, sum, p, e)) end longs_to_str(v).unpack(\u0026#39;a*\u0026#39;).pack(\u0026#39;m\u0026#39;).delete(\u0026#34;\\n\u0026#34;) end def self.decrypt(key, ciphertext) self.new(key).decrypt(ciphertext) end end end def validate_flag(input_flag) c_flag = input_flag + \u0026#34;\\0\u0026#34; result = $check_flag.call(c_flag) result == 1 end def check flag = $game_party.actors[0].name key = Scene_RPG::Secret_Class.new(\u0026#39;rpgmakerxp_D3CTF\u0026#39;) cyphertext = key.encrypt(flag) if validate_flag(cyphertext) $game_variables[1] = 100 else $game_variables[1] = 0 end end def check1 flag = $game_party.actors[0].name if flag == \u0026#34;ImPsw\u0026#34; $game_variables[2] = 100 else $game_variables[2] = 0 end end 直接写python解密即可\nfrom regadgets import * data = decode_b64(\u0026#39;LhVvfepywFIsHb8G8kNdu49J3k0=\u0026#39;) key = b\u0026#39;rpgmakerxp_D3CTF\u0026#39; #xxtea decode data = xxtea_decrypt(data, key, delta=0xf1919810) print(data) #Y0u_R_RPG_M4st3r ","permalink":"https://l0x1c.com/posts/d3ctf_writeup/","summary":"很久没打ctf了, 正好碰见周末有一点空, 就看了一下d3ctf和windows相关的题目\nlocked-door 加的是vmp的壳子, 需要调试的话直接用TitanHide - \u0026gt; https://github.com/mrexodia/TitanHide就可以调试起来, download后自行加个签名即可, 发现题目有两个bin文件, 直接可以得到的思路是先dump, 因为一定要读取文件一定会调用readfile, 所以可以根据回溯找到关键位置进行调试 通过readfile回溯已经找到了关键位置, 然后用过函数特征入口点来dump, 正常编程的也就那几个软件, 这个问题在之前我发过看雪的文章可以看一下, 可以看到这里很像入口点了, 看一个正常vs编译出来的程序 比较后可以看很像入口点的位置, 直接dump设置oep, 这样dump后的逻辑就很清晰了 可以看到一个算法, 本身程序对他们的校验的算法是一样的 加密完的数据进行evp的校验 校验过了后才可以走到正确的流程, 参数是key+加密的bin里的data, 那直接替换一下, 就可以得到flag了 d3rpg-revenge 这是一个游戏, 正好我是一个游戏安全的从业者, 直接打开ce开始干, 进入一个房间后, 他让我输入密码, 那么可以对密码的位置进行访问断点, 可以看到可以被很好的断下来 d3rpg.dll+50DEA这里的地址, 这个字符串很可疑, 去搜一下 module Scene_RPG class Secret_Class DELTA = | (($de1ta + 1) * 0xf0000000) def initialize(new_key) @key = str_to_longs(new_key) if @key.length \u0026lt; 4 @key.length.upto(4) { |i| @key[i] = 0 } end end def self.","title":"D3CTF-WriteUp"},{"content":"初步分析 分析到一个E语言的外挂, 但是说的是过检测的外挂, 分析一下, 直接ida一把梭大概看到有用的信息, 内部测试3-A.exe explorer.exe 打开外挂后看到的功能大概有这几个, 加载过检, 开始过检, 伪装进程, 隐藏进程这几个, 大概就能猜到肯定用到了驱动 跑起来后, 第一个功能是开始过检测, 发现修改了R3层的应用层访问的状态为拒绝 直接打开process explorer, 可以发现进程的Protection属性变成了PsProtectedSignerWinTcb-Light, 这里的保护和今年的腾讯游戏安全初赛的那个是一样的PPL 直接windbg看一下进程的EPROCESS结构, 可以看到Protection为0x61 -\u0026gt; 0110 0001b, 可以看到修改的为PsProtectedTypeProtectedLight,PsProtectedSignerWinTcb\n//进程保护类型 typedef enum _PS_PROTECTED_TYPE { PsProtectedTypeNone = 0, PsProtectedTypeProtectedLight = 1, PsProtectedTypeProtected = 2 } PS_PROTECTED_TYPE, *PPS_PROTECTED_TYPE; //Audit 审计标志（很少使用） //Signer 签名了进程 typedef enum _PS_PROTECTED_SIGNER { PsProtectedSignerNone = 0, PsProtectedSignerAuthenticode, PsProtectedSignerCodeGen, PsProtectedSignerAntimalware, PsProtectedSignerLsa, PsProtectedSignerWindows, PsProtectedSignerWinTcb, PsProtectedSignerWinSystem, PsProtectedSignerApp, PsProtectedSignerMax } PS_PROTECTED_SIGNER, *PPS_PROTECTED_SIGNER; 直接把这个位置修改为0即可\nCmRegisterCallback 直接开始分析一下这个东西具体都干什么了吧, 可以打开了解到这个是一个E语言的东西, 并且他一定是有一个通信码在和什么东西通信的, 因为有一个点击事件, 直接ida开始分析, 打开后直接可以看到了一个地址，R3反正也是通信做的, 大部分功能应该是在驱动里，直接去驱动分析看一下 发现直接download可以的, 发现这个东西在疯狂套娃, ExAllocatePoolWithTag后创建一个系统线程, 线程的入口点就是申请的内存的位置, 由这个sys中藏的一个PE的oep的位置开始执行 直接双机调试开始搞一下, 还是老地方ioploaddriver, 直接下断释放的函数可以看到这个位置是一个PE 在StartRoutine下断看一下主要在做什么 经过分析后, 可以分析到它通过设置CmRegisterCallback注册表回调, 把代码放在这里开始执行用于隐藏自己的驱动代码 分析BE的时候发现实际上是有对这种情况进行检测的, BE中分别对进程线程回调, 以及注册表回调判断回调函数的其实位置是不是被hook, 是不是jmp reg的跳转来判断是不是有问题 直接打开BE逆向发现他取了CmUnRegisterCallback的特征, 因为这里存有相应的表, 里面存放了相对的地址和cookie\nlea rdx, [rsp+38h] lea rcx, [ntkrnlmp!CallbackListHead (fffff8015ea60920)] 直接跑通, 写个代码测试一下可不可以找到相应的位置\n#include \u0026lt;ntddk.h\u0026gt; PVOID GetCmCallbackListHead() { UNICODE_STRING ustr; RtlInitUnicodeString(\u0026amp;ustr, L\u0026#34;CmUnRegisterCallback\u0026#34;); PUCHAR pBase = (PUCHAR)MmGetSystemRoutineAddress(\u0026amp;ustr); if (!pBase) return NULL; for (PUCHAR p = pBase; p \u0026lt; pBase + 0x1000; ++p) { if (!MmIsAddressValid(p) || !MmIsAddressValid(p + 6)) continue; if (p[0] == 0x48 \u0026amp;\u0026amp; p[1] == 0x8D \u0026amp;\u0026amp; p[2] == 0x0D \u0026amp;\u0026amp; p[-5] == 0x48 \u0026amp;\u0026amp; p[-4] == 0x8D \u0026amp;\u0026amp; p[-3] == 0x54) { INT32 disp = *(INT32*)(p + 3); UINT64 off = 0; if (disp \u0026lt;= 0) off = (UINT32)disp | 0xFFFFFFFF00000000ull; else off = (UINT32)disp; PUCHAR pListHead = p + off + 7; if (MmIsAddressValid(pListHead)) return pListHead; } } return NULL; } extern USHORT NtBuildNumber; void DumpCmRegisterCallback() { PVOID pListHead = GetCmCallbackListHead(); //DbgBreakPoint(); if (!pListHead) { DbgPrint(\u0026#34;[-] CallbackListHead not found!\\n\u0026#34;); return; } char* Head = (char*)pListHead; char* Entry = *(char**)Head; int idx = 0; ULONG_PTR Offset = 8; // Win7 SP1及以上偏移 if (NtBuildNumber \u0026lt;= 7600) Offset = 0; // Win7 RTM及以下偏移 while (Entry \u0026amp;\u0026amp; Entry != Head \u0026amp;\u0026amp; MmIsAddressValid(Entry)) { char* p = Entry + Offset; ULONGLONG CallbackAddr = *((ULONGLONG*)p + 5); ULONGLONG Cookie = *((ULONGLONG*)p + 3); if (CallbackAddr \u0026gt;= 0x8000000000000000ull \u0026amp;\u0026amp; MmIsAddressValid((PVOID)CallbackAddr)) DbgPrint(\u0026#34;[CMCallback %d] Callback: %p Cookie: %llx\\n\u0026#34;, idx, (PVOID)CallbackAddr, Cookie); Entry = *(char**)Entry; if (++idx \u0026gt; 64) break; // 防止死循环 } } VOID DriverUnload(PDRIVER_OBJECT pDriver) { DbgPrint(\u0026#34;Unload called!\\n\u0026#34;); } NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg) { DbgPrint(\u0026#34;Driver Loaded\\n\u0026#34;); pDriver-\u0026gt;DriverUnload = DriverUnload; //DbgBreakPoint(); DumpCmRegisterCallback(); return STATUS_SUCCESS; } 可以找到相应的位置, 这里的check的就是模块的头部是jmp reg, 并且reg过去的地址是无模块地址 相应的BE的检测的伪代码 开始过检按钮 相应的回调的位置的check已经可以搞定, 继续分析点击过检测的时候一定会和驱动层进行通信, 直接在这个位置下断即可 点击开始过检, 可以知道流程为控制码0822 -\u0026gt; 0814, 调试可以知道这里通过获取到Protection的offset获取的分别是自己本身的程序和smss.exe的Protection属性进行了交换\nPROCESS ffffc081d05ab080 SessionId: 1 Cid: 1010 Peb: e9f5789000 ParentCid: 0e34 DirBase: 1406a002 ObjectTable: ffff9d8e2a8f2c80 HandleCount: 47. Image: A.exe PROCESS ffffc081cd7634c0 SessionId: none Cid: 0208 Peb: 843a07b000 ParentCid: 0004 DirBase: 136b7b002 ObjectTable: ffff9d8e1f3768c0 HandleCount: 53. Image: smss.exe 因为smss.exe的EPROCESS他获取了后, 可以拿到该进程的保护属性和父进程的pid, 第二个操作就是交换了父进程的pid, 可以看到InheritedFromUniqueProcessId等于了4 取消就是explorer.exe的ParentCid和Protection赋值给了该被保护的程序 伪装进程按钮 获取自身和另一个进程的名字, 把名字复制到被保护的进程里 可以看到名字已经被修改成了explorer.exe 主要这个模块处理了很多peb里的信息这里省略一下有点多, github有一个比较好的项目很像这个模块https://github.com/zhuhuibeishadiao/PathModification\n进程隐藏按钮 发现比较有趣的事情, 好像ydark还是可以扫描到这个被隐藏的进程, 但是任务管理器的没了 看一下他是怎么做的, 他直接把+0x2e8 UniqueProcessId : (null)清空了, 所以任务管理器看不见 但是ydark为什么能看见, 研究了一下是通过句柄表来做的进程的遍历, 可以使用PspCidTable来做这个事情\n遍历PspCidTable枚举进程 PspCidTable这个位置需要通过特征码匹配来看一下是什么值 通过PsLookupProcessByProcessId的E8 call获取到地址后, 直接dq看一下, 这里大概说一下思路和找寻的方法, 代码就不贴了 dq pspcidtable获取了表的地址后, 实际上的类型是_HANDLE_TABLE类型, 可以看到tablecode的低两位代表句柄表的层数, 最多有三层 随便进一个看一下, 可以看到是加密的情况 win10的解密是\u0026gt;\u0026gt; 0x10 \u0026amp; 0xfffffffffffffff0 解密后看一下EPROCESS, 发现是第一个的system 通过这个就可以遍历出id和对应的object, 但是如果要遍历进程的, 还要进行筛选需要知道一个东西叫做OBJECT_TYPE和OBJECT_HEADER, 实际上OBJECT_HEADER是在EPROCESS结构上面的\nkd\u0026gt; dt _OBJECT_HEADER nt!_OBJECT_HEADER +0x000 PointerCount : Int8B +0x008 HandleCount : Int8B +0x008 NextToFree : Ptr64 Void +0x010 Lock : _EX_PUSH_LOCK +0x018 TypeIndex : UChar +0x019 TraceFlags : UChar +0x019 DbgRefTrace : Pos 0, 1 Bit +0x019 DbgTracePermanent : Pos 1, 1 Bit +0x01a InfoMask : UChar +0x01b Flags : UChar +0x01b NewObject : Pos 0, 1 Bit +0x01b KernelObject : Pos 1, 1 Bit +0x01b KernelOnlyAccess : Pos 2, 1 Bit +0x01b ExclusiveObject : Pos 3, 1 Bit +0x01b PermanentObject : Pos 4, 1 Bit +0x01b DefaultSecurityQuota : Pos 5, 1 Bit +0x01b SingleHandleEntry : Pos 6, 1 Bit +0x01b DeletedInline : Pos 7, 1 Bit +0x01c Reserved : Uint4B +0x020 ObjectCreateInfo : Ptr64 _OBJECT_CREATE_INFORMATION +0x020 QuotaBlockCharged : Ptr64 Void +0x028 SecurityDescriptor : Ptr64 Void +0x030 Body : _QUAD 那么windbg看一下这个结构, 判断类型主要的还是这个TypeIndex 这里的解密可以看一下ObGetObjectType 那么实际上的解密就是0xfa ^ 0x8f ^ 0x72 = 0x7 按照这个思路写的代码效果如下: ","permalink":"https://l0x1c.com/posts/dg-pass_anti%E5%88%86%E6%9E%90/","summary":"初步分析 分析到一个E语言的外挂, 但是说的是过检测的外挂, 分析一下, 直接ida一把梭大概看到有用的信息, 内部测试3-A.exe explorer.exe 打开外挂后看到的功能大概有这几个, 加载过检, 开始过检, 伪装进程, 隐藏进程这几个, 大概就能猜到肯定用到了驱动 跑起来后, 第一个功能是开始过检测, 发现修改了R3层的应用层访问的状态为拒绝 直接打开process explorer, 可以发现进程的Protection属性变成了PsProtectedSignerWinTcb-Light, 这里的保护和今年的腾讯游戏安全初赛的那个是一样的PPL 直接windbg看一下进程的EPROCESS结构, 可以看到Protection为0x61 -\u0026gt; 0110 0001b, 可以看到修改的为PsProtectedTypeProtectedLight,PsProtectedSignerWinTcb\n//进程保护类型 typedef enum _PS_PROTECTED_TYPE { PsProtectedTypeNone = 0, PsProtectedTypeProtectedLight = 1, PsProtectedTypeProtected = 2 } PS_PROTECTED_TYPE, *PPS_PROTECTED_TYPE; //Audit 审计标志（很少使用） //Signer 签名了进程 typedef enum _PS_PROTECTED_SIGNER { PsProtectedSignerNone = 0, PsProtectedSignerAuthenticode, PsProtectedSignerCodeGen, PsProtectedSignerAntimalware, PsProtectedSignerLsa, PsProtectedSignerWindows, PsProtectedSignerWinTcb, PsProtectedSignerWinSystem, PsProtectedSignerApp, PsProtectedSignerMax } PS_PROTECTED_SIGNER, *PPS_PROTECTED_SIGNER; 直接把这个位置修改为0即可\nCmRegisterCallback 直接开始分析一下这个东西具体都干什么了吧, 可以打开了解到这个是一个E语言的东西, 并且他一定是有一个通信码在和什么东西通信的, 因为有一个点击事件, 直接ida开始分析, 打开后直接可以看到了一个地址，R3反正也是通信做的, 大部分功能应该是在驱动里，直接去驱动分析看一下 发现直接download可以的, 发现这个东西在疯狂套娃, ExAllocatePoolWithTag后创建一个系统线程, 线程的入口点就是申请的内存的位置, 由这个sys中藏的一个PE的oep的位置开始执行 直接双机调试开始搞一下, 还是老地方ioploaddriver, 直接下断释放的函数可以看到这个位置是一个PE 在StartRoutine下断看一下主要在做什么 经过分析后, 可以分析到它通过设置CmRegisterCallback注册表回调, 把代码放在这里开始执行用于隐藏自己的驱动代码 分析BE的时候发现实际上是有对这种情况进行检测的, BE中分别对进程线程回调, 以及注册表回调判断回调函数的其实位置是不是被hook, 是不是jmp reg的跳转来判断是不是有问题 直接打开BE逆向发现他取了CmUnRegisterCallback的特征, 因为这里存有相应的表, 里面存放了相对的地址和cookie","title":"关于CmRegisterCallback的检测/windows进程隐藏的问题"},{"content":"About Profile ctfer@W\u0026amp;M (Intern) Feiyu Security (2020.8 ~2020.9) (Intern) Virus Analysis Engineer@sangfor (2020.9 ~ 2021.5) Security Enginner@QiAnXin (2021.7 ~ 2024.1) Anti-cheat Engineer@Tencent GameSecurity Interest Cybersecurity Binary Play Game Contact L0x1c3r (at) gmail (dot) com\n","permalink":"https://l0x1c.com/about/","summary":"About Profile ctfer@W\u0026amp;M (Intern) Feiyu Security (2020.8 ~2020.9) (Intern) Virus Analysis Engineer@sangfor (2020.9 ~ 2021.5) Security Enginner@QiAnXin (2021.7 ~ 2024.1) Anti-cheat Engineer@Tencent GameSecurity Interest Cybersecurity Binary Play Game Contact L0x1c3r (at) gmail (dot) com","title":""}]