<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>L0x1c&#39;s Blog</title>
    <link>https://l0x1c.com/</link>
    <description>Recent content on L0x1c&#39;s Blog</description>
    <image>
      <title>L0x1c&#39;s Blog</title>
      <url>https://l0x1c.com/images/papermod-cover.png</url>
      <link>https://l0x1c.com/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.120.4</generator>
    <language>en</language>
    <copyright>PaperMod Contributors</copyright>
    <lastBuildDate>Sun, 12 Oct 2025 19:54:10 +0800</lastBuildDate>
    <atom:link href="https://l0x1c.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>xv6 环境配置</title>
      <link>https://l0x1c.com/posts/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 12 Oct 2025 19:54:10 +0800</pubDate>
      <guid>https://l0x1c.com/posts/xv6-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>xv6 环境配置问题 ( vmare or docker ) 配置的地址: https://pdos.csail.mit.edu/6.828/2020/tools.html 准备的系统： vmware + ubuntu
vmare mit的实验代码:
git clone git://g.csail.mit.edu/xv6-labs-2020 git checkout util 这边遇见的坑大概网上都有解答，唯一的一个位置是，如果出现 user/sh.c:58:1: error 的问题修改代码
加入__attribute__((noreturn)) 即可，后面直接目录下make qemu就可以启动了
配置gdb调试也有点繁琐，主要就是在这个目录下进行 make qemu-gdb，新开一个窗口，那个窗口运行 gdb
举个例子用sleep
这样就可以调试了，具体的一些命令可以看：https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf https://xv6.dgs.zone/tranlate_books/Use%20GUN%20Debugger.html
docker 因为后面准备看csapp lab的适合还是得用到docker去配置环境，所以索性就直接学一下，后面就可以直接用了
直接网上下载docker就可以
docker pull ubuntu docker run -i -t -w /root --name ubuntu ubuntu bash # 连接ubuntu系统 docker start -i ubuntu apt-get update apt-get install vim 需要换个源
vim /etc/apt/source.list #替换 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.</description>
    </item>
    <item>
      <title>Arm 汇编学习</title>
      <link>https://l0x1c.com/posts/arm-%E6%B1%87%E7%BC%96/</link>
      <pubDate>Sun, 12 Oct 2025 00:59:09 +0800</pubDate>
      <guid>https://l0x1c.com/posts/arm-%E6%B1%87%E7%BC%96/</guid>
      <description>ARM 汇编 由于开始好好的接触安卓这些东西，所以还是决定把所有的东西从头到尾的好好学习一下，也是开始记录生活的一种方式吧
主要的学习流程大概这两个：
看一下周壑老师的视频 辅助一下利用 https://azeria-labs.com/ 这个网站上的lab进行学习 ARM 汇编介绍 &amp;amp; 环境搭建 环境需要：Android studio （ 模拟器，ndk交叉编译环境，adb工具 ） ida（ 远程调试 ），keypatch 插件
Android studio &amp;amp; ida 的配置 勾选这几个选项即可，下载完会在上面表示的sdk Location的目录下
安装完之后自己在 .zshrc 中配置一下环境变量
export ANDROID_HOME=&amp;#34;Android/sdk所在路径&amp;#34; export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools export PATH=${PATH}:${ANDROID_HOME}/ndk所在的路径 所需要的东西比如Emulator，ndk这些东西都在这个Location的目录下了
代码的头文件在 toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/include 下
进到android studio中里面自带有一个arm64的emu，avd所在的位置 .android/avd/{emu:name}
以后避免每次都打开 android studio可以用emulator里面命令来启动avd
⚠️ 如果我们后面如果调试或者做什么搞坏了，我们可以直接到 snapshots 目录下把下面的文件删除就行，这样就是冷启动了
配置ida调试就是直接把 android的server通过adb丢进去然后启动，配置一下端口的转发
这样后ida attach就可以看到对应的进程那些了
c编译环境 https://developer.android.google.cn/ndk/guides/ndk-build?hl=en
主要需要的是 Application.mk 和 Android.mk 这两个文件，现在写一个c然后编译一下试试
APP_ABI := arm64-v8a APP_BUILD_SCRIPT := Android.mk APP_PLATFORM := android-16 LOCAL_PATH := $(call my-dir) #LOCAL_ARM_MODE := arm LOCAL_MODULE := hello LOCAL_SRC_FILES := hello.</description>
    </item>
    <item>
      <title>内存管理</title>
      <link>https://l0x1c.com/posts/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 09 Jun 2025 22:32:09 +0800</pubDate>
      <guid>https://l0x1c.com/posts/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>VAD_私有内存 私有内存 像malloc, virtualalloc申请的内存都是私有内存, MapViewofFile, MapViewOfSize, mdl, 这种是映射的内存
这些内存是由一个叫做vadroot的节点来管理的, 可以看一下这个位置 这里如果后续想获取到这个位置的话, 因为每个版本的偏移可能不一样, 可以通过函数PsGetProcessExitStatus来获取对应的偏移 + 4就是vadRoot win10上的结构
+0x658 VadRoot : _RTL_AVL_TREE +0x660 VadHint : 0xffff900f`4bf43e10 Void +0x668 VadCount : 0xde VadRoot: _RTL_AVL_TREE 里面就是代表了二叉搜索树的节点, 而里面的每个节点的结构都是__MMVAD的结构, VadHint多次查询的节点会放在这里, VadCount代表vad节点的个数
kd&amp;gt; dt _RTL_AVL_TREE ffff900f4c129400+0x658 nt!_RTL_AVL_TREE +0x000 Root : 0xffff900f`4bf44810 _RTL_BALANCED_NODE kd&amp;gt; dt 0xffff900f`4bf44810 _RTL_BALANCED_NODE nt!_RTL_BALANCED_NODE +0x000 Children : [2] 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE +0x000 Left : 0xffff900f`4b1dcb10 _RTL_BALANCED_NODE +0x008 Right : 0xffff900f`4bfe65c0 _RTL_BALANCED_NODE +0x010 Red : 0y0 +0x010 Balance : 0y00 +0x010 ParentValue : 0 !</description>
    </item>
    <item>
      <title>minifilter</title>
      <link>https://l0x1c.com/posts/minifilter/</link>
      <pubDate>Sun, 08 Jun 2025 19:55:11 +0800</pubDate>
      <guid>https://l0x1c.com/posts/minifilter/</guid>
      <description>这周主要看了一下minifilter的东西, 网吧, 杀软, 反作弊都会相应的用到这个
minifilter_Nt启动 </description>
    </item>
    <item>
      <title>D3CTF-WriteUp</title>
      <link>https://l0x1c.com/posts/d3ctf_writeup/</link>
      <pubDate>Sun, 01 Jun 2025 17:25:09 +0800</pubDate>
      <guid>https://l0x1c.com/posts/d3ctf_writeup/</guid>
      <description>很久没打ctf了, 正好碰见周末有一点空, 就看了一下d3ctf和windows相关的题目
locked-door 加的是vmp的壳子, 需要调试的话直接用TitanHide - &amp;gt; https://github.com/mrexodia/TitanHide就可以调试起来, download后自行加个签名即可, 发现题目有两个bin文件, 直接可以得到的思路是先dump, 因为一定要读取文件一定会调用readfile, 所以可以根据回溯找到关键位置进行调试 通过readfile回溯已经找到了关键位置, 然后用过函数特征入口点来dump, 正常编程的也就那几个软件, 这个问题在之前我发过看雪的文章可以看一下, 可以看到这里很像入口点了, 看一个正常vs编译出来的程序 比较后可以看很像入口点的位置, 直接dump设置oep, 这样dump后的逻辑就很清晰了 可以看到一个算法, 本身程序对他们的校验的算法是一样的 加密完的数据进行evp的校验 校验过了后才可以走到正确的流程, 参数是key+加密的bin里的data, 那直接替换一下, 就可以得到flag了 d3rpg-revenge 这是一个游戏, 正好我是一个游戏安全的从业者, 直接打开ce开始干, 进入一个房间后, 他让我输入密码, 那么可以对密码的位置进行访问断点, 可以看到可以被很好的断下来 d3rpg.dll+50DEA这里的地址, 这个字符串很可疑, 去搜一下 module Scene_RPG class Secret_Class DELTA = | (($de1ta + 1) * 0xf0000000) def initialize(new_key) @key = str_to_longs(new_key) if @key.length &amp;lt; 4 @key.length.upto(4) { |i| @key[i] = 0 } end end def self.</description>
    </item>
    <item>
      <title>关于CmRegisterCallback的检测/windows进程隐藏的问题</title>
      <link>https://l0x1c.com/posts/dg-pass_anti%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 27 May 2025 18:49:02 +0800</pubDate>
      <guid>https://l0x1c.com/posts/dg-pass_anti%E5%88%86%E6%9E%90/</guid>
      <description>初步分析 分析到一个E语言的外挂, 但是说的是过检测的外挂, 分析一下, 直接ida一把梭大概看到有用的信息, 内部测试3-A.exe explorer.exe 打开外挂后看到的功能大概有这几个, 加载过检, 开始过检, 伪装进程, 隐藏进程这几个, 大概就能猜到肯定用到了驱动 跑起来后, 第一个功能是开始过检测, 发现修改了R3层的应用层访问的状态为拒绝 直接打开process explorer, 可以发现进程的Protection属性变成了PsProtectedSignerWinTcb-Light, 这里的保护和今年的腾讯游戏安全初赛的那个是一样的PPL 直接windbg看一下进程的EPROCESS结构, 可以看到Protection为0x61 -&amp;gt; 0110 0001b, 可以看到修改的为PsProtectedTypeProtectedLight,PsProtectedSignerWinTcb
//进程保护类型 typedef enum _PS_PROTECTED_TYPE { PsProtectedTypeNone = 0, PsProtectedTypeProtectedLight = 1, PsProtectedTypeProtected = 2 } PS_PROTECTED_TYPE, *PPS_PROTECTED_TYPE; //Audit 审计标志（很少使用） //Signer 签名了进程 typedef enum _PS_PROTECTED_SIGNER { PsProtectedSignerNone = 0, PsProtectedSignerAuthenticode, PsProtectedSignerCodeGen, PsProtectedSignerAntimalware, PsProtectedSignerLsa, PsProtectedSignerWindows, PsProtectedSignerWinTcb, PsProtectedSignerWinSystem, PsProtectedSignerApp, PsProtectedSignerMax } PS_PROTECTED_SIGNER, *PPS_PROTECTED_SIGNER; 直接把这个位置修改为0即可
CmRegisterCallback 直接开始分析一下这个东西具体都干什么了吧, 可以打开了解到这个是一个E语言的东西, 并且他一定是有一个通信码在和什么东西通信的, 因为有一个点击事件, 直接ida开始分析, 打开后直接可以看到了一个地址，R3反正也是通信做的, 大部分功能应该是在驱动里，直接去驱动分析看一下 发现直接download可以的, 发现这个东西在疯狂套娃, ExAllocatePoolWithTag后创建一个系统线程, 线程的入口点就是申请的内存的位置, 由这个sys中藏的一个PE的oep的位置开始执行 直接双机调试开始搞一下, 还是老地方ioploaddriver, 直接下断释放的函数可以看到这个位置是一个PE 在StartRoutine下断看一下主要在做什么 经过分析后, 可以分析到它通过设置CmRegisterCallback注册表回调, 把代码放在这里开始执行用于隐藏自己的驱动代码 分析BE的时候发现实际上是有对这种情况进行检测的, BE中分别对进程线程回调, 以及注册表回调判断回调函数的其实位置是不是被hook, 是不是jmp reg的跳转来判断是不是有问题 直接打开BE逆向发现他取了CmUnRegisterCallback的特征, 因为这里存有相应的表, 里面存放了相对的地址和cookie</description>
    </item>
    <item>
      <title></title>
      <link>https://l0x1c.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://l0x1c.com/about/</guid>
      <description>About Profile ctfer@W&amp;amp;M (Intern) Feiyu Security (2020.8 ~2020.9) (Intern) Virus Analysis Engineer@sangfor (2020.9 ~ 2021.5) Security Enginner@QiAnXin (2021.7 ~ 2024.1) Anti-cheat Engineer@Tencent GameSecurity Interest Cybersecurity Binary Play Game Contact L0x1c3r (at) gmail (dot) com</description>
    </item>
  </channel>
</rss>
